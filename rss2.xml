<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0"
  xmlns:atom="http://www.w3.org/2005/Atom"
  xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>Ferron的个人博客</title>
    <link>http://zhuferron.github.io/</link>
    
    <atom:link href="http://zhuferron.github.io/rss2.xml" rel="self" type="application/rss+xml"/>
    
    <description>何谈三观，褒贬任剪，笑骂随便</description>
    <pubDate>Tue, 06 Apr 2021 14:15:47 GMT</pubDate>
    <generator>http://hexo.io/</generator>
    
    <item>
      <title>多人协同开发、版本管理---git分支使用(码云为例)</title>
      <link>http://zhuferron.github.io/2021/04/06/%E5%A4%9A%E4%BA%BA%E5%8D%8F%E5%90%8C%E5%BC%80%E5%8F%91%E3%80%81%E7%89%88%E6%9C%AC%E7%AE%A1%E7%90%86----git%E5%88%86%E6%94%AF%E4%BD%BF%E7%94%A8(%E7%A0%81%E4%BA%91%E4%B8%BA%E4%BE%8B)/</link>
      <guid>http://zhuferron.github.io/2021/04/06/%E5%A4%9A%E4%BA%BA%E5%8D%8F%E5%90%8C%E5%BC%80%E5%8F%91%E3%80%81%E7%89%88%E6%9C%AC%E7%AE%A1%E7%90%86----git%E5%88%86%E6%94%AF%E4%BD%BF%E7%94%A8(%E7%A0%81%E4%BA%91%E4%B8%BA%E4%BE%8B)/</guid>
      <pubDate>Tue, 06 Apr 2021 13:31:47 GMT</pubDate>
      
        
        
      <description>&lt;h2 id=&quot;1、Git安装与配置&quot;&gt;&lt;a href=&quot;#1、Git安装与配置&quot; class=&quot;headerlink&quot; title=&quot;1、Git安装与配置&quot;&gt;&lt;/a&gt;1、Git安装与配置&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;进入git官网&lt;code&gt;https://www.git-</description>
        
      
      
      
      <content:encoded><![CDATA[<h2 id="1、Git安装与配置"><a href="#1、Git安装与配置" class="headerlink" title="1、Git安装与配置"></a>1、Git安装与配置</h2><ul><li><p>进入git官网<code>https://www.git-scm.com/download</code>下载git，安装，安装过程省略，注意要安装gui和bash。其他的配置参考<a href="https://blog.csdn.net/qq_31884737/article/details/108632492%E3%80%82">https://blog.csdn.net/qq_31884737/article/details/108632492。</a></p><p><img src="http://fl.ljuuu.com/img/20210406213801.png"></p></li><li><p>git安装好之后，打开git的安装目录，发现有<code>git-bash.exe</code>和<code>git-cmd.exe</code>两个程序，我们一般都使用bash，通过linux命令来操作。</p></li><li><p>刚安装好git，先用以下命令设置全局有效的用户名和邮箱(下面以我的用户名和邮箱为例)</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git config --global user.name <span class="string">&quot;ferron&quot;</span></span><br><span class="line">git config --gloabl user.email <span class="string">&quot;2963624004@qq.com&quot;</span></span><br></pre></td></tr></table></figure></li><li></li></ul><h2 id="2、连接码云"><a href="#2、连接码云" class="headerlink" title="2、连接码云"></a>2、连接码云</h2><ul><li></li></ul><h2 id="2、项目创建"><a href="#2、项目创建" class="headerlink" title="2、项目创建"></a>2、项目创建</h2>]]></content:encoded>
      
      
      <category domain="http://zhuferron.github.io/categories/%E4%B8%AD%E9%97%B4%E4%BB%B6/">中间件</category>
      
      
      <category domain="http://zhuferron.github.io/tags/%E4%B8%AD%E9%97%B4%E4%BB%B6/">中间件</category>
      
      
      <comments>http://zhuferron.github.io/2021/04/06/%E5%A4%9A%E4%BA%BA%E5%8D%8F%E5%90%8C%E5%BC%80%E5%8F%91%E3%80%81%E7%89%88%E6%9C%AC%E7%AE%A1%E7%90%86----git%E5%88%86%E6%94%AF%E4%BD%BF%E7%94%A8(%E7%A0%81%E4%BA%91%E4%B8%BA%E4%BE%8B)/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>AWS ec2服务器创建多用户登录(使用密码登录)</title>
      <link>http://zhuferron.github.io/2021/04/05/AWS%20ec2%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%88%9B%E5%BB%BA%E5%A4%9A%E7%94%A8%E6%88%B7%E7%99%BB%E5%BD%95(%E4%BD%BF%E7%94%A8%E5%AF%86%E7%A0%81%E7%99%BB%E5%BD%95)/</link>
      <guid>http://zhuferron.github.io/2021/04/05/AWS%20ec2%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%88%9B%E5%BB%BA%E5%A4%9A%E7%94%A8%E6%88%B7%E7%99%BB%E5%BD%95(%E4%BD%BF%E7%94%A8%E5%AF%86%E7%A0%81%E7%99%BB%E5%BD%95)/</guid>
      <pubDate>Mon, 05 Apr 2021 04:31:01 GMT</pubDate>
      
      <description>介绍AWS的ec2云服务器如何使用密码进行多用户登录</description>
      
      
      
      <content:encoded><![CDATA[<h2 id="1、使用ubuntu登录"><a href="#1、使用ubuntu登录" class="headerlink" title="1、使用ubuntu登录"></a>1、使用ubuntu登录</h2><ul><li><p>好像ec2服务器不支持使用root直接登录，但是却支持使用root用户组的用户名登录，不同服务器的登录名不同，具体对应名称参考<a href="https://blog.csdn.net/Linrena/article/details/106171588%E3%80%82%E6%9C%AC%E7%AF%87%E5%8D%9A%E5%AE%A2%E4%BD%BF%E7%94%A8%E7%9A%84%E6%98%AFUbuntu%EF%BC%8C%E7%94%A8%E6%88%B7%E5%90%8D%E4%B8%BAubuntu">https://blog.csdn.net/Linrena/article/details/106171588。本篇博客使用的是Ubuntu，用户名为ubuntu</a></p></li><li><p>使用xshell创建新连接</p><p><img src="http://fl.ljuuu.com/img/20210405124402.png"></p></li><li><p>输入用户名</p><p><img src="http://fl.ljuuu.com/img/20210405124809.png"></p></li><li><p>使用密钥文件登录</p><p><img src="http://fl.ljuuu.com/img/20210405124844.png"></p></li><li><p>登录成功</p><p><img src="http://fl.ljuuu.com/img/20210405124648.png"></p></li></ul><h2 id="2、创建新用户"><a href="#2、创建新用户" class="headerlink" title="2、创建新用户"></a>2、创建新用户</h2><ul><li><p>登录之后，当前用户为<code>ubuntu</code>，使用命令<code>sudo su </code>切换为<code>root</code>用户</p></li><li><p>使用<code>adduser user</code>命令创建一个名字为<code>user</code>新用户</p><p><img src="http://fl.ljuuu.com/img/20210405125309.png"></p><p>极少数情况创建用户时不会让你输入密码，这时候需要使用命令<code>passwd user</code>为该用户创建密码</p></li></ul><h2 id="3、修改配置文件"><a href="#3、修改配置文件" class="headerlink" title="3、修改配置文件"></a>3、修改配置文件</h2><p>因为ec2服务器默认是不允许使用密码登录的，因此需要修改ssh的配置文件让其允许使用密码登录</p><ul><li><p>使用<code>root</code>账户修改<code>sshd_config</code>文件，使用命令<code>vim /etc/ssh/sshd_config</code>。</p></li><li><p>切换成编辑模式将第56行的注释去掉，打开允许密码登录功能。</p><p><img src="http://fl.ljuuu.com/img/20210405125701.png"></p></li><li><p>切换成命令模式，输入<code>wq</code>保存退出。</p></li><li><p>使用命令<code>sudo service ssh restart</code>，重启ssh服务令配置文件生效。</p></li><li><p>重新用新创建的用户登录</p></li></ul><h2 id="4、新用户登录"><a href="#4、新用户登录" class="headerlink" title="4、新用户登录"></a>4、新用户登录</h2><ul><li><img src="http://fl.ljuuu.com/img/20210405130316.png"></li><li><img src="http://fl.ljuuu.com/img/20210405130337.png"></li><li><img src="http://fl.ljuuu.com/img/20210405130422.png"></li></ul><p>登录成功！</p><h2 id="5、允许root用户登录"><a href="#5、允许root用户登录" class="headerlink" title="5、允许root用户登录"></a>5、允许root用户登录</h2><ul><li><p>重新使用用户<code>ubuntu</code>登录，<strong>切换成root用户进行以下操作</strong></p></li><li><p>新的ec2服务器的root账户默认是没有密码的，需要使用命令<code>sudo passwd root</code>给<code>root</code>用户设置密码</p><p><img src="http://fl.ljuuu.com/img/20210405130634.png"></p></li><li><p>使用命令<code>vim /etc/ssh/sshd_config</code>修改<code>sshd_config</code>文件的第32行的<code>PermitRootLogin</code>，并保存退出。</p><p><img src="http://fl.ljuuu.com/img/20210405131026.png"></p></li><li><p>使用命令<code>sudo service ssh restart</code>，重启ssh服务令配置文件生效。</p></li><li><p>重新登录</p><p><img src="http://fl.ljuuu.com/img/20210405131321.png"></p></li></ul><p><img src="http://fl.ljuuu.com/img/20210405131213.png"></p><p><img src="http://fl.ljuuu.com/img/20210405131239.png"></p><p>登录成功，完结撒花！</p>]]></content:encoded>
      
      
      <category domain="http://zhuferron.github.io/categories/%E4%BA%91%E8%AE%A1%E7%AE%97/">云计算</category>
      
      
      <category domain="http://zhuferron.github.io/tags/%E4%BA%91%E8%AE%A1%E7%AE%97/">云计算</category>
      
      
      <comments>http://zhuferron.github.io/2021/04/05/AWS%20ec2%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%88%9B%E5%BB%BA%E5%A4%9A%E7%94%A8%E6%88%B7%E7%99%BB%E5%BD%95(%E4%BD%BF%E7%94%A8%E5%AF%86%E7%A0%81%E7%99%BB%E5%BD%95)/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>创建以太坊钱包</title>
      <link>http://zhuferron.github.io/2021/03/31/%E7%94%9F%E6%88%90%E4%BB%A5%E5%A4%AA%E5%9D%8A%E9%92%B1%E5%8C%85/</link>
      <guid>http://zhuferron.github.io/2021/03/31/%E7%94%9F%E6%88%90%E4%BB%A5%E5%A4%AA%E5%9D%8A%E9%92%B1%E5%8C%85/</guid>
      <pubDate>Wed, 31 Mar 2021 14:27:11 GMT</pubDate>
      
      <description>傻瓜式地介绍了如何创建一个以太坊钱包</description>
      
      
      
      <content:encoded><![CDATA[<h2 id="1、进入官网"><a href="#1、进入官网" class="headerlink" title="1、进入官网"></a>1、进入官网</h2><p>进入MyEtherWaller官网：<a href="https://www.myetherwallet.com/">https://www.myetherwallet.com/</a></p><p><img src="http://fl.ljuuu.com/img/20210331214557.png"></p><p>一路next</p><p><img src="http://fl.ljuuu.com/img/20210331214638.png"></p><p>一定要好好保存好你的密钥和密码，丢了就啥也没了~</p><p><img src="http://fl.ljuuu.com/img/20210331214816.png"></p><h2 id="2、新建钱包"><a href="#2、新建钱包" class="headerlink" title="2、新建钱包"></a>2、新建钱包</h2><p>官方更推荐使用第一种方法(NEW wallet钱包)来创建新钱包，我们使用第二种方式，即密钥库文件创建一个新的ETH钱包，输入密码，<strong>一定一定要记住密码</strong>！</p><p><img src="http://fl.ljuuu.com/img/20210331215120.png"></p><p>等待你的密钥库文件生成，下载密钥库文件，<strong>保存好！</strong></p><p><img src="http://fl.ljuuu.com/img/20210331215521.png"></p><p><strong>下载保存好！</strong></p><p><img src="http://fl.ljuuu.com/img/20210331215815.png"></p><p>开始使用。</p><p><img src="http://fl.ljuuu.com/img/20210331215900.png"></p><p><strong>打开你的密钥库文件，mac后面跟着的就是你钱包的私钥！</strong></p><p><img src="http://fl.ljuuu.com/img/20210331221723.png"></p><h2 id="3、登录钱包"><a href="#3、登录钱包" class="headerlink" title="3、登录钱包"></a>3、登录钱包</h2><p>虽然官方不推荐，但是我们还是使用密钥库文件来登录，<strong>毕竟你的账户也没多少钱，被盗走或者丢失影响也不大！</strong>，</p><p><img src="http://fl.ljuuu.com/img/20210331220048.png"></p><p>可以选择<strong>密钥库文件</strong>或者<strong>私钥</strong>进行登录，这里使用密钥库文件进行登录，第二种方式是助记词方法登录，对应创建ETH钱包时的第三种创建方法！</p><p><img src="http://fl.ljuuu.com/img/20210331220227.png"></p><p>选择你刚刚保存的密钥库文件</p><p><img src="http://fl.ljuuu.com/img/20210331220314.png"></p><p>输入密码</p><p><img src="http://fl.ljuuu.com/img/20210331220345.png"></p><p>钱包页面！</p><p><img src="http://fl.ljuuu.com/img/20210331221320.png"></p><p>这样你就拥有了一个属于你的ETH钱包了！</p>]]></content:encoded>
      
      
      <category domain="http://zhuferron.github.io/categories/%E5%8C%BA%E5%9D%97%E9%93%BE/">区块链</category>
      
      
      <category domain="http://zhuferron.github.io/tags/%E5%8C%BA%E5%9D%97%E9%93%BE/">区块链</category>
      
      
      <comments>http://zhuferron.github.io/2021/03/31/%E7%94%9F%E6%88%90%E4%BB%A5%E5%A4%AA%E5%9D%8A%E9%92%B1%E5%8C%85/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>剑指offer刷题笔记</title>
      <link>http://zhuferron.github.io/2021/03/28/%E5%89%91%E6%8C%87offer%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0/</link>
      <guid>http://zhuferron.github.io/2021/03/28/%E5%89%91%E6%8C%87offer%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0/</guid>
      <pubDate>Sun, 28 Mar 2021 13:45:29 GMT</pubDate>
      
      <description>这是笔者在牛客网上刷剑指offer的题目的刷题笔记，持续更新!!!</description>
      
      
      
      <content:encoded><![CDATA[<h2 id="1、二维数组中的查找"><a href="#1、二维数组中的查找" class="headerlink" title="1、二维数组中的查找"></a>1、二维数组中的查找</h2><p><strong>题目描述</strong></p><p>在一个二维数组中（每个一维数组的长度相同），每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。</p><p><strong>示例</strong></p><p>输入：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">7,[[1,2,8,9],[2,4,9,12],[4,7,10,13],[6,8,11,15]]</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">true</span><br></pre></td></tr></table></figure><p><strong>思路分析</strong></p><p>因为这个一个排好序的二维数组，查找时考虑使用二分查找。然而由题目可知，这个二维数组的排序有一定规律，按照二分查找的思路就是选定一个mid点，然而进行查找。因此考虑选择二维数组右上方的元素作为mid，如果target等于mid，则找到；如果target大于mid，就说明target不在第一行，此时接着判断第二行和最后一列，循环即可；如歌targte小于mid，就说明target不在最后一列，此时接着判断第一行和倒数第二列，循环即可。</p><p><strong>代码</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">Find</span><span class="params">(<span class="keyword">int</span> target, <span class="keyword">int</span> [][] array)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> j = array[<span class="number">0</span>].length-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">boolean</span> flag = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">while</span>(i&lt;=array.length-<span class="number">1</span> &amp;&amp; j&gt;=<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(target == array[i][j])&#123;</span><br><span class="line">                flag=<span class="keyword">true</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(target &gt; array[i][j])&#123;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                j--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> flag;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2、替换空格"><a href="#2、替换空格" class="headerlink" title="2、替换空格"></a>2、替换空格</h2><p><strong>题目描述</strong></p><p>请实现一个函数，将一个字符串中的每个空格替换成“%20”。</p><p><strong>示例</strong></p><p>输入：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&quot;We Are Happy&quot;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&quot;We%20Are%20Happy&quot;</span><br></pre></td></tr></table></figure><p><strong>思路分析</strong></p><p>题目需要替换字符串，因此考虑使用StringBuffer类来实现。新建一个StringBuffer，遍历原字符串，如果字符为空格，则在sb中添加一个%20，如果字符不为空格，则添加该字符。</p><p><strong>代码</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">replaceSpace</span> <span class="params">(String s)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// write code here</span></span><br><span class="line"></span><br><span class="line">    StringBuffer sb = <span class="keyword">new</span> StringBuffer();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;s.length(); i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(s.charAt(i)==<span class="string">&#x27; &#x27;</span>)&#123;</span><br><span class="line">            sb.append(<span class="string">&quot;%20&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            sb.append(s.charAt(i));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sb.toString();     </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3、从尾到头打印链表"><a href="#3、从尾到头打印链表" class="headerlink" title="3、从尾到头打印链表"></a>3、从尾到头打印链表</h2><p><strong>题目描述</strong></p><p>输入一个链表，按链表从尾到头的顺序返回一个ArrayList。</p><p><strong>示例</strong></p><p>输入：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;67,0,24,58&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[58,24,0,67]</span><br></pre></td></tr></table></figure><p><strong>思路分析</strong></p><p>题目说需要从尾到头打印这个链表，因此考虑使用栈来解决。</p><p><strong>代码</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ArrayList&lt;Integer&gt; <span class="title">printListFromTailToHead</span><span class="params">(ListNode listNode)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">        ArrayList array = <span class="keyword">new</span> ArrayList();</span><br><span class="line">        Stack&lt;Integer&gt; stack = <span class="keyword">new</span> Stack&lt;Integer&gt;();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(ListNode node=listNode; node!=<span class="keyword">null</span>; node=node.next)&#123;</span><br><span class="line">            stack.push(node.val);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(!stack.isEmpty())&#123;</span><br><span class="line">            array.add(stack.pop());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> array;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4、重建二叉树"><a href="#4、重建二叉树" class="headerlink" title="4、重建二叉树"></a>4、重建二叉树</h2><p><strong>题目描述</strong></p><p>输入某二叉树的前序遍历和中序遍历的结果，请重建出该二叉树。假设输入的前序遍历和中序遍历的结果中都不含重复的数字。例如输入前序遍历序列{1,2,4,7,3,5,6,8}和中序遍历序列{4,7,2,1,5,3,8,6}，则重建二叉树并返回。</p><p><strong>示例</strong></p><p>输入：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[1,2,3,4,5,6,7],[3,2,4,1,6,5,7]</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;1,2,5,3,4,6,7&#125;</span><br></pre></td></tr></table></figure><p><strong>思路分析</strong></p><p>知道二叉树的前序遍历和中序遍历，可以考虑使用递归来解决。首先通过前序遍历得到该二叉树的root结点，示例中root结点为1。知道root结点后，通过中序遍历知道了root的左子树的前序遍历为<code>[2,3,4]</code>，中序遍历为<code>[3,2,4]</code>，右子树前序遍历为<code>[5,6,7]</code>，<code>[6,5,7]</code>，接着分别对root的左子树和右子树进行同样的递归操作即可。</p><p><strong>代码</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">reConstructBinaryTree</span><span class="params">(<span class="keyword">int</span> [] pre,<span class="keyword">int</span> [] in)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//当前序和中序都为0时，返回null；</span></span><br><span class="line">        <span class="keyword">if</span>(pre.length==<span class="number">0</span> | in.length==<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        TreeNode root = <span class="keyword">new</span> TreeNode(pre[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;in.length; i++)&#123;</span><br><span class="line">            <span class="comment">//从前序遍历中找到中序遍历中的二叉树的根结点</span></span><br><span class="line">            <span class="keyword">if</span>(in[i] == pre[<span class="number">0</span>])&#123;</span><br><span class="line">                root.left=reConstructBinaryTree(Arrays.copyOfRange(pre,<span class="number">1</span>,i+<span class="number">1</span>),Arrays.copyOfRange(in,<span class="number">0</span>,i));</span><br><span class="line">                root.right=reConstructBinaryTree(Arrays.copyOfRange(pre,i+<span class="number">1</span>,pre.length),Arrays.copyOfRange(in,i+<span class="number">1</span>,in.length));</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="5、两个栈来实现一个队列"><a href="#5、两个栈来实现一个队列" class="headerlink" title="5、两个栈来实现一个队列"></a>5、两个栈来实现一个队列</h2><p><strong>题目描述</strong></p><p>用两个栈来实现一个队列，完成队列的Push和Pop操作。 队列中的元素为int类型。</p><p><strong>思路分析</strong></p><p>考虑使用两个栈来实现一个队列，首先考虑的是该队列只进不出，这样就可以直接使用stack1来存储该“队列”的所有元素。一旦考虑到出列的情况，就相当于要把stack1的所有元素先倒置，即把stack1的元素全部装进stack2，这样stack2中的元素就是stack1中所有元素的倒置，这样出列操作就可以通过stack2的pop方法来完成。考虑到这里还不够完整，如果该“队列”需要在出列之后再进列，则应该继续完善进列方法，即把stack2中的元素再push到stack1中，此时为进列模式下的“队列”，此时只需把需要进列的元素push进stack1即可。</p><p><strong>代码</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Stack;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    Stack&lt;Integer&gt; stack1 = <span class="keyword">new</span> Stack&lt;Integer&gt;();</span><br><span class="line">    Stack&lt;Integer&gt; stack2 = <span class="keyword">new</span> Stack&lt;Integer&gt;();</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> node)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(stack1.isEmpty())&#123;</span><br><span class="line">            <span class="keyword">while</span>(!stack2.isEmpty())&#123;</span><br><span class="line">                stack1.push(stack2.pop());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        stack1.push(node);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(stack2.isEmpty())&#123;</span><br><span class="line">            <span class="keyword">while</span>(!stack1.isEmpty())&#123;</span><br><span class="line">                stack2.push(stack1.pop());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> stack2.pop();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="6、旋转数组的最小数字"><a href="#6、旋转数组的最小数字" class="headerlink" title="6、旋转数组的最小数字"></a>6、旋转数组的最小数字</h2><p><strong>题目描述</strong></p><p>把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。<br> 输入一个非递减排序的数组的一个旋转，输出旋转数组的最小元素。<br> NOTE：给出的所有元素都大于0，若数组大小为0，请返回0。</p><p><strong>示例</strong></p><p>输入：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[3,4,5,1,2]</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1</span><br></pre></td></tr></table></figure><p><strong>思路分析</strong></p><p>这题最开始没有思路，网上比较流行的就是使用二分搜索来完成，但是实现的过程也有一些细微的差异，下面列了一个我觉得较为理想的答案。首先mid大于high时，更新左边界值，而当mid小于high时，则更新右边界值，当两者相等时，很难判断，则让high自减1继续判断。</p><p><strong>代码</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minNumberInRotateArray</span><span class="params">(<span class="keyword">int</span> [] array)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(array.length == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> low = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> high = array.length-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(low&lt;high)&#123;</span><br><span class="line">            <span class="keyword">int</span> mid=(low+high)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(array[mid]&gt;array[high])&#123;</span><br><span class="line">                low=mid+<span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(array[mid]==array[high])&#123;</span><br><span class="line">                high=high-<span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                high=mid;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> array[high];    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="7、斐波那契数列"><a href="#7、斐波那契数列" class="headerlink" title="7、斐波那契数列"></a>7、斐波那契数列</h2><p><strong>题目描述</strong></p><p>大家都知道斐波那契数列，现在要求输入一个整数n，请你输出斐波那契数列的第n项（从0开始，第0项为0，第1项是1）。 </p><p><strong>示例</strong></p><p>输入：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">4</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">3</span><br></pre></td></tr></table></figure><p><strong>思路分析</strong></p><p>思路一：递归</p><p>思路二：递归会造成大量的相同的数据，我们可以考虑使用数组来简化存储</p><p>思路三：因此每次递归都只需要用到相邻的两个数，因此可以在思路二的前提下优化存储。</p><p><strong>代码</strong></p><p>思路一：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">Fibonacci</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n==<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(n==<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> Fibonacci(n-<span class="number">1</span>)+Fibonacci(n-<span class="number">2</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>思路二：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">Fibonacci</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] array = <span class="keyword">new</span> <span class="keyword">int</span>[n+<span class="number">5</span>];</span><br><span class="line">        </span><br><span class="line">        array[<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">        array[<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>; i&lt;array.length; i++)&#123;</span><br><span class="line">            array[i]=array[i-<span class="number">1</span>]+array[i-<span class="number">2</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> array[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>思路三：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">Fibonacci</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] array = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">2</span>];</span><br><span class="line">        </span><br><span class="line">        array[<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">        array[<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>; i&lt;=n; i++)&#123;</span><br><span class="line">            array[i%<span class="number">2</span>]=array[(i-<span class="number">1</span>)%<span class="number">2</span>]+array[i%<span class="number">2</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> array[n%<span class="number">2</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="8、跳台阶"><a href="#8、跳台阶" class="headerlink" title="8、跳台阶"></a>8、跳台阶</h2><p><strong>题目描述</strong></p><p>一只青蛙一次可以跳上1级台阶，也可以跳上2级。求该青蛙跳上一个n级的台阶总共有多少种跳法（先后次序不同算不同的结果）。</p><p><strong>思路分析</strong></p><p>思路一：这道题跟前面的斐波那契数列很类似。我们可以用反向思维来理解，假设青蛙跳到第n阶台阶，那么它的上一步会在哪呢？要么在n-1阶台阶，要么在n-2阶台阶，这样我们就可以得到青蛙跳到第n阶台阶的跳法等于青蛙跳到第n-1阶台阶的跳法与跳到第n-2阶台阶的跳法之和。</p><p>思路二：次递归都只需要用到相邻的两个数，因此使用一个长度为2的数组来进行存储每次计算的数。</p><p><strong>代码</strong></p><p>思路一：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">JumpFloor</span><span class="params">(<span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(target==<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(target==<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(target==<span class="number">2</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> JumpFloor(target-<span class="number">1</span>)+JumpFloor(target-<span class="number">2</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>思路二：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">JumpFloor</span><span class="params">(<span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] array = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">2</span>];</span><br><span class="line">        array[<span class="number">0</span>]=<span class="number">1</span>;  <span class="comment">//index=0代表跳上target=1的跳法</span></span><br><span class="line">        array[<span class="number">1</span>]=<span class="number">2</span>;  <span class="comment">//index=1代表跳上target=2的跳法</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>; i&lt;target; i++)&#123;</span><br><span class="line">            array[i%<span class="number">2</span>]=array[(i-<span class="number">1</span>)%<span class="number">2</span>]+array[i%<span class="number">2</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> array[(target-<span class="number">1</span>)%<span class="number">2</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="9、变态跳台阶"><a href="#9、变态跳台阶" class="headerlink" title="9、变态跳台阶"></a>9、变态跳台阶</h2><p><strong>题目描述</strong></p><p>一只青蛙一次可以跳上1级台阶，也可以跳上2级……它也可以跳上n级。求该青蛙跳上一个n级的台阶总共有多少种跳法。</p><p><strong>思路分析</strong></p><p>思路一：这道题跟是跳台阶的拓展，使用数组来存储每次计算的结果即可。比起原来的跳台阶问题，这次跳台阶只需要每次循环加总前面数组的元素即可。</p><p>思路二：f(n)=f(n-1)+f(n-2)……+f(1)；f(n-1)=f(n-2)+f(n-3)……+f(1)；由此可得到f(n)=2f(n-1)，而f(1)等于1，f(2)就等于2，因此f(n)=2的n-1次方。</p><p><strong>代码</strong></p><p>思路一：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">jumpFloorII</span><span class="params">(<span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span>[] array = <span class="keyword">new</span> <span class="keyword">int</span>[target+<span class="number">1</span>];</span><br><span class="line">        array[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">        array[<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>; i&lt;target+<span class="number">1</span>; i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;array.length; j++)&#123;</span><br><span class="line">                count+=array[j];</span><br><span class="line">            &#125;</span><br><span class="line">            array[i]=count;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> array[target];</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>思路二：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">jumpFloorII</span><span class="params">(<span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">int</span>)Math.pow(<span class="number">2</span>,target-<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="10、矩阵覆盖"><a href="#10、矩阵覆盖" class="headerlink" title="10、矩阵覆盖"></a>10、矩阵覆盖</h2><p><strong>题目描述</strong><br>我们可以用2<em>1的小矩形横着或者竖着去覆盖更大的矩形。请问用n个2</em>1的小矩形无重叠地覆盖一个2*n的大矩形，总共有多少种方法？<br>输入：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">4</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">5</span><br></pre></td></tr></table></figure><p><strong>思路分析</strong><br>这同样也是一道递归的题目一个2<em>n的大矩形的覆盖方法，等于2</em>(n-1)的大矩形的覆盖方法加上2*(n-2)的大矩形的覆盖方法，使用数组的方式存储递归结果。<br><strong>代码</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">rectCover</span><span class="params">(<span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] array = <span class="keyword">new</span> <span class="keyword">int</span>[target+<span class="number">5</span>];</span><br><span class="line">        </span><br><span class="line">        array[<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">        array[<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">        array[<span class="number">2</span>]=<span class="number">2</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">3</span>; i&lt;target+<span class="number">1</span>; i++)&#123;</span><br><span class="line">            array[i]=array[i-<span class="number">1</span>]+array[i-<span class="number">2</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> array[target];</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="11、二进制中1的个数"><a href="#11、二进制中1的个数" class="headerlink" title="11、二进制中1的个数"></a>11、二进制中1的个数</h2><p><strong>题目描述</strong><br>输入一个整数，输出该数32位二进制表示中1的个数。其中负数用补码表示。<br>输入：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">10</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2</span><br></pre></td></tr></table></figure><p><strong>思路分析</strong><br>本题因为博主不太熟悉进制转换之间的一些性质，因此只能在百度上找一些参考答案。该答案是把输入数依次无符号右移，并与1进行与运算，然后计算结果为1的个数。<br><strong>代码</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">NumberOf1</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">32</span>; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>((n &gt;&gt;&gt; i &amp; <span class="number">1</span>) == <span class="number">1</span>)</span><br><span class="line">                count++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="12、数值的整数次方"><a href="#12、数值的整数次方" class="headerlink" title="12、数值的整数次方"></a>12、数值的整数次方</h2><p> 给定一个double类型的浮点数base和int类型的整数exponent。求base的exponent次方。 </p><p> 保证base和exponent不同时为0 </p><p>输入：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2,3</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">8.00000</span><br></pre></td></tr></table></figure><p><strong>思路分析</strong></p><p>思路一：无论哪种思路，都需要考虑进行exponent的判断，当exponent小于0时，将base取分数并且exponent取反，当exponent等于0时，直接返回1，当exponent大于0时，思路一就是暴力循环求解。</p><p>思路二：递归的快速幂，当我们要求一个数的8次方时，我们只需要将这个的4次方再平方即可，奇数次方则将其再乘多一个base即可，可构造递归。</p><p><strong>代码</strong></p><p>思路一：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">Power</span><span class="params">(<span class="keyword">double</span> base, <span class="keyword">int</span> exponent)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(exponent&lt;<span class="number">0</span>)&#123;</span><br><span class="line">            base = <span class="number">1</span> / base;</span><br><span class="line">            exponent = -exponent;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(exponent ==<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">double</span> result = base;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;exponent-<span class="number">1</span>; i++)&#123;</span><br><span class="line">                result*=base;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>思路二：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">q_power</span><span class="params">(<span class="keyword">double</span> base, <span class="keyword">int</span> exponent)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(exponent ==<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">double</span> result = q_power(base,exponent/<span class="number">2</span>);</span><br><span class="line">        <span class="keyword">if</span>(exponent%<span class="number">2</span> == <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> result*result*base;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> result * result;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">Power</span><span class="params">(<span class="keyword">double</span> base, <span class="keyword">int</span> exponent)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(exponent&lt;<span class="number">0</span>)&#123;</span><br><span class="line">            base = <span class="number">1</span> / base;</span><br><span class="line">            exponent = -exponent;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> q_power(base,exponent);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="13、调整数组顺序使奇数位于偶数前面"><a href="#13、调整数组顺序使奇数位于偶数前面" class="headerlink" title="13、调整数组顺序使奇数位于偶数前面"></a>13、调整数组顺序使奇数位于偶数前面</h2><p>输入一个整数数组，实现一个函数来调整该数组中数字的顺序，使得所有的奇数位于数组的前半部分，所有的偶数位于数组的后半部分，并保证奇数和奇数，偶数和偶数之间的相对位置不变。</p><p>输入：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[1,2,3,4]</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[1,3,2,4]</span><br></pre></td></tr></table></figure><p><strong>思路分析</strong></p><p>可以参考使用几种常见的排序思想，因为题目要求保证稳定性，故只能考虑使用插入排序和冒泡排序，这里使用插入排序的思想。比较相邻两个元素，当前者是偶数，后者是奇数时调换两者位置。</p><p><strong>代码</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">judge</span><span class="params">(<span class="keyword">int</span> front, <span class="keyword">int</span> back)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(front%<span class="number">2</span>==<span class="number">0</span> &amp;&amp; back%<span class="number">2</span>==<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] reOrderArray (<span class="keyword">int</span>[] array) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;array.length-<span class="number">1</span>; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=i+<span class="number">1</span>; j&gt;<span class="number">0</span> &amp;&amp; judge(array[j-<span class="number">1</span>],array[j]); j--)&#123;</span><br><span class="line">                <span class="keyword">int</span> temp = array[j-<span class="number">1</span>];</span><br><span class="line">                array[j-<span class="number">1</span>] = array[j];</span><br><span class="line">                array[j] = temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> array;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="14、链表中倒数第k个结点"><a href="#14、链表中倒数第k个结点" class="headerlink" title="14、链表中倒数第k个结点"></a>14、链表中倒数第k个结点</h2><p>  输入一个链表，输出该链表中倒数第k个结点。 </p><p>  如果该链表长度小于k，请返回空。 </p><p>输入：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;1,2,3,4,5&#125;,1 </span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;5&#125;</span><br></pre></td></tr></table></figure><p><strong>思路分析</strong></p><p>思路一：首先求出链表的长度len，然后将len与k进行比较，若k大于链表长度，则返回空，否则，就返回链表的第len-k个元素。</p><p>思路二：双指针法。首先定义一个快指针和一个慢指针，快指针先走k步，然后两个指针一起走，当快指针走到链尾时，慢指针刚好在倒数第k个结点。</p><p><strong>代码</strong></p><p>思路一：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">FindKthToTail</span> <span class="params">(ListNode pHead, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> count=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(ListNode node = pHead; node!=<span class="keyword">null</span>; node=node.next)&#123;</span><br><span class="line">            count++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(k&gt;count)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">int</span> step = count-k;</span><br><span class="line">            ListNode node = pHead;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;step; i++)&#123;</span><br><span class="line">                node=node.next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> node;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>思路二：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">FindKthToTail</span> <span class="params">(ListNode pHead, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">        ListNode fast = pHead;</span><br><span class="line">        ListNode slow = pHead;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;k; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(fast==<span class="keyword">null</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            fast=fast.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(fast!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            fast=fast.next;</span><br><span class="line">            slow=slow.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> slow;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="15、反转链表"><a href="#15、反转链表" class="headerlink" title="15、反转链表"></a>15、反转链表</h2><p>输入一个链表，反转链表后，输出新链表的表头。</p><p>输入：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;1,2,3&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;3,2,1&#125;</span><br></pre></td></tr></table></figure><p><strong>思路分析</strong></p><p>使用三个指针，三个指针分别为当前结点的前结点pre，当前结点head，当前结点的后结点next。对当前结点进行循环操作，首先使用next指针记录下当前结点head的下一个结点，然后将当前结点head的下一个结点设为pre，此时这局部的三个结点的前面两个结点就相当于反转了，而后面的结点还在，然后将pre设为head，将head设为next，继续循环即可。</p><p><strong>代码</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">ReverseList</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">        ListNode pre=<span class="keyword">null</span>;</span><br><span class="line">        ListNode next=<span class="keyword">null</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(head!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            next=head.next;</span><br><span class="line">            head.next=pre;</span><br><span class="line">            pre=head;</span><br><span class="line">            head=next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pre;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="16、合并两个排序的链表"><a href="#16、合并两个排序的链表" class="headerlink" title="16、合并两个排序的链表"></a>16、合并两个排序的链表</h2><p>输入两个单调递增的链表，输出两个链表合成后的链表，当然我们需要合成后的链表满足单调不减规则。</p><p>输入：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;1,3,5&#125;,&#123;2,4,6&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;1,2,3,4,5,6&#125;</span><br></pre></td></tr></table></figure><p><strong>思路分析</strong></p><p>使用最容易想到的遍历即可，比较两个链表节点值的大小，然后循环迭代即可！</p><p><strong>代码</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">Merge</span><span class="params">(ListNode list1,ListNode list2)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">        ListNode head = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">        ListNode new_list = head;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(list1 != <span class="keyword">null</span> &amp;&amp; list2 != <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(list1.val &gt;= list2.val)&#123;</span><br><span class="line">                new_list.next = list2;</span><br><span class="line">                list2=list2.next;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                new_list.next = list1;</span><br><span class="line">                list1 = list1.next;</span><br><span class="line">            &#125;</span><br><span class="line">            new_list=new_list.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(list1 != <span class="keyword">null</span>) new_list.next = list1;</span><br><span class="line">        <span class="keyword">if</span>(list2 != <span class="keyword">null</span>) new_list.next = list2;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> head.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="17、树的子结构"><a href="#17、树的子结构" class="headerlink" title="17、树的子结构"></a>17、树的子结构</h2><p>输入两棵二叉树A，B，判断B是不是A的子结构。（ps：我们约定空树不是任意一个树的子结构）</p><p>输入：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;8,8,#,9,#,2,#,5&#125;,&#123;8,9,#,2&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">true</span><br></pre></td></tr></table></figure><p><strong>思路分析</strong></p><p>思路的话就是首先就是从B的根节点开始判断，如果A树中有与B树的根节点一样的节点，再循环遍历B树的左右节点是否跟该节点的左右节点相同即可。</p><p><strong>代码</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">judge</span><span class="params">(TreeNode root1, TreeNode subtree)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(subtree == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">if</span>(root1 == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">if</span>(root1.val == subtree.val)&#123;</span><br><span class="line">            <span class="keyword">return</span> judge(root1.left,subtree.left) &amp;&amp; judge(root1.right, subtree.right);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">HasSubtree</span><span class="params">(TreeNode root1,TreeNode root2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root1 == <span class="keyword">null</span> || root2==<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(root1.val == root2.val)&#123;</span><br><span class="line">            <span class="keyword">if</span>(judge(root1,root2))&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> HasSubtree(root1.left, root2) || HasSubtree(root1.right, root2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="18、二叉树的镜像"><a href="#18、二叉树的镜像" class="headerlink" title="18、二叉树的镜像"></a>18、二叉树的镜像</h2><p><strong>题目描述</strong></p><p>操作给定的二叉树，将其变换为源二叉树的镜像。 </p><p>比如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">源二叉树 </span><br><span class="line">            8</span><br><span class="line">           &#x2F;  \</span><br><span class="line">          6   10</span><br><span class="line">         &#x2F; \  &#x2F; \</span><br><span class="line">        5  7 9 11</span><br><span class="line">        镜像二叉树</span><br><span class="line">            8</span><br><span class="line">           &#x2F;  \</span><br><span class="line">          10   6</span><br><span class="line">         &#x2F; \  &#x2F; \</span><br><span class="line">        11 9 7  5</span><br></pre></td></tr></table></figure><p><strong>示例</strong></p><p>输入：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;8,6,10,5,7,9,11&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;8,10,6,11,9,7,5&#125;</span><br></pre></td></tr></table></figure><p><strong>思路分析</strong></p><p>思路一：使用递归判断，将每个节点的左右节点反转即可。</p><p>思路二：考虑到使用递归存在极大地复杂度，因此提供思路二和思路三，分别使用二叉树的广度优先遍历和深度优先遍历来实现。使用二叉树的广度优先遍历(BFS)，将该二叉树依据广度优先遍历的准则进行左右节点反转。</p><p>思路三：使用二叉树的深度优先遍历(DFS)，将该二叉树依据深度优先遍历的准则进行左右节点反转。</p><p><strong>代码</strong></p><p>思路一：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> TreeNode <span class="title">exchange</span><span class="params">(TreeNode pRoot)</span></span>&#123;</span><br><span class="line">        TreeNode temp = pRoot.left;</span><br><span class="line">        pRoot.left = pRoot.right;</span><br><span class="line">        pRoot.right = temp;</span><br><span class="line">        <span class="keyword">return</span> pRoot;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">Mirror</span> <span class="params">(TreeNode pRoot)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(pRoot == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> pRoot;</span><br><span class="line">        &#125;</span><br><span class="line">        exchange(pRoot);</span><br><span class="line">        Mirror(pRoot.left);</span><br><span class="line">        Mirror(pRoot.right);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> pRoot;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>思路二：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> TreeNode <span class="title">exchange</span><span class="params">(TreeNode pRoot)</span></span>&#123;</span><br><span class="line">        TreeNode temp = pRoot.left;</span><br><span class="line">        pRoot.left = pRoot.right;</span><br><span class="line">        pRoot.right = temp;</span><br><span class="line">        <span class="keyword">return</span> pRoot;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">Mirror</span> <span class="params">(TreeNode pRoot)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(pRoot == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> pRoot;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> LinkedList&lt;TreeNode&gt;();</span><br><span class="line">        queue.add(pRoot);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(!queue.isEmpty())&#123;</span><br><span class="line">            TreeNode node = queue.poll();</span><br><span class="line">            exchange(node);</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span>(node.left != <span class="keyword">null</span>) queue.add(node.left);</span><br><span class="line">            <span class="keyword">if</span>(node.right != <span class="keyword">null</span>) queue.add(node.right);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pRoot;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>思路三：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> TreeNode <span class="title">exchange</span><span class="params">(TreeNode pRoot)</span></span>&#123;</span><br><span class="line">        TreeNode temp = pRoot.left;</span><br><span class="line">        pRoot.left = pRoot.right;</span><br><span class="line">        pRoot.right = temp;</span><br><span class="line">        <span class="keyword">return</span> pRoot;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">Mirror</span> <span class="params">(TreeNode pRoot)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(pRoot == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> pRoot;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        Stack&lt;TreeNode&gt; stack = <span class="keyword">new</span> Stack&lt;TreeNode&gt;();</span><br><span class="line">        stack.push(pRoot);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(!stack.isEmpty())&#123;</span><br><span class="line">            TreeNode node = stack.pop();</span><br><span class="line">            exchange(node);</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span>(node.left != <span class="keyword">null</span>) stack.add(node.left);</span><br><span class="line">            <span class="keyword">if</span>(node.right != <span class="keyword">null</span>) stack.add(node.right);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pRoot;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="19、顺时针打印矩阵"><a href="#19、顺时针打印矩阵" class="headerlink" title="19、顺时针打印矩阵"></a>19、顺时针打印矩阵</h2><p><strong>题目描述</strong></p><p>输入一个矩阵，按照从外向里以顺时针的顺序依次打印出每一个数字，例如，如果输入如下4 X 4矩阵： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 则依次打印出数字1,2,3,4,8,12,16,15,14,13,9,5,6,7,11,10. </p><p><strong>示例</strong></p><p>输入：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[[1,2],[3,4]]</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[1,2,4,3]</span><br></pre></td></tr></table></figure><p><strong>思路分析</strong></p><p>思路一：按顺序输出，定义上下左右四个结点，找到顺时针打印矩阵的规律，当上边界大于下边界或左边界大于右边界时，停止循环。</p><p><strong>代码</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ArrayList&lt;Integer&gt; <span class="title">printMatrix</span><span class="params">(<span class="keyword">int</span> [][] matrix)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">        ArrayList&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> top = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> bottom = matrix.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> right = matrix[<span class="number">0</span>].length - <span class="number">1</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=left; i&lt;=right; i++)&#123;</span><br><span class="line">            list.add(matrix[top][i]);</span><br><span class="line">            &#125;</span><br><span class="line">            top++;</span><br><span class="line">            <span class="keyword">if</span>(top&gt;bottom) <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=top; j&lt;=bottom; j++)&#123;</span><br><span class="line">                list.add(matrix[j][right]);</span><br><span class="line">            &#125;</span><br><span class="line">            right--;</span><br><span class="line">            <span class="keyword">if</span>(left&gt;right) <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> k=right; k&gt;=left; k--)&#123;</span><br><span class="line">                list.add(matrix[bottom][k]);</span><br><span class="line">            &#125;</span><br><span class="line">            bottom--;</span><br><span class="line">            <span class="keyword">if</span>(top&gt;bottom) <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=bottom; j&gt;=top; j--)&#123;</span><br><span class="line">                list.add(matrix[j][left]);</span><br><span class="line">            &#125;</span><br><span class="line">            left++;</span><br><span class="line">            <span class="keyword">if</span>(left&gt;right) <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> list;  </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="20、包含min函数的栈"><a href="#20、包含min函数的栈" class="headerlink" title="20、包含min函数的栈"></a>20、包含min函数的栈</h2><p><strong>题目描述</strong></p><p>定义栈的数据结构，请在该类型中实现一个能够得到栈中所含最小元素的min函数（时间复杂度应为O（1））。</p><p><strong>思路分析</strong></p><p>参考了别人的思路，这里也是使用了两个栈。<br>一个用来存所有的元素<code>stackTotal</code>,另一个用来存加入新的元素后当前<code>stackTotal</code>中对应的最小值。<br>两个栈中的元素数量始终保持一致，当新的元素小于<code>stackLittle</code>栈顶元素时，<code>stackLittle</code>像栈顶push新来的元素，否则，<code>stackLittle</code>向栈顶加入原栈顶元素。<br>执行“pop”方法时，两个栈同时弹出各自的栈顶元素。</p><p><strong>代码</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Stack;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    Stack&lt;Integer&gt; stackTotal = <span class="keyword">new</span> Stack&lt;Integer&gt;();</span><br><span class="line">    Stack&lt;Integer&gt; stackLittle = <span class="keyword">new</span> Stack&lt;Integer&gt;();</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> node)</span> </span>&#123;</span><br><span class="line">        stackTotal.push(node);</span><br><span class="line">        <span class="keyword">if</span>(stackLittle.empty())&#123;</span><br><span class="line">            stackLittle.push(node);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(node &lt;= stackLittle.peek())&#123;</span><br><span class="line">                stackLittle.push(node);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                stackLittle.push(stackLittle.peek());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        stackTotal.pop();</span><br><span class="line">        stackLittle.pop();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">top</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> stackTotal.peek();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">min</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> stackLittle.peek();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="21、栈的压入、弹出序列"><a href="#21、栈的压入、弹出序列" class="headerlink" title="21、栈的压入、弹出序列"></a>21、栈的压入、弹出序列</h2><p><strong>题目描述</strong></p><p>输入两个整数序列，第一个序列表示栈的压入顺序，请判断第二个序列是否可能为该栈的弹出顺序。假设压入栈的所有数字均不相等。例如序列1,2,3,4,5是某栈的压入顺序，序列4,5,3,2,1是该压栈序列对应的一个弹出序列，但4,3,5,1,2就不可能是该压栈序列的弹出序列。（注意：这两个序列的长度是相等的）</p><p><strong>示例</strong></p><p>输入：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[1,2,3,4,5],[4,3,5,1,2]</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">false</span><br></pre></td></tr></table></figure><p><strong>思路分析</strong></p><p>这道题主要是使用模拟的思想，定义一个压入栈，将<code>pushA</code>中的元素一个个压入栈，每次将元素压入栈之后，循环判断栈顶元素是否与出栈列表的元素相等，如果相等则将对应元素出栈，出栈<code>count</code>加1，则循环判断。最后返回压入栈的<code>isEmpty()</code>即可。</p><p><strong>代码</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Stack;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">IsPopOrder</span><span class="params">(<span class="keyword">int</span> [] pushA,<span class="keyword">int</span> [] popA)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">        Stack&lt;Integer&gt; stack = <span class="keyword">new</span> Stack();</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;pushA.length; i++)&#123;</span><br><span class="line">            stack.push(pushA[i]);</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">while</span>(!stack.isEmpty() &amp;&amp; stack.peek()==popA[count])&#123;</span><br><span class="line">                stack.pop();</span><br><span class="line">                count++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> stack.isEmpty();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="22、从上往下打印二叉树"><a href="#22、从上往下打印二叉树" class="headerlink" title="22、从上往下打印二叉树"></a>22、从上往下打印二叉树</h2><p><strong>题目描述</strong></p><p>从上往下打印出二叉树的每个节点，同层节点从左至右打印。</p><p><strong>示例</strong></p><p>输入：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;5,4,#,3,#,2,#,1&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[5,4,3,2,1]</span><br></pre></td></tr></table></figure><p><strong>思路分析</strong></p><p>这道题主要运用的思想就是二叉树的广度优先遍历(BFS)，具体实现参见代码或者第18题的思路分析。</p><p><strong>代码</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ArrayList&lt;Integer&gt; <span class="title">PrintFromTopToBottom</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">        ArrayList&lt;Integer&gt; array = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>) <span class="keyword">return</span> array;</span><br><span class="line">        </span><br><span class="line">        queue.add(root);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(!queue.isEmpty())&#123;</span><br><span class="line">            </span><br><span class="line">            TreeNode node = queue.poll();</span><br><span class="line">            array.add(node.val);</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span>(node.left != <span class="keyword">null</span>) queue.add(node.left);</span><br><span class="line">            <span class="keyword">if</span>(node.right != <span class="keyword">null</span>) queue.add(node.right);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> array;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="23、二叉搜索树的后序遍历序列"><a href="#23、二叉搜索树的后序遍历序列" class="headerlink" title="23、二叉搜索树的后序遍历序列"></a>23、二叉搜索树的后序遍历序列</h2><p><strong>题目描述</strong></p><p>输入一个整数数组，判断该数组是不是某二叉搜索树的后序遍历的结果。如果是则返回true,否则返回false。假设输入的数组的任意两个数字都互不相同。（ps：我们约定空树不是二叉搜素树）</p><p><strong>示例</strong></p><p>输入：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[4,8,6,12,16,14,10]</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">true</span><br></pre></td></tr></table></figure><p><strong>思路分析</strong></p><p>思路一：使用递归判断，二叉树的后序遍历输出时，其最后一个结点为root结点，因此我们将该数组从后往前遍历，找到第一个小于root结点的元素，该节点就是root结点的左子树的根节点，该节点加左边的元素就是root结点的左子树，该节点右边的元素就是root结点的右子树。BST的特点就是左子结点&lt;根结点&lt;右子结点，因此，循环递归判断即可。</p><p><strong>代码</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isBST</span><span class="params">(<span class="keyword">int</span>[] seq, <span class="keyword">int</span> start, <span class="keyword">int</span> root)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(start &gt;= root)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> i = root;</span><br><span class="line">        <span class="keyword">while</span>(i&gt;start &amp;&amp; seq[i-<span class="number">1</span>] &gt; seq[root])&#123;</span><br><span class="line">            i--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = start ; j&lt; i-<span class="number">1</span>;j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(seq[j]&gt;seq[root])&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> isBST(seq,start , i-<span class="number">1</span>)&amp;&amp;isBST(seq,i,root-<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">VerifySquenceOfBST</span><span class="params">(<span class="keyword">int</span> [] sequence)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(sequence.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">return</span> isBST(sequence, <span class="number">0</span>, sequence.length-<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="24、二叉树中和未某一值的路径"><a href="#24、二叉树中和未某一值的路径" class="headerlink" title="24、二叉树中和未某一值的路径"></a>24、二叉树中和未某一值的路径</h2><p><strong>题目描述</strong></p><p>输入一颗二叉树的根节点和一个整数，按字典序打印出二叉树中结点值的和为输入整数的所有路径。路径定义为从树的根结点开始往下一直到叶结点所经过的结点形成一条路径。</p><p><strong>示例</strong></p><p>输入：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;10,5,12,4,7&#125;,22</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[[10,5,7],[10,12]]</span><br></pre></td></tr></table></figure><p><strong>思路分析</strong></p><p>使用递归判断，新建一个result集和list集。当root结点为null时就直接返回result，否则将lroot的值加入list，同时target减去root的值。然后判断此时是否为叶结点，如果是叶结点且target为0，表示此时这条路径就是一个答案，将list加入result，否则继续遍历该结点的左右结点。如果这条路径不合适，则最后去掉list中这条路径上的元素。</p><p><strong>代码</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    ArrayList&lt;ArrayList&lt;Integer&gt;&gt; result = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    ArrayList&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> ArrayList&lt;ArrayList&lt;Integer&gt;&gt; FindPath(TreeNode root,<span class="keyword">int</span> target) &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>) <span class="keyword">return</span> result;</span><br><span class="line">        </span><br><span class="line">        list.add(root.val);</span><br><span class="line">        target-=root.val;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(target==<span class="number">0</span> &amp;&amp; root.left==<span class="keyword">null</span> &amp;&amp; root.right==<span class="keyword">null</span>)&#123;</span><br><span class="line">            result.add(<span class="keyword">new</span> ArrayList&lt;Integer&gt;(list));</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        FindPath(root.left,target);</span><br><span class="line">        FindPath(root.right,target);</span><br><span class="line">        </span><br><span class="line">        list.remove(list.size()-<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content:encoded>
      
      
      <category domain="http://zhuferron.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/">数据结构与算法</category>
      
      
      <category domain="http://zhuferron.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/">数据结构与算法</category>
      
      
      <comments>http://zhuferron.github.io/2021/03/28/%E5%89%91%E6%8C%87offer%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>MybatisPlus学习笔记</title>
      <link>http://zhuferron.github.io/2021/03/24/MybatisPlus%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</link>
      <guid>http://zhuferron.github.io/2021/03/24/MybatisPlus%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</guid>
      <pubDate>Wed, 24 Mar 2021 03:59:49 GMT</pubDate>
      
      <description>根据狂神学习MybatisPlus的笔记，本文深入浅出地讲解了MybatisPlus的使用</description>
      
      
      
      <content:encoded><![CDATA[<h2 id="1、MybatisPlus概述"><a href="#1、MybatisPlus概述" class="headerlink" title="1、MybatisPlus概述"></a>1、MybatisPlus概述</h2><h3 id="1-1、简介"><a href="#1-1、简介" class="headerlink" title="1.1、简介"></a>1.1、简介</h3><p>Mybatis本来就是简化JDBC操作的，<a href="https://github.com/baomidou/mybatis-plus">MyBatis-Plus</a><a href="https://github.com/baomidou/mybatis-plus"> </a><a href="https://github.com/baomidou/mybatis-plus"> (opens new window)</a>（简称 MP）是一个 <a href="http://www.mybatis.org/mybatis-3/">MyBatis</a><a href="http://www.mybatis.org/mybatis-3/"> </a><a href="http://www.mybatis.org/mybatis-3/"> (opens new window)</a> 的增强工具，在 MyBatis 的基础上只做增强不做改变，为简化开发、提高效率而生。</p><p>官网：<a href="https://mp.baomidou.com/">https://mp.baomidou.com/</a></p><p><img src="http://fl.ljuuu.com/img/20210324090355.png"></p><h3 id="1-2、特性"><a href="#1-2、特性" class="headerlink" title="1.2、特性"></a>1.2、特性</h3><ul><li><strong>无侵入</strong>：只做增强不做改变，引入它不会对现有工程产生影响，如丝般顺滑</li><li><strong>损耗小</strong>：启动即会自动注入基本 CURD，性能基本无损耗，直接面向对象操作</li><li><strong>强大的 CRUD 操作</strong>：内置通用 Mapper、通用 Service，仅仅通过少量配置即可实现单表大部分 CRUD 操作，更有强大的条件构造器，满足各类使用需求</li><li><strong>支持 Lambda 形式调用</strong>：通过 Lambda 表达式，方便的编写各类查询条件，无需再担心字段写错</li><li><strong>支持主键自动生成</strong>：支持多达 4 种主键策略（内含分布式唯一 ID 生成器 - Sequence），可自由配置，完美解决主键问题</li><li><strong>支持 ActiveRecord 模式</strong>：支持 ActiveRecord 形式调用，实体类只需继承 Model 类即可进行强大的 CRUD 操作</li><li><strong>支持自定义全局通用操作</strong>：支持全局通用方法注入（ Write once, use anywhere ）</li><li><strong>内置代码生成器</strong>：采用代码或者 Maven 插件可快速生成 Mapper 、 Model 、 Service 、 Controller 层代码，支持模板引擎，更有超多自定义配置等您来使用（<strong>自动帮你生成代码</strong>）</li><li><strong>内置分页插件</strong>：基于 MyBatis 物理分页，开发者无需关心具体操作，配置好插件之后，写分页等同于普通 List 查询</li><li><strong>分页插件支持多种数据库</strong>：支持 MySQL、MariaDB、Oracle、DB2、H2、HSQL、SQLite、Postgre、SQLServer 等多种数据库</li><li><strong>内置性能分析插件</strong>：可输出 Sql 语句以及其执行时间，建议开发测试时启用该功能，能快速揪出慢查询</li><li><strong>内置全局拦截插件</strong>：提供全表 delete 、 update 操作智能分析阻断，也可自定义拦截规则，预防误操作</li></ul><h2 id="2、快速入门"><a href="#2、快速入门" class="headerlink" title="2、快速入门"></a>2、快速入门</h2><ul><li><p>创建数据库<code>db01</code>，创建表<code>user</code>：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span> IF <span class="keyword">EXISTS</span> <span class="keyword">user</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="keyword">user</span></span><br><span class="line">(</span><br><span class="line">id <span class="type">BIGINT</span>(<span class="number">20</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;主键ID&#x27;</span>,</span><br><span class="line">name <span class="type">VARCHAR</span>(<span class="number">30</span>) <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;姓名&#x27;</span>,</span><br><span class="line">age <span class="type">INT</span>(<span class="number">11</span>) <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;年龄&#x27;</span>,</span><br><span class="line">email <span class="type">VARCHAR</span>(<span class="number">50</span>) <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;邮箱&#x27;</span>,</span><br><span class="line"><span class="keyword">PRIMARY</span> KEY (id)</span><br><span class="line">);</span><br><span class="line"><span class="comment">--真实开发中，version(乐观锁)、delete(逻辑删除)、gmt_create、gmt_modified</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="keyword">user</span> (id, name, age, email) <span class="keyword">VALUES</span></span><br><span class="line">(<span class="number">1</span>, <span class="string">&#x27;Jone&#x27;</span>, <span class="number">18</span>, <span class="string">&#x27;test1@baomidou.com&#x27;</span>),</span><br><span class="line">(<span class="number">2</span>, <span class="string">&#x27;Jack&#x27;</span>, <span class="number">20</span>, <span class="string">&#x27;test2@baomidou.com&#x27;</span>),</span><br><span class="line">(<span class="number">3</span>, <span class="string">&#x27;Tom&#x27;</span>, <span class="number">28</span>, <span class="string">&#x27;test3@baomidou.com&#x27;</span>),</span><br><span class="line">(<span class="number">4</span>, <span class="string">&#x27;Sandy&#x27;</span>, <span class="number">21</span>, <span class="string">&#x27;test4@baomidou.com&#x27;</span>),</span><br><span class="line">(<span class="number">5</span>, <span class="string">&#x27;Billie&#x27;</span>, <span class="number">24</span>, <span class="string">&#x27;test5@baomidou.com&#x27;</span>);</span><br></pre></td></tr></table></figure></li><li><p>编写springboot项目，导入依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.1.47<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.projectlombok<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>lombok<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.18.12<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- mybatisplus依赖 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.baomidou<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis-plus-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.0.5<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>说明：我们使用mybatisplus可以节省我们大量的代码，尽量不要同时导入mybatis和mybatisplus</p></li><li><p>连接数据库</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">8080</span></span><br><span class="line"></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">datasource:</span></span><br><span class="line">    <span class="attr">driver-class-name:</span> <span class="string">com.mysql.jdbc.Driver</span></span><br><span class="line">    <span class="attr">url:</span> <span class="string">jdbc:mysql://localhost:3306/db01?useSSL=false&amp;useUnicode=true&amp;characterEncoding=UTF-8&amp;serverTimezone=UTC</span></span><br><span class="line">    <span class="attr">username:</span> <span class="string">root</span></span><br><span class="line">    <span class="attr">password:</span> <span class="string">*********</span></span><br></pre></td></tr></table></figure></li><li><p>传统：pojo-dao(连接mybatis、配置mapper.xml)-service-controller</p></li><li><p>使用mybatisplus</p><ul><li><p>dao</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="meta">@NoArgsConstructor</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> Integer age;</span><br><span class="line">    <span class="keyword">private</span> String email;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>mapper：继承<code>BaseMapper</code>类即可，基本的CRUD方法都有了，你如果需要拓展的方法跟往常一样编写即可</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//在对应的Mapper上面集成基本的类BaseMapper</span></span><br><span class="line"><span class="meta">@Repository</span></span><br><span class="line"><span class="meta">@Mapper</span>  <span class="comment">//这里加@Mapper注解，否则就是在主启动类上添加@MapperScan注解</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserMapper</span> <span class="keyword">extends</span> <span class="title">BaseMapper</span>&lt;<span class="title">User</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">//所有的CRUD已经完成</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>测试</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">contextLoads</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//查询全部用户</span></span><br><span class="line">    <span class="comment">//参数是一个Wrapper，条件构造器</span></span><br><span class="line">    List&lt;User&gt; users = userMapper.selectList(<span class="keyword">null</span>);</span><br><span class="line">    users.forEach(System.out::println);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul><h2 id="3、CRUD"><a href="#3、CRUD" class="headerlink" title="3、CRUD"></a>3、CRUD</h2><h3 id="3-1、插入"><a href="#3-1、插入" class="headerlink" title="3.1、插入"></a>3.1、插入</h3><ul><li><p>测试插入</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//插入测试</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span></span>&#123;</span><br><span class="line">    User user = <span class="keyword">new</span> User();</span><br><span class="line">    user.setName(<span class="string">&quot;ferron&quot;</span>);</span><br><span class="line">    user.setAge(<span class="number">20</span>);</span><br><span class="line">    user.setEmail(<span class="string">&quot;2963624004@qq.com&quot;</span>);</span><br><span class="line">    System.out.println(user);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> insert = userMapper.insert(user);  <span class="comment">//会帮我们自动生成id</span></span><br><span class="line">    System.out.println(insert);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>发现我们没有填写id它竟然会自动帮我们生成id！—&gt;<strong>主键生成算法</strong></p></li><li><p>默认策略：全局唯一ID</p><p><img src="http://fl.ljuuu.com/img/20210324090136.png"></p></li><li><p>雪花算法</p><ul><li>分布式唯一id生成算法汇总：<a href="https://blog.csdn.net/cyl101816/article/details/107002852">https://blog.csdn.net/cyl101816/article/details/107002852</a></li><li>snowflake是Twitter开源的分布式ID生成算法，结果是一个long型的ID。其核心思想是：使用41bit作为毫秒数，10bit作为机器的ID（5个bit是数据中心，5个bit的机器ID），12bit作为毫秒内的流水号（意味着每个节点在每毫秒可以产生 4096 个 ID），最后还有一个符号位，永远是0。具体实现的代码可以参看<a href="https://github.com/twitter/snowflake%E3%80%82">https://github.com/twitter/snowflake。</a></li><li>snowflake算法可以根据自身项目的需要进行一定的修改。比如估算未来的数据中心个数，每个数据中心的机器数以及统一毫秒可以能的并发数来调整在算法中所需要的bit数。</li><li>优点：<ul><li>不依赖于数据库，灵活方便，且性能优于数据库。</li><li>ID按照时间在单机上是递增的。</li></ul></li><li>缺点：<ul><li>在单机上是递增的，但是由于涉及到分布式环境，每台机器上的时钟不可能完全同步，也许有时候也会出现不是全局递增的情况。</li></ul></li></ul></li><li><p>主键自增：</p><ul><li>实体类字段上增加<code>@TableId(type = IdType.AUTO)</code></li><li>数据字段一定要是自增的</li></ul></li><li><p>其他的主键生成策略源代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">enum</span> <span class="title">IdType</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 数据库ID自增</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    AUTO(<span class="number">0</span>),</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 该类型为未设置主键类型</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    NONE(<span class="number">1</span>),</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 用户输入ID</span></span><br><span class="line"><span class="comment">     * 该类型可以通过自己注册自动填充插件进行填充</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    INPUT(<span class="number">2</span>),</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 以下3种类型、只有当插入对象ID 为空，才自动填充。 */</span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 全局唯一ID (idWorker)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    ID_WORKER(<span class="number">3</span>),</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 全局唯一ID (UUID)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    UUID(<span class="number">4</span>),</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 字符串全局唯一ID (idWorker 的字符串表示)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    ID_WORKER_STR(<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> key;</span><br><span class="line"></span><br><span class="line">    IdType(<span class="keyword">int</span> key) &#123;</span><br><span class="line">        <span class="keyword">this</span>.key = key;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="3-2、更新"><a href="#3-2、更新" class="headerlink" title="3.2、更新"></a>3.2、更新</h3><ul><li><p>测试更新</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//更新测试</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span></span>&#123;</span><br><span class="line">    User user = <span class="keyword">new</span> User();</span><br><span class="line">    user.setId(<span class="number">1L</span>);</span><br><span class="line">    user.setEmail(<span class="string">&quot;2963624004@qq.com&quot;</span>);</span><br><span class="line">    System.out.println(user);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> i = userMapper.updateById(user);</span><br><span class="line">    System.out.println(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>探索：发现了我们使用id来更新，想修改什么就创建好对象之后传什么就行了，mybatisplus会帮我们自动使用<strong>动态SQL</strong></p><p><img src="http://fl.ljuuu.com/img/20210324091342.png"></p></li></ul><h3 id="3-3、自动填充"><a href="#3-3、自动填充" class="headerlink" title="3.3、自动填充"></a>3.3、自动填充</h3><p>创建时间、修改时间！这些操作一般都是自动化完成的，我们不希望手动更新</p><p>阿里巴巴开发手册：所有的数据库表都需要有<code>gmt_create</code>和<code>gmt_modified</code>这两个字段，而且需要自动化实现！</p><ul><li><p>方式一：数据库修改(工作中不能使用)</p><ul><li><p>在表中新增字段<code>create_time</code>和<code>update_time</code></p><p><img src="http://fl.ljuuu.com/img/20210324091941.png"></p></li><li><p>同步实体类：使用驼峰命名</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="meta">@NoArgsConstructor</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line">    <span class="keyword">private</span> String email;</span><br><span class="line">    <span class="keyword">private</span> Date createTime;</span><br><span class="line">    <span class="keyword">private</span> Date updateTime;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>再次更新测试</p></li></ul></li><li><p>方式二：代码修改</p><ul><li><p>恢复开始的修改，数据库只添加字段，不修改值等</p><p><img src="http://fl.ljuuu.com/img/20210324092327.png"></p></li><li><p>在实体类的字段上<strong>添加注解</strong>了！</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@TableField(fill = FieldFill.INSERT)</span></span><br><span class="line"><span class="keyword">private</span> Date createTime;</span><br><span class="line"><span class="meta">@TableField(fill = FieldFill.INSERT_UPDATE)</span></span><br><span class="line"><span class="keyword">private</span> Date updateTime;</span><br></pre></td></tr></table></figure></li><li><p>新建<code>handler</code>包，编写对应的处理器来处理注解</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@Component</span>  <span class="comment">//一定不要忘记把处理器加到IOC容器中</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyMetaObjectHandler</span> <span class="keyword">implements</span> <span class="title">MetaObjectHandler</span> </span>&#123;</span><br><span class="line">    <span class="comment">//插入时候的填充策略</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insertFill</span><span class="params">(MetaObject metaObject)</span> </span>&#123;</span><br><span class="line">        log.info(<span class="string">&quot;start insert fill......&quot;</span>);</span><br><span class="line">        <span class="comment">//String fieldName, Object fieldVal, MetaObject metaObject</span></span><br><span class="line">        <span class="keyword">this</span>.setFieldValByName(<span class="string">&quot;createTime&quot;</span>,<span class="keyword">new</span> Date(),metaObject);</span><br><span class="line">        <span class="keyword">this</span>.setFieldValByName(<span class="string">&quot;updateTime&quot;</span>,<span class="keyword">new</span> Date(),metaObject);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//填充时候的填充策略</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">updateFill</span><span class="params">(MetaObject metaObject)</span> </span>&#123;</span><br><span class="line">        log.info(<span class="string">&quot;start update fill......&quot;</span>);</span><br><span class="line">        <span class="keyword">this</span>.setFieldValByName(<span class="string">&quot;updateTime&quot;</span>,<span class="keyword">new</span> Date(),metaObject);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>测试插入</p><p><img src="http://fl.ljuuu.com/img/20210324093255.png"></p></li><li><p>测试更新</p><p><img src="http://fl.ljuuu.com/img/20210324093358.png"></p></li></ul></li></ul><h3 id="3-4、乐观锁"><a href="#3-4、乐观锁" class="headerlink" title="3.4、乐观锁"></a>3.4、乐观锁</h3><p>在面试过程中，我们经常会被遇到乐观锁和悲观锁。</p><p><strong>乐观锁</strong>：它总是会认为不会出现问题，无论干什么都不会上锁，如果出现了问题，再次更新值测试(<strong>version</strong>)</p><p><strong>悲观锁</strong>：它认为怎么都会出现问题，无论干嘛都会上锁，再去操作！</p><p>乐观锁实现方式：</p><ul><li>取出记录时，获取当前version</li><li>更新时，带上这个version</li><li>执行更新时， set version = newVersion where version = oldVersion</li><li>如果version不对，就更新失败</li></ul><p><strong>测试</strong>：</p><ul><li><p>将数据库中添加一个<code>version</code>字段</p><p><img src="http://fl.ljuuu.com/img/20210324094133.png"></p></li><li><p>添加实体类字段</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Version</span></span><br><span class="line"><span class="keyword">private</span> Integer version;</span><br></pre></td></tr></table></figure></li><li><p>新建<code>config</code>包，编写<code>MybatisPlusConfig</code>类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@EnableTransactionManagement</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MybatisPlusConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> OptimisticLockerInterceptor <span class="title">optimisticLockerInterceptor</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> OptimisticLockerInterceptor();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>测试修改成功</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//测试乐观锁</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test3</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//查询用户信息</span></span><br><span class="line">    User user = userMapper.selectById(<span class="number">1L</span>);</span><br><span class="line">    <span class="comment">//修改用户信息</span></span><br><span class="line">    user.setName(<span class="string">&quot;ferron测试&quot;</span>);</span><br><span class="line">    <span class="comment">//执行更新</span></span><br><span class="line">    userMapper.updateById(user);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="http://fl.ljuuu.com/img/20210324094924.png"></p></li><li><p>测试修改实现：乐观锁起作用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//测试乐观锁失败  多线程下</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test4</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//线程1</span></span><br><span class="line">    User user1 = userMapper.selectById(<span class="number">1L</span>);</span><br><span class="line">    user1.setName(<span class="string">&quot;ferron测试1111&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//线程2</span></span><br><span class="line">    User user2 = userMapper.selectById(<span class="number">1L</span>);</span><br><span class="line">    user2.setName(<span class="string">&quot;ferron测试2222&quot;</span>);</span><br><span class="line">    userMapper.updateById(user2);</span><br><span class="line"></span><br><span class="line">    userMapper.updateById(user1);  <span class="comment">//如果没有乐观锁，user1就会覆盖user2的修改</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="http://fl.ljuuu.com/img/20210324095240.png"></p></li><li><p>user1修改失败，可以考虑使用<strong>自旋锁</strong>来尝试多次提交</p></li></ul><h3 id="3-5、查询"><a href="#3-5、查询" class="headerlink" title="3.5、查询"></a>3.5、查询</h3><ul><li><p>按单个id查询</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//查询单个ID</span></span><br><span class="line">User user = userMapper.selectById(<span class="number">1L</span>);</span><br><span class="line">System.out.println(user);</span><br></pre></td></tr></table></figure></li><li><p>按多个id查询</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//查询多个ID</span></span><br><span class="line">List&lt;User&gt; users = userMapper.selectBatchIds(Arrays.asList(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>));</span><br><span class="line">users.forEach(System.out::println);</span><br></pre></td></tr></table></figure></li><li><p>按条件查询</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//条件查询</span></span><br><span class="line"><span class="comment">//new一个查询Map</span></span><br><span class="line">HashMap&lt;String, Object&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"><span class="comment">//添加查询条件</span></span><br><span class="line">map.put(<span class="string">&quot;name&quot;</span>,<span class="string">&quot;ferron&quot;</span>);</span><br><span class="line"><span class="comment">//执行查询</span></span><br><span class="line">List&lt;User&gt; users1 = userMapper.selectByMap(map);</span><br><span class="line">System.out.println(users1);</span><br></pre></td></tr></table></figure></li></ul><h3 id="3-6、分页查询"><a href="#3-6、分页查询" class="headerlink" title="3.6、分页查询"></a>3.6、分页查询</h3><p>原始的分页：原始的limit进行分页</p><p>MybatisPlus分页：</p><ul><li><p>在<code>MybatisPlusConfig</code>中配置分页拦截器插件：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 旧版</span></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> PaginationInterceptor <span class="title">paginationInterceptor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    PaginationInterceptor paginationInterceptor = <span class="keyword">new</span> PaginationInterceptor();</span><br><span class="line">    <span class="keyword">return</span> paginationInterceptor;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>直接使用<code>Page</code>对象即可</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//测试分页</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test6</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//参数一：当前页</span></span><br><span class="line">    <span class="comment">//参数二：页面大小</span></span><br><span class="line">    Page&lt;User&gt; page = <span class="keyword">new</span> Page&lt;&gt;(<span class="number">1</span>,<span class="number">5</span>);</span><br><span class="line">    userMapper.selectPage(page,<span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">    page.getRecords().forEach(System.out::println);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="3-7、删除"><a href="#3-7、删除" class="headerlink" title="3.7、删除"></a>3.7、删除</h3><ul><li><p>根据id删除记录</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i = userMapper.deleteById(<span class="number">1L</span>);</span><br><span class="line">System.out.println(i);</span><br></pre></td></tr></table></figure></li><li><p>根据id批量删除</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i1 = userMapper.deleteBatchIds(Arrays.asList(<span class="number">2</span>, <span class="number">3</span>));</span><br><span class="line">System.out.println(i1);</span><br></pre></td></tr></table></figure></li><li><p>根据条件删除</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">HashMap&lt;String, Object&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">map.put(<span class="string">&quot;name&quot;</span>,<span class="string">&quot;ferron&quot;</span>);</span><br><span class="line">userMapper.deleteByMap(map);</span><br></pre></td></tr></table></figure></li></ul><h3 id="3-8、逻辑删除"><a href="#3-8、逻辑删除" class="headerlink" title="3.8、逻辑删除"></a>3.8、逻辑删除</h3><p>物理删除：从数据库中直接移除</p><p>逻辑删除：在数据库中没有被移除，而是通过一个变量来让他失效！delete=0 =&gt;delete=1</p><p>逻辑删除就相当于一个回收站，网站管理员可以看到被删除的数据！</p><ul><li><p>新增数据库字段</p><p><img src="http://fl.ljuuu.com/img/20210324101615.png"></p></li><li><p>在实体类中添加字段</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@TableLogic</span> <span class="comment">//逻辑删除</span></span><br><span class="line"><span class="keyword">private</span> Integer deleted;</span><br></pre></td></tr></table></figure></li><li><p>在<code>MybatisPlusConfig</code>中配置</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//逻辑删除配置</span></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ISqlInjector <span class="title">sqlInjector</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> LogicSqlInjector();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>在yml文件中添加配置</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">mybatis-plus:</span></span><br><span class="line">  <span class="attr">global-config:</span></span><br><span class="line">    <span class="attr">db-config:</span></span><br><span class="line">      <span class="attr">logic-delete-field:</span> <span class="string">flag</span>  <span class="comment"># 全局逻辑删除的实体字段名(since 3.3.0,配置后可以忽略不配置步骤2)</span></span><br><span class="line">      <span class="attr">logic-delete-value:</span> <span class="number">1</span> <span class="comment"># 逻辑已删除值(默认为 1)</span></span><br><span class="line">      <span class="attr">logic-not-delete-value:</span> <span class="number">0</span> <span class="comment"># 逻辑未删除值(默认为 0)</span></span><br></pre></td></tr></table></figure></li><li><p>测试<strong>逻辑删除</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">/测试逻辑删除</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">test7</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = userMapper.deleteById(<span class="number">4L</span>);</span><br><span class="line">    System.out.println(i);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>注意：<strong>逻辑删除本质是更新操作</strong></p><p><img src="http://fl.ljuuu.com/img/20210324102115.png"></p><p><img src="http://fl.ljuuu.com/img/20210324102151.png"></p></li><li><p>再去查询操作：发现查不到4号用户，deleted属性会被自动拼接上</p><p><img src="http://fl.ljuuu.com/img/20210324102335.png"></p></li></ul><h3 id="3-9、配置日志"><a href="#3-9、配置日志" class="headerlink" title="3.9、配置日志"></a>3.9、配置日志</h3><p>使用了mybatisplus之后，我们所有的SQL语句都不可见，我们需要输出日志</p><ul><li><p>在yml文件中配置日志输出，将其输出在控制台</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">mybatis-plus:</span></span><br><span class="line">  <span class="attr">configuration:</span></span><br><span class="line">    <span class="attr">log-impl:</span> <span class="string">org.apache.ibatis.logging.stdout.StdOutImpl</span></span><br></pre></td></tr></table></figure></li><li><p>测试</p><p><img src="http://fl.ljuuu.com/img/20210324090326.png"></p></li></ul><h2 id="4、MybatisPlus进阶"><a href="#4、MybatisPlus进阶" class="headerlink" title="4、MybatisPlus进阶"></a>4、MybatisPlus进阶</h2><h3 id="4-1、性能分析插件"><a href="#4-1、性能分析插件" class="headerlink" title="4.1、性能分析插件"></a>4.1、性能分析插件</h3><p>我们在平时的开发中，会遇到一些慢sql，MybatisPlus提供了性能分析插件，如果超过一个时间就停止运行</p><ul><li><p>在<code>MybatisPlusConfig</code>中配置</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//性能分析工具</span></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="meta">@Profile(&#123;&quot;dev&quot;,&quot;test&quot;&#125;)</span>  <span class="comment">//在开发环境和测试环境使用，提高效率</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> PerformanceInterceptor <span class="title">performanceInterceptor</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    PerformanceInterceptor performanceInterceptor = <span class="keyword">new</span> PerformanceInterceptor();</span><br><span class="line">    performanceInterceptor.setMaxTime(<span class="number">100</span>);  <span class="comment">//毫秒级别  设置sql查询最大时间</span></span><br><span class="line">    performanceInterceptor.setFormat(<span class="keyword">true</span>);  <span class="comment">//设置sql格式化</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> performanceInterceptor();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>在yml中设置为开发环境</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">profiles:</span></span><br><span class="line">    <span class="attr">active:</span> <span class="string">dev</span></span><br></pre></td></tr></table></figure></li><li><p>测试查询：只要超过了限制时间，就会报异常</p></li></ul><h3 id="4-2、条件查询器Wrapper"><a href="#4-2、条件查询器Wrapper" class="headerlink" title="4.2、条件查询器Wrapper"></a>4.2、条件查询器Wrapper</h3><p><strong>十分重要：Wrapper</strong></p><p>我们如果要使用一些复制的sql就可以使用条件构造器</p><ul><li><p>查询name不为空的用户，并且邮箱不为空的用户，年龄大于等于12</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//查询name不为空的用户，并且邮箱不为空的用户，年龄大于等于12</span></span><br><span class="line">    QueryWrapper&lt;User&gt; wrapper = <span class="keyword">new</span> QueryWrapper&lt;&gt;();</span><br><span class="line">    wrapper</span><br><span class="line">        .isNotNull(<span class="string">&quot;name&quot;</span>)</span><br><span class="line">        .isNotNull(<span class="string">&quot;email&quot;</span>)</span><br><span class="line">        .ge(<span class="string">&quot;age&quot;</span>,<span class="number">12</span>);</span><br><span class="line">    userMapper.selectList(wrapper).forEach(System.out::println);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>查询特定的一个用户，多个用户会模糊</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//查询名字为Ferron超级无敌的用户</span></span><br><span class="line">    QueryWrapper&lt;User&gt; wrapper = <span class="keyword">new</span> QueryWrapper&lt;&gt;();</span><br><span class="line">    wrapper.eq(<span class="string">&quot;name&quot;</span>,<span class="string">&quot;Ferron超级无敌的用户&quot;</span>);</span><br><span class="line">    User user = userMapper.selectOne(wrapper);</span><br><span class="line">    System.out.println(user);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>查询age在20-30的用户的用户个数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test3</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//查询age在20-30的用户的用户个数</span></span><br><span class="line">    QueryWrapper&lt;User&gt; wrapper = <span class="keyword">new</span> QueryWrapper&lt;&gt;();</span><br><span class="line">    wrapper</span><br><span class="line">        .between(<span class="string">&quot;age&quot;</span>,<span class="number">20</span>,<span class="number">30</span>);</span><br><span class="line">    Integer integer = userMapper.selectCount(wrapper);</span><br><span class="line">    System.out.println(integer);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>模糊查询</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test4</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//模糊查询</span></span><br><span class="line">    QueryWrapper&lt;User&gt; wrapper = <span class="keyword">new</span> QueryWrapper&lt;&gt;();</span><br><span class="line">    <span class="comment">//左和右 %e%</span></span><br><span class="line">    wrapper.notLike(<span class="string">&quot;name&quot;</span>,<span class="string">&quot;e&quot;</span>)</span><br><span class="line">        .likeRight(<span class="string">&quot;email&quot;</span>,<span class="string">&quot;t&quot;</span>);</span><br><span class="line"></span><br><span class="line">    List&lt;Map&lt;String, Object&gt;&gt; maps = userMapper.selectMaps(wrapper);</span><br><span class="line">    maps.forEach(System.out::println);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="http://fl.ljuuu.com/img/20210324104753.png"></p></li><li><p>内查询</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test5</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//内查询</span></span><br><span class="line">    QueryWrapper&lt;User&gt; wrapper = <span class="keyword">new</span> QueryWrapper&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//id在子查询中查询出来</span></span><br><span class="line">    wrapper.inSql(<span class="string">&quot;id&quot;</span>,<span class="string">&quot;select id from user where id&gt;3&quot;</span>);</span><br><span class="line"></span><br><span class="line">    List&lt;Object&gt; objects = userMapper.selectObjs(wrapper);</span><br><span class="line">    objects.forEach(System.out::println);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="http://fl.ljuuu.com/img/20210324105125.png"></p></li><li><p>通过id降序排序</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test6</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//通过id降序排序</span></span><br><span class="line">    QueryWrapper&lt;User&gt; wrapper = <span class="keyword">new</span> QueryWrapper&lt;&gt;();</span><br><span class="line">    wrapper.orderByDesc(<span class="string">&quot;id&quot;</span>);</span><br><span class="line"></span><br><span class="line">    List&lt;User&gt; users = userMapper.selectList(wrapper);</span><br><span class="line">    users.forEach(System.out::println);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="http://fl.ljuuu.com/img/20210324105314.png"></p></li></ul><h3 id="4-3、代码自动生成器-牛逼"><a href="#4-3、代码自动生成器-牛逼" class="headerlink" title="4.3、代码自动生成器(牛逼)"></a>4.3、代码自动生成器(牛逼)</h3><p><strong>AutoGenerator 是 MyBatis-Plus 的代码生成器，通过 AutoGenerator 可以快速生成 Entity、Mapper、Mapper XML、Service、Controller 等各个模块的代码，极大的提升了开发效率。</strong></p><p>测试：</p><ul><li><p>在test目录下新建一个代码生成类<code>FerronCode</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FerronCode</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//需要构建一个代码自动生成器 对象</span></span><br><span class="line">        AutoGenerator mpg = <span class="keyword">new</span> AutoGenerator();</span><br><span class="line">        <span class="comment">//配置策略</span></span><br><span class="line">        <span class="comment">//1.全局配置</span></span><br><span class="line">        GlobalConfig gc = <span class="keyword">new</span> GlobalConfig();</span><br><span class="line">        String propertyPath = System.getProperty(<span class="string">&quot;user.dir&quot;</span>);</span><br><span class="line">        gc.setOutputDir(propertyPath+<span class="string">&quot;/src/main/java&quot;</span>);  <span class="comment">//设置生成代码的路径</span></span><br><span class="line">        gc.setAuthor(<span class="string">&quot;Ferron&quot;</span>);</span><br><span class="line">        gc.setOpen(<span class="keyword">false</span>);  <span class="comment">//打开资源管理器</span></span><br><span class="line">        gc.setFileOverride(<span class="keyword">false</span>);  <span class="comment">//是否覆盖原来的代码</span></span><br><span class="line">        gc.setServiceImplName(<span class="string">&quot;%sService&quot;</span>);  <span class="comment">//去掉Service的I前缀</span></span><br><span class="line">        gc.setIdType(IdType.ID_WORKER);  <span class="comment">//设置id策略</span></span><br><span class="line">        gc.setDateType(DateType.ONLY_DATE);</span><br><span class="line">        gc.setSwagger2(<span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">        mpg.setGlobalConfig(gc);  <span class="comment">//添加全局配置</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//2.设置数据源</span></span><br><span class="line">        DataSourceConfig dsc = <span class="keyword">new</span> DataSourceConfig();</span><br><span class="line">        dsc.setUrl(<span class="string">&quot;jdbc:mysql://localhost:3306/db01?useSSL=false&amp;useUnicode=true&amp;characterEncoding=UTF-8&amp;serverTimezone=UTC&quot;</span>);</span><br><span class="line">        dsc.setDriverName(<span class="string">&quot;com.mysql.jdbc.Driver&quot;</span>);</span><br><span class="line">        dsc.setUsername(<span class="string">&quot;root&quot;</span>);</span><br><span class="line">        dsc.setPassword(<span class="string">&quot;sanfashi&quot;</span>);</span><br><span class="line">        dsc.setDbType(DbType.MYSQL);  <span class="comment">//数据库</span></span><br><span class="line">        mpg.setDataSource(dsc);  <span class="comment">//设置数据源</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//3.包的配置</span></span><br><span class="line">        PackageConfig pc = <span class="keyword">new</span> PackageConfig();</span><br><span class="line">        pc.setModuleName(<span class="string">&quot;blog&quot;</span>);</span><br><span class="line">        pc.setParent(<span class="string">&quot;com.ferron&quot;</span>);</span><br><span class="line">        pc.setEntity(<span class="string">&quot;pojo&quot;</span>);</span><br><span class="line">        pc.setMapper(<span class="string">&quot;mapper&quot;</span>);</span><br><span class="line">        pc.setService(<span class="string">&quot;service&quot;</span>);</span><br><span class="line">        pc.setController(<span class="string">&quot;controller&quot;</span>);</span><br><span class="line">        mpg.setPackageInfo(pc);  <span class="comment">//设置包的配置</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4.策略配置</span></span><br><span class="line">        StrategyConfig strategy = <span class="keyword">new</span> StrategyConfig();</span><br><span class="line">        strategy.setInclude(<span class="string">&quot;user&quot;</span>);  <span class="comment">//设置要映射的表名</span></span><br><span class="line">        strategy.setNaming(NamingStrategy.underline_to_camel);</span><br><span class="line">        strategy.setColumnNaming(NamingStrategy.underline_to_camel);</span><br><span class="line">        strategy.setSuperEntityClass(<span class="string">&quot;你自己的父类实体,没有就不用设置!&quot;</span>);</span><br><span class="line">        strategy.setEntityLombokModel(<span class="keyword">true</span>);</span><br><span class="line">        strategy.setRestControllerStyle(<span class="keyword">true</span>);</span><br><span class="line">        <span class="comment">//逻辑删除的字段</span></span><br><span class="line">        strategy.setLogicDeleteFieldName(<span class="string">&quot;deleted&quot;</span>);</span><br><span class="line">        <span class="comment">//自动填充配置</span></span><br><span class="line">        TableFill gmtCreate = <span class="keyword">new</span> TableFill(<span class="string">&quot;gmt_create&quot;</span>, FieldFill.INSERT);</span><br><span class="line">        TableFill gmtModified = <span class="keyword">new</span> TableFill(<span class="string">&quot;gmt_modified&quot;</span>, FieldFill.INSERT_UPDATE);</span><br><span class="line">        ArrayList&lt;TableFill&gt; tableFills = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        tableFills.add(gmtCreate);</span><br><span class="line">        tableFills.add(gmtModified);</span><br><span class="line">        strategy.setTableFillList(tableFills);</span><br><span class="line">        <span class="comment">//乐观锁</span></span><br><span class="line">        strategy.setVersionFieldName(<span class="string">&quot;version&quot;</span>);</span><br><span class="line"></span><br><span class="line">        mpg.setStrategy(strategy);  <span class="comment">//设置策略</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">//执行</span></span><br><span class="line">        mpg.execute();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>这代码可以生成<code>user</code>表的对应包，如果需要生成别的表，<strong>就改一下<code>strategy.setInclude(&quot;user&quot;)</code>的表名就行</strong>，参数也可以传List</p></li></ul>]]></content:encoded>
      
      
      <category domain="http://zhuferron.github.io/categories/%E4%B8%AD%E9%97%B4%E4%BB%B6/">中间件</category>
      
      
      <category domain="http://zhuferron.github.io/tags/MybatisPlus/">MybatisPlus</category>
      
      
      <comments>http://zhuferron.github.io/2021/03/24/MybatisPlus%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>数据结构与算法学习笔记(一)：排序算法(一)</title>
      <link>http://zhuferron.github.io/2021/03/18/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(%E4%B8%80)%EF%BC%9A%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95(%E4%B8%80)/</link>
      <guid>http://zhuferron.github.io/2021/03/18/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(%E4%B8%80)%EF%BC%9A%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95(%E4%B8%80)/</guid>
      <pubDate>Thu, 18 Mar 2021 09:57:57 GMT</pubDate>
      
      <description>这是学习数据结构与算法笔记的第一部分，主要介绍了冒泡，选择，插入和希尔排序这四种排序算法</description>
      
      
      
      <content:encoded><![CDATA[<h2 id="1、冒泡排序"><a href="#1、冒泡排序" class="headerlink" title="1、冒泡排序"></a>1、冒泡排序</h2><h3 id="1-1、算法"><a href="#1-1、算法" class="headerlink" title="1.1、算法"></a>1.1、算法</h3><ol><li>比较待排序序列中两个相邻的元素，前者比后者大则交换</li><li>对于j=i，对j与j+1的元素进行步骤一</li><li>i=0 -&gt; i=N-1</li></ol><h3 id="1-2、性质"><a href="#1-2、性质" class="headerlink" title="1.2、性质"></a>1.2、性质</h3><ul><li>当a[j]=a[j+1]时，冒泡排序不进行交换，因此冒泡排序是<strong>稳定</strong>的</li><li>冒泡排序的平均时间复杂度为o(n^2)，最坏时间复杂度为o(n^2)，最好时间复杂度为o(n)</li></ul><h3 id="1-3、代码实现"><a href="#1-3、代码实现" class="headerlink" title="1.3、代码实现"></a>1.3、代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//比较函数，下同</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">less</span><span class="params">(Comparable v, Comparable w)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> v.compareTo(w) &lt; <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//交换函数，下同</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">exchange</span><span class="params">(Comparable v, Comparable w)</span></span>&#123;</span><br><span class="line">    Comparable temp = v;</span><br><span class="line">    v = w;</span><br><span class="line">    w = temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//冒泡排序</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">bubblesort</span><span class="params">(Comparable[] a)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;a.length; i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=i+<span class="number">1</span>; j&lt;a.length; j++)&#123;  </span><br><span class="line">            <span class="keyword">if</span>(less(a[j+<span class="number">1</span>], a[j]))&#123;</span><br><span class="line">                exchange(a[j], a[j+<span class="number">1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2、选择排序"><a href="#2、选择排序" class="headerlink" title="2、选择排序"></a>2、选择排序</h2><h3 id="2-1、算法"><a href="#2-1、算法" class="headerlink" title="2.1、算法"></a>2.1、算法</h3><ol><li>初始i=0，无序区为[i, N]，有序区为空</li><li>将[i, N]中的最小的元素a[min]取出，并且将a[i]与a[min]交换，此时有序区为[0, i]</li><li>i=0 -&gt; i=N-1</li></ol><h3 id="2-2、性质"><a href="#2-2、性质" class="headerlink" title="2.2、性质"></a>2.2、性质</h3><ul><li>因为选择排序可能将较前面的相等元素交换到后面，所以选择排序是<strong>不稳定</strong>的</li><li>选择排序的平均时间复杂度为o(n^2)，最坏时间复杂度为o(n^2)，最好时间复杂度为o(n^2)</li></ul><h3 id="2-3、代码实现"><a href="#2-3、代码实现" class="headerlink" title="2.3、代码实现"></a>2.3、代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//选择排序</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">selectsort</span><span class="params">(Comparable[] a)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;a.length; i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> min=i;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=i+<span class="number">1</span>; j&lt;a.length; j++)&#123;  <span class="comment">//j=i+1是因为初始min为i，第一次比较是j=i+1与i的比较</span></span><br><span class="line">            <span class="keyword">if</span>(less(a[j], a[min]))&#123;</span><br><span class="line">                min=j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        exchange(a[i],a[min]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3、插入排序"><a href="#3、插入排序" class="headerlink" title="3、插入排序"></a>3、插入排序</h2><h3 id="3-1、算法"><a href="#3-1、算法" class="headerlink" title="3.1、算法"></a>3.1、算法</h3><ol><li>初始i=1，无序区为[i, N]，有序区为第一个元素</li><li>将第i+1个元素取出，依次与第i，i-1…1个元素[<strong>有序区的元素</strong>]比较，将其交换到合适的位置</li><li>i=0 -&gt; i=N-1</li></ol><h3 id="3-2、性质"><a href="#3-2、性质" class="headerlink" title="3.2、性质"></a>3.2、性质</h3><ul><li>插入排序交换与冒泡排序类似，都是相邻两个元素交换，因此是<strong>稳定</strong>的</li><li>插入排序的平均时间复杂度为o(n^2)，最坏时间复杂度为o(n^2)，最好时间复杂度为o(n)</li></ul><h3 id="3-3、代码实现"><a href="#3-3、代码实现" class="headerlink" title="3.3、代码实现"></a>3.3、代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//插入排序</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">insertsort</span><span class="params">(Comparable[] a)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;a.length; i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=i+<span class="number">1</span>; j&gt;<span class="number">0</span> &amp;&amp; less(a[j-<span class="number">1</span>],a[j]))&#123; <span class="comment">//停止条件：a[j]到了合适的位置或者a[j]到了需要的最开始</span></span><br><span class="line">            exchange(a[j-<span class="number">1</span>],a[j]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4、希尔排序"><a href="#4、希尔排序" class="headerlink" title="4、希尔排序"></a>4、希尔排序</h2><h3 id="4-1、算法"><a href="#4-1、算法" class="headerlink" title="4.1、算法"></a>4.1、算法</h3><ol><li>选择一组增量序列：t1, t2,…tq,…tk，其中tk=1，这里选择：N/2, N/4,…, 1</li><li>选择增量序列中一个合适的数字开始排序，这里初始以N/2开始</li><li>h=N/2，将原序列变成h组序列，此时每组序列有2个元素，分别对这h组序列执行插入排序的第一，二步</li><li>h=N/2 -&gt; h=1</li></ol><h3 id="4-2、性质"><a href="#4-2、性质" class="headerlink" title="4.2、性质"></a>4.2、性质</h3><ul><li>希尔排序又叫缩小增量排序，因为它会优先比较距离较远的元素，可以说希尔排序是插入排序的改进版</li><li>希尔排序的核心在于间隔序列的设定。既可以提前设定好间隔序列，也可以动态的定义间隔序列比如：h=h/3或h=h/2</li><li>希尔排序最开始有可能进行长距离的交换，因此是<strong>不稳定</strong>的</li><li>希尔排序的平均时间复杂度为o(n^1.3)，最坏时间复杂度为o(n^2)，最好时间复杂度为o(n)</li></ul><h3 id="4-3、代码实现"><a href="#4-3、代码实现" class="headerlink" title="4.3、代码实现"></a>4.3、代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//希尔排序</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">shellsort</span><span class="params">(Comparable[] a)</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(h&gt;=<span class="number">1</span>)&#123; <span class="comment">//希尔排序停止条件</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=h; i&lt;a.length; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=i; j&gt;=h &amp;&amp; less(a[j], a[j-h]), j-=h)&#123;</span><br><span class="line">                exchange(a[j],a[j-h]);</span><br><span class="line">            &#125;</span><br><span class="line">            h/=<span class="number">3</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content:encoded>
      
      
      <category domain="http://zhuferron.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/">数据结构与算法</category>
      
      
      <category domain="http://zhuferron.github.io/tags/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/">排序算法</category>
      
      
      <comments>http://zhuferron.github.io/2021/03/18/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(%E4%B8%80)%EF%BC%9A%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95(%E4%B8%80)/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>微服务架构及Pig项目分析(二)：SpringCloud微服务技术</title>
      <link>http://zhuferron.github.io/2021/03/17/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84%E4%BB%A5%E5%8F%8APig%E9%A1%B9%E7%9B%AE%E5%88%86%E6%9E%90(%E4%BA%8C)%20/</link>
      <guid>http://zhuferron.github.io/2021/03/17/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84%E4%BB%A5%E5%8F%8APig%E9%A1%B9%E7%9B%AE%E5%88%86%E6%9E%90(%E4%BA%8C)%20/</guid>
      <pubDate>Wed, 17 Mar 2021 00:45:39 GMT</pubDate>
      
      <description>软件体系架构课程论文，这部分主要介绍了微服务存在的问题以及SpringCloud是怎么解决这些问题的</description>
      
      
      
      <content:encoded><![CDATA[<h2 id="2-1、微服务核心问题"><a href="#2-1、微服务核心问题" class="headerlink" title="2.1、微服务核心问题"></a>2.1、微服务核心问题</h2><ol><li><p>微服务架构中有很多服务组件，不同的用户怎么调用不同的服务</p></li><li><p>微服务架构中不同的服务之间怎么进行互相调用</p></li><li><p>微服务架构中怎么对这些不同的服务进行治理</p></li><li><p>微服务架构中某个服务出问题了，怎么解决</p></li></ol><h2 id="2-2、问题一：Zuul-微服务网关"><a href="#2-2、问题一：Zuul-微服务网关" class="headerlink" title="2.2、问题一：Zuul+微服务网关"></a>2.2、问题一：Zuul+微服务网关</h2><p>​    Zuul是Netflix开源的一个API Gateway 服务器,在云平台上提供动态路由，监控，弹性，安全等边缘服务的框架。Zuul相当于是设备和Netflix流应用的Web网站后端所有请求的前门。SpringCloud中集成了Zuul，使用它来解决微服务架构中的问题一。</p><p>​    Zuul的核心便是Servlet中的filter机制的实现，而filter本质上就是一个Servlet，而filter的应用则是Spring中AOP思想的体现，通过在用户在前端与后端通信的过程中增加一个filter，实现动态路由的功能。例如，用户在前端与后端进行交互时，需要一个具体的服务，而后端往往有成百上千个服务，想让前端记住后端服务的名称往往是不现实的，而加入Zuul网关的作用就是，当前端想要调用后端的一个或多个服务时，往往不直接调用，而是统一从Zuul网关调用，Zuul网关将对应的请求转发或重定向到对应的服务。</p><p><img src="http://fl.ljuuu.com/img/20210317083241.png"></p><h2 id="2-3、问题二：Feign-异步调用"><a href="#2-3、问题二：Feign-异步调用" class="headerlink" title="2.3、问题二：Feign+异步调用"></a>2.3、问题二：Feign+异步调用</h2><p>​    Feign是Netflix开发的声明式，模板化的HTTP客户端，其灵感来自Retrofit,JAXRS-2.0以及WebSocket. Feign远程调用的核心就是通过一系列的封装和处理，将以Java注解的方式定义的远程调用API接口，最终转换成HTTP的请求形式，然后将HTTP的请求的响应结果，解码成JavaBean，放回给调用者，其调用过程如下图所示。</p><p><img src="http://fl.ljuuu.com/img/20210317083309.png"></p><p>​    Feign的核心机制就是动态代理，与静态代理不同的是，动态代理的代码不用我们手写，而是可以自动生成。Feign中的动态代理是基于接口的动态代理模式，它是由JDK动态代理的，接口为InvocationHandler，动态代理也是AOP思想的核心。Feign的动态代理会根据你在接口上的@RequestMapping等注解，来动态构造出你要请求的服务的地址最后针对这个地址，发起请求、解析响应。</p><h2 id="2-4、问题三：Eureka-服务注册与发现"><a href="#2-4、问题三：Eureka-服务注册与发现" class="headerlink" title="2.4、问题三：Eureka+服务注册与发现"></a>2.4、问题三：Eureka+服务注册与发现</h2><p>​    Eureka是Netflix开发的服务发现框架，本身是一个基于REST的服务，主要用于定位运行在AWS域中的中间层服务，以达到负载均衡和中间层服务故障转移的目的。SpringCloud将它集成在其子项目spring-cloud-netflix中，以实现SpringCloud的服务发现功能。Eureka中分为eureka server和eureka client。其中eureka server是作为服务的注册与发现中心。eureka client既可以作为服务的生产者，又可以作为服务的消费者。</p><p><img src="http://fl.ljuuu.com/img/20210317083340.png"></p><p>​    其整体架构如上图所示：多个eureka server同步保留着相同的服务信息，作为服务生产者的eureka client需要在eureka server中注册其服务信息，而作为服务消费者的eureka client想要查找一个具体的服务时，首先得去eureka server查找对应服务所对应的eureka client，然后再从对应的eureka client调用对应的服务。</p><h2 id="2-5、问题四：Hystrix-降级"><a href="#2-5、问题四：Hystrix-降级" class="headerlink" title="2.5、问题四：Hystrix+降级"></a>2.5、问题四：Hystrix+降级</h2><p>​    微服务架构的特点就是各个不同的服务分离了，当网站或应用程序有很高的工作量时，就有可能导致部分服务挂了，然而往往不同的服务之间有相互调用，当一个服务挂了，就可能导致其他服务的部分功能也实现不了，这就是服务雪崩效应。</p><p>​    为了避免这种服务雪崩效应，Hystrix提出的一个解决方法就是服务降级。其实现的具体思想就是每个服务发起的请求都通过Hystrix的线程池不同的服务走不同的线程池，实现了不同的服务调度隔离，从而避免服务雪崩的问题。</p>]]></content:encoded>
      
      
      <category domain="http://zhuferron.github.io/categories/%E5%BE%AE%E6%9C%8D%E5%8A%A1/">微服务</category>
      
      
      <category domain="http://zhuferron.github.io/tags/SpringCloud/">SpringCloud</category>
      
      
      <comments>http://zhuferron.github.io/2021/03/17/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84%E4%BB%A5%E5%8F%8APig%E9%A1%B9%E7%9B%AE%E5%88%86%E6%9E%90(%E4%BA%8C)%20/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>微服务架构及Pig项目分析(三)：Pig项目分析</title>
      <link>http://zhuferron.github.io/2021/03/17/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84%E4%BB%A5%E5%8F%8APig%E9%A1%B9%E7%9B%AE%E5%88%86%E6%9E%90(%E4%B8%89)/</link>
      <guid>http://zhuferron.github.io/2021/03/17/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84%E4%BB%A5%E5%8F%8APig%E9%A1%B9%E7%9B%AE%E5%88%86%E6%9E%90(%E4%B8%89)/</guid>
      <pubDate>Wed, 17 Mar 2021 00:39:54 GMT</pubDate>
      
      <description>软件体系架构课程论文，这部分主要对Pig项目分析和源码解读</description>
      
      
      
      <content:encoded><![CDATA[<h2 id="3-1、项目简介"><a href="#3-1、项目简介" class="headerlink" title="3.1、项目简介"></a>3.1、项目简介</h2><p>  本文微服务案例选择的是码云上19.2K star的pig项目，该项目是基于 Spring Cloud Hoxton、Spring Boot 2.4、OAuth2的RBAC权限管理系统。</p><h2 id="3-2、项目技术"><a href="#3-2、项目技术" class="headerlink" title="3.2、项目技术"></a>3.2、项目技术</h2><h3 id="3-2-1、Nacos-服务注册与发现"><a href="#3-2-1、Nacos-服务注册与发现" class="headerlink" title="3.2.1、Nacos 服务注册与发现"></a>3.2.1、Nacos 服务注册与发现</h3><p>​    该项目通过Nacos注册中心来作为协调所有服务，所有服务需要在注册中心进行注册，而一个服务需要调用另外一个服务的时候则先取注册中心查找，然后得到查找结果后再去调用对应的服务。具体过程如下图所示：所有的订单服务都在注册中心中注册，但某一个用户服务需要订单服务时，则去注册中心查找需要的订单服务名字，然后去调用对应的服务。</p><p><img src="http://fl.ljuuu.com/img/20210317083536.png"></p><h3 id="3-2-2、Ribbon负载均衡"><a href="#3-2-2、Ribbon负载均衡" class="headerlink" title="3.2.2、Ribbon负载均衡"></a>3.2.2、Ribbon负载均衡</h3><p>​    Ribbon是Netflix发布的云中间层服务开源项目，其主要功能是提供客户端实现负载均衡算法。负载均衡的调度规则一般为轮询调度或者加权轮询策略，轮询调度算法的原理是每一次把来自用户的请求轮流分配给内部中的服务器，从1开始，直到N(内部服务器个数)，然后重新开始循环。轮询调度算法假设所有服务器的处理性能都相同，不关心每台服务器的当前连接数和响应速度。当请求服务间隔时间变化比较大时，轮询调度算法容易导致服务器间的负载不平衡。所以此种均衡算法适合于服务器组中的所有服务器都有相同的软硬件配置并且平均服务请求相对均衡的情况，因此现实中往往会采用加权轮询策略，而限于本文的篇幅，加权轮询策略原理不再展开。</p><p><img src="http://fl.ljuuu.com/img/20210317083557.png"></p><p>​    在SpringCloud中往往使用Ribbon来实现负载均值，其过程如下图所示：当有一个服务需要调用另外某一个服务时，该服务会向注册中心进行查询，注册中心会返回一个可用的服务实例列表，例如前文的三个订单服务中只有一个订单服务空闲，另外两个订单服务处于高工作量时，用户服务就能得到空闲的订单服务的名称，此时用户服务就可直接调用该空闲的订单服务。</p><p><img src="http://fl.ljuuu.com/img/20210317083609.png"></p><h3 id="3-2-3、GateWay业务网关"><a href="#3-2-3、GateWay业务网关" class="headerlink" title="3.2.3、GateWay业务网关"></a>3.2.3、GateWay业务网关</h3><p>​    面对互联网复杂的业务系统，基本可以将API网关分成两类：流量网关和业务网关。流量网关是指跟具体的后端业务系统和服务完全无关的部分，比如安全策略、全局性流控策略、流量分发策略等。而业务网关针对具体的后端业务系统，或者是服务和业务有一定关联性的部分，并且一般被直接部署在业务服务的前面。业务网关一般部署在流量网关之后，业务系统之前，比流量网关更靠近系统。我们大部分情况下说的 API 网关，狭义上指的是业务网关。并且如果系统的规模不大，我们也会将两者合二为一，使用一个网关来处理所有的工作。</p><p>​    SpringCloud中GateWay作为业务网关的一种，整个作用原理如下图：客户端发送的请求不会直接到服务端，而是首先通过网关系统，如果请求与网关程序定义的路由匹配，则将其发送到网关 Web 处理程序，此处理程序运行特定的请求过滤器链。过滤器之间用虚线分开的原因是过滤器可能会在发送代理请求之前或之后执行逻辑。所有 “pre” 过滤器逻辑先执行，然后执行代理请求，代理请求完成后，执行 “post” 过滤器逻辑。</p><p><img src="http://fl.ljuuu.com/img/20210317083629.png"></p><h3 id="3-2-4、Sentinel-流量保护"><a href="#3-2-4、Sentinel-流量保护" class="headerlink" title="3.2.4、Sentinel 流量保护"></a>3.2.4、Sentinel 流量保护</h3><p>​    Hystrix的产生和原理在前文已经讲述，Sentinel 和 Hystrix 的原则是一致的：当调用链路中某个资源出现不稳定，例如，表现为 timeout，异常比例升高的时候，则对这个资源的调用进行限制，并让请求快速失败，避免影响到其它的资源，最终产生雪崩的效果。但是在限制的手段上，Sentinel 和 Hystrix 采取了完全不一样的方法。Sentinel 对这个问题采取了两种手段：</p><ol><li><p>通过并发线程数进行限制：和资源池隔离的方法不同，Sentinel 通过限制资源并发线程的数量，来减少不稳定资源对其它资源的影响。这样不但没有线程切换的损耗，也不需要您预先分配线程池的大小。当某个资源出现不稳定的情况下，例如响应时间变长，对资源的直接影响就是会造成线程数的逐步堆积。当线程数在特定资源上堆积到一定的数量之后，对该资源的新请求就会被拒绝。堆积的线程完成任务后才开始继续接收请求。</p></li><li><p>通过响应时间对资源进行降级：除了对并发线程数进行控制以外，Sentinel 还可以通过响应时间来快速降级不稳定的资源。当依赖的资源出现响应时间过长后，所有对该资源的访问都会被直接拒绝，直到过了指定的时间窗口之后才重新恢复。</p></li></ol><h2 id="3-3、源码分析"><a href="#3-3、源码分析" class="headerlink" title="3.3、源码分析"></a>3.3、源码分析</h2><h3 id="3-3-1、注册中心源码分析"><a href="#3-3-1、注册中心源码分析" class="headerlink" title="3.3.1、注册中心源码分析"></a>3.3.1、注册中心源码分析</h3><p>​    从码云将pig项目clone到本地之后，使用IDEA打开该项目，SpringBoot项目本质还是一个Maven项目，故将该项目解析成一个Maven项目。</p><p>​    Springcloud-commons包中自动装配了AutoServiceRegistrationAutoConfiguration类，这个类就是与服务注册相关的配置类。如下图所示，找到这个配置类，这个配置类注入了一个AutoServiceRegistration实例。</p><p><img src="http://fl.ljuuu.com/img/20210317083729.png"></p><p>​    分析与AutoServiceRegistration类相关的其他类，发现有个很重要的AbstractAutoServiceRegistration抽象类实现了AutoServiceRegistration这个接口。</p><p><img src="http://fl.ljuuu.com/img/20210317083742.png"></p><p>​    AbstractAutoServiceRegistration类实现了onApplicationEvent抽象方法,并且监听WebServerInitializedEvent事件(当Webserver初始化完成之后) , 调用this.bind ( event )方法。</p><p><img src="http://fl.ljuuu.com/img/20210317083755.png"></p><p>​    最终会调用NacosServiceREgistry.register()方法进行服务注册。</p><p><img src="http://fl.ljuuu.com/img/20210317083808.png"></p><p><img src="http://fl.ljuuu.com/img/20210317083812.png"></p><h3 id="3-3-2、GateWay路由网关源码分析"><a href="#3-3-2、GateWay路由网关源码分析" class="headerlink" title="3.3.2、GateWay路由网关源码分析"></a>3.3.2、GateWay路由网关源码分析</h3><p>​    因为目前SpringCloud未集成Zuul，并且Zuul也已经停止维护，而GateWay与Spring完美集成，因此Pig项目选择用GateWay来做API网关。</p><p>​    GateWay中定义了一个GlobalFilter接口，该接口直译为全局的过滤器，我们知道API网关的本质就是一个或者多个过滤器，因此我们找到该项目中GlobalFilter接口的实现类。</p><p><img src="http://fl.ljuuu.com/img/20210317083832.png"></p><p>​    该类重写了接口中的filter()方法，接收一个ServerWebExchange参数和GatewayFilterChain参数，GatewayFilterChain是一个放行链，其接收参数为一系列过滤器的列表，表示可以对这些过滤器进行建立或者放行。我们重点关注ServerWebExchange参数。</p><p><img src="http://fl.ljuuu.com/img/20210317083843.png"></p><p>​    如上图，ServerWebExchange参数有请求和相应两个数据域，表示从ServerWebExchange参数中我们可以得到从用户那传递过来的请求的具体信息。于是有了下面这一步，从ServerWebExchange中得到请求的信息。</p><p><img src="http://fl.ljuuu.com/img/20210317083854.png"></p><p>然后根据具体的内容，GateWay重写对应的请求路径，将请求实现转发或者重定向。</p><p><img src="http://fl.ljuuu.com/img/20210317083903.png"></p><p>实际上，这里GateWay整个可以看成进入应用程序之前的过滤器，拦截所有请求，然后根据请求内容将请求转发或重定向到具体的业务实现部分，GateWay充当一个中介的作用。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol><li><p><a href="https://www.cnblogs.com/zhangs1986/p/10546973.html">https://www.cnblogs.com/zhangs1986/p/10546973.html</a></p></li><li><p><a href="https://blog.csdn.net/weixin_41217541/article/details/104718834">https://blog.csdn.net/weixin_41217541/article/details/104718834</a></p></li><li><p><a href="https://pig4cloud.com/home">https://pig4cloud.com/home</a></p></li></ol>]]></content:encoded>
      
      
      <category domain="http://zhuferron.github.io/categories/%E5%BE%AE%E6%9C%8D%E5%8A%A1/">微服务</category>
      
      
      <category domain="http://zhuferron.github.io/tags/SpringCloud/">SpringCloud</category>
      
      
      <comments>http://zhuferron.github.io/2021/03/17/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84%E4%BB%A5%E5%8F%8APig%E9%A1%B9%E7%9B%AE%E5%88%86%E6%9E%90(%E4%B8%89)/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>微服务架构及Pig项目分析(一)：微服务简介</title>
      <link>http://zhuferron.github.io/2021/03/17/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84%E4%BB%A5%E5%8F%8APig%E9%A1%B9%E7%9B%AE%E5%88%86%E6%9E%90(%E4%B8%80)/</link>
      <guid>http://zhuferron.github.io/2021/03/17/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84%E4%BB%A5%E5%8F%8APig%E9%A1%B9%E7%9B%AE%E5%88%86%E6%9E%90(%E4%B8%80)/</guid>
      <pubDate>Wed, 17 Mar 2021 00:39:54 GMT</pubDate>
      
      <description>软件体系架构课程论文，这部分主要介绍了微服务的概述和与单体架构的对比</description>
      
      
      
      <content:encoded><![CDATA[<h2 id="1-1、引言"><a href="#1-1、引言" class="headerlink" title="1.1、引言"></a>1.1、引言</h2><p>​    随着互联网技术和社会的快速发展，为了适应日益增长的用户访问量和产品的快速迭代升级，软件体系架构也经历了从繁到简，从最初的单体架构，到后来的MVC架构，再到现在的SOA和微服务架构的发展过程。最初的单体架构，一般一个应用程序就是一个完整的结构体，整个应用程序都只会部署到一个服务器上，但是这种高度耦合性的架构风格存在可维护性，可拓展性不足的缺陷，而且对项目作进一步修改、开发、部署及测试的压力会不断增大，无法满足移动互联网时代业务快速增长和系统快速更新交付的需求。因此微服务架构这种新的架构风格便出现了。</p><p>​    微服务分布式架构具备可扩展性、敏捷性和容错性的优势，同时，容器技术和容器编排管理平台的迅速发展为微服务架构的大规模使用提供了基础支撑，这使得微服务架构逐渐成为了目前最主流的应用解决方案。</p><p><img src="http://fl.ljuuu.com/img/20210317082811.png"></p><h2 id="1-2、概述"><a href="#1-2、概述" class="headerlink" title="1.2、概述"></a>1.2、概述</h2><p>​    服务架构是一种将一个单一应用程序开发为一组小型服务的方法，每个服务运行在自己的进程中，服务间通信采用的轻量级通信机制（通常用HTTP资源API），这些服务围绕业务能力构建并且可通过全自动部署机制独立部署。这些服务公用一个最小型的集中式的管理，服务可用不同的语言进行开发，使用不同的数据储存技术。</p><p>​    下图是目前一个微服务应用程序的架构图，首先用户访问应用程序首先得通过企业防火墙进入负载均衡系统，目前主流的负载均衡技术一般由NGINX来实现，其正向和反向代理技术是负载均衡的核心。负载均衡系统会将工作任务进行平衡、分摊到多个操作单元上进行运行，使不同的任务服务器协同完成工作任务。而微服务架构把传统的架构进行高聚合，低耦合处理，把一个应用程序的开发变成一组服务的开发，把每个具体的服务聚合成一个开发单元，如下图中的图片服务器、文件服务器、群发服务器等等。</p><p><img src="http://fl.ljuuu.com/img/20210317082853.png"></p><h2 id="1-3、单体架构和微服务对比"><a href="#1-3、单体架构和微服务对比" class="headerlink" title="1.3、单体架构和微服务对比"></a>1.3、单体架构和微服务对比</h2><h3 id="1-3-1、微服务架构的优缺点"><a href="#1-3-1、微服务架构的优缺点" class="headerlink" title="1.3.1、微服务架构的优缺点"></a>1.3.1、微服务架构的优缺点</h3><table><thead><tr><th>优点</th><th>缺点</th></tr></thead><tbody><tr><td>易于开发和维护</td><td>运维要求高</td></tr><tr><td>开发和维护单个微服务相对简单</td><td>分布式固有的复杂性</td></tr><tr><td>单个微服务启动较快</td><td>接口调整成本高</td></tr><tr><td>局部修改容易部署</td><td></td></tr><tr><td>技术栈不受限制</td><td></td></tr><tr><td>按需伸缩</td><td></td></tr></tbody></table><h3 id="1-3-2、单体架构的优缺点"><a href="#1-3-2、单体架构的优缺点" class="headerlink" title="1.3.2、单体架构的优缺点"></a>1.3.2、单体架构的优缺点</h3><table><thead><tr><th>优点</th><th>缺点</th></tr></thead><tbody><tr><td>易于开发和测试</td><td>复杂性高</td></tr><tr><td>易于部署</td><td>技术债务</td></tr><tr><td>易于整体扩展</td><td>阻碍技术创新</td></tr></tbody></table>]]></content:encoded>
      
      
      <category domain="http://zhuferron.github.io/categories/%E5%BE%AE%E6%9C%8D%E5%8A%A1/">微服务</category>
      
      
      <category domain="http://zhuferron.github.io/tags/SpringCloud/">SpringCloud</category>
      
      
      <comments>http://zhuferron.github.io/2021/03/17/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84%E4%BB%A5%E5%8F%8APig%E9%A1%B9%E7%9B%AE%E5%88%86%E6%9E%90(%E4%B8%80)/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>初始SpringMVC</title>
      <link>http://zhuferron.github.io/2021/03/17/%E5%88%9D%E8%AF%86SpringMVC/</link>
      <guid>http://zhuferron.github.io/2021/03/17/%E5%88%9D%E8%AF%86SpringMVC/</guid>
      <pubDate>Wed, 17 Mar 2021 00:21:30 GMT</pubDate>
      
      <description>SSM框架部分SpringMVC的学习内容，回顾了servlet实现controller，以及原生态SpringMVC和使用注解实现SpirngMVC</description>
      
      
      
      <content:encoded><![CDATA[<h2 id="1、SpringMVC原理剖析"><a href="#1、SpringMVC原理剖析" class="headerlink" title="1、SpringMVC原理剖析"></a>1、SpringMVC原理剖析</h2><p>SpringMVC是基于Java实现MVC的轻量级Web框架。原来的MVC框架是由servlet，javabean，jsp构成。在SpringMVC中，一切的核心是DispatcherServlet。DispatcherServlet的本质也是一个servlet，用户的所有请求都会通过这个核心的DispatcherServlet，进而协调整个MVC框架。<br>SpringMVC的工作流程如下：</p><ul><li>用户的请求首先会通过DispatcherServlet，DispatcherServlet接收到用户请求的url时，调用HandlerMapping查找对应url的handler，并向DispatcherServlet返回对应的HandlerExecution(handler)。</li><li>DispatcherServlet接收到对应的HandlerExecution，将传递给HandlerAdapter，HandlerAdapter再让具体的控制器(Controller）去执行</li><li>Controller执行业务代码后，将ModelAndView返回给HanderAdapter，HanderAdapter再传递给DispatcherServlet。</li><li>DispatcherServlet接收到ModelAndView结果后，会调用ViewResolver去解析视图。</li><li>DispatcherServlet根据ViewResolver的解析结果，调用具体视图响应给用户。</li></ul><h2 id="2、回顾Servlet"><a href="#2、回顾Servlet" class="headerlink" title="2、回顾Servlet"></a>2、回顾Servlet</h2><p>因为SpringMVC的核心终究还是Servlet，因此在实现SpringMVC之前，我们先来回顾一下之前我们是怎么实现Servlet的。</p><ul><li><p>首先新建一个空Maven项目，删掉其src文件夹，作为本篇文章所有项目的父项目，在父项目中导入相关依赖，同时固定jdk的版本。（因为笔者每次新建项目时jdk默认为1.5，目前对于笔者来说直接使用代码固定jdk版本更方便）</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- Srping依赖 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-webmvc<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.2.9.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- junit单元测试--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.12<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- Servlet依赖 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>javax.servlet<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>javax.servlet-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.0.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- JSP依赖 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>javax.servlet.jsp<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jsp-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- JSTL表达式依赖 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>javax.servlet.jsp.jstl<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jstl-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- Standard标签库 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>taglibs<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>standard<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.1.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--固定jdk版本--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">project.build.sourceEncoding</span>&gt;</span>UTF-8<span class="tag">&lt;/<span class="name">project.build.sourceEncoding</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">maven.compiler.encoding</span>&gt;</span>UTF-8<span class="tag">&lt;/<span class="name">maven.compiler.encoding</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">java.version</span>&gt;</span>11<span class="tag">&lt;/<span class="name">java.version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">maven.compiler.source</span>&gt;</span>11<span class="tag">&lt;/<span class="name">maven.compiler.source</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">maven.compiler.target</span>&gt;</span>11<span class="tag">&lt;/<span class="name">maven.compiler.target</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>新建一个module，添加Web框架支持。</p></li><li><p>编写HelloServlet</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloServlet</span> <span class="keyword">extends</span> <span class="title">HttpServlet</span> </span>&#123;</span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doGet</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line"></span><br><span class="line">       <span class="comment">//业务代码</span></span><br><span class="line">       String msg = <span class="string">&quot;这个Servlet的结果&quot;</span>;</span><br><span class="line">       req.getSession().setAttribute(<span class="string">&quot;msg&quot;</span>,msg);</span><br><span class="line">       <span class="comment">//转发</span></span><br><span class="line">       req.getRequestDispatcher(<span class="string">&quot;/WEB-INF/jsp/test.jsp&quot;</span>).forward(req,resp);</span><br><span class="line"></span><br><span class="line">   &#125;</span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doPost</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">       doGet(req, resp);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>编写前端页面，前端页面提取msg。</p></li><li><p>配置Tomcat，测试。</p><p><img src="http://fl.ljuuu.com/img/20210119151924806.png"></p></li></ul><h2 id="3、原生态SpringMVC"><a href="#3、原生态SpringMVC" class="headerlink" title="3、原生态SpringMVC"></a>3、原生态SpringMVC</h2><ul><li><p>新建一个module，这里建立一个空的Maven项目，同时添加web框架支持。同时在项目结构处新建lib文件夹，手动将依赖导入。（因为不使用模板创建Maven项目有时依赖会无法导入，运行时网页会报404，下面使用注解实现SpringMVC做同样操作）</p></li><li><p>编写web.xml配置文件。在这里注册了SpringMVC的核心DispatcherServlet。因为SpringMVC已经帮我们写好DispatcherServlet，我们只需要直接在web.xml中注册就好了。注册的同时需要绑定springmvc的核心配置文件springmvc-servlet.xml。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">web-app</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://xmlns.jcp.org/xml/ns/javaee&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">version</span>=<span class="string">&quot;4.0&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>springmvc<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span>org.springframework.web.servlet.DispatcherServlet<span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>contextConfigLocation<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>classpath:springmvc-servlet.xml<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">load-on-startup</span>&gt;</span>1<span class="tag">&lt;/<span class="name">load-on-startup</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>springmvc<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">web-app</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>编写核心配置文件springmvc-servlet.xml。在该配置文件中注册SpringMVC中的HandlerMapping，HanderAdapter，ViewResolver。因为这三个SpringMVC也已经帮我们写好了，所以只需要直接注册就行~</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="tag"><span class="string">        https://www.springframework.org/schema/beans/spring-beans.xsd&quot;</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.web.servlet.handler.BeanNameUrlHandlerMapping&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.web.servlet.mvc.SimpleControllerHandlerAdapter&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot;</span> <span class="attr">id</span>=<span class="string">&quot;InternalResourceViewResolver&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;prefix&quot;</span> <span class="attr">value</span>=<span class="string">&quot;/WEB-INF/jsp/&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;suffix&quot;</span> <span class="attr">value</span>=<span class="string">&quot;.jsp&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">    </span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>编写一个控制器HelloController。ModelAndView是用来传递业务结果的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloController</span> <span class="keyword">implements</span> <span class="title">Controller</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ModelAndView <span class="title">handleRequest</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        ModelAndView mav = <span class="keyword">new</span> ModelAndView();</span><br><span class="line"></span><br><span class="line">        mav.addObject(<span class="string">&quot;msg&quot;</span>,<span class="string">&quot;这是SpringMVC的结果&quot;</span>);</span><br><span class="line">        mav.setViewName(<span class="string">&quot;test&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> mav;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>编写完控制器之后，别忘了在springmvc-servlet.xml中注册。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;/t2&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.ferron.controller.HelloController&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>编写前端页面，前端页面提取msg。</p></li><li><p>配置Tomcat，测试</p><p><img src="http://fl.ljuuu.com/img/20210119153755827.png"></p></li></ul><h2 id="4、使用注解实现SpringMVC"><a href="#4、使用注解实现SpringMVC" class="headerlink" title="4、使用注解实现SpringMVC"></a>4、使用注解实现SpringMVC</h2><ul><li><p>新建module，添加web框架支持。</p></li><li><p>编写同上的web.xml配置文件</p></li><li><p>编写核心配置文件springmvc-servlet.xml。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:context</span>=<span class="string">&quot;http://www.springframework.org/schema/context&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:mvc</span>=<span class="string">&quot;http://www.springframework.org/schema/mvc&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="tag"><span class="string">        https://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">        http://www.springframework.org/schema/context</span></span></span><br><span class="line"><span class="tag"><span class="string">        https://www.springframework.org/schema/context/spring-context.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">        http://www.springframework.org/schema/mvc</span></span></span><br><span class="line"><span class="tag"><span class="string">        https://www.springframework.org/schema/mvc/spring-mvc.xsd&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--扫描包下的注解，让注解生效--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">&quot;com.ferron.controller&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mvc:annotation-driven</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot;</span> <span class="attr">id</span>=<span class="string">&quot;InternalResourceViewResolver&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;prefix&quot;</span> <span class="attr">value</span>=<span class="string">&quot;/WEB-INF/jsp/&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;suffix&quot;</span> <span class="attr">value</span>=<span class="string">&quot;.jsp&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>编写一个控制器HelloControllerAnno。使用@Controller注解将其标记为一个控制器，此时就默认注册到springmvc-servlet.xml中了，使用@RequestMapping指定其请求url。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloControllerAnno</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/t3&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">test3</span><span class="params">(Model model)</span></span>&#123;</span><br><span class="line">        model.addAttribute(<span class="string">&quot;msg&quot;</span>,<span class="string">&quot;这是SpringMVC注解的结果&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;test&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>编写前端页面，提取msg。</p></li><li><p>配置Tomcat，测试</p><p><img src="http://fl.ljuuu.com/img/20210119155942891.png"></p></li></ul><h2 id="5、结尾"><a href="#5、结尾" class="headerlink" title="5、结尾"></a>5、结尾</h2><p>笔者是一个喜欢编程的985理工男，金融科技专业。目前在学习Java全栈技术，过段时间可能会开始接触大数据架构、区块链技术、云计算架构和人工智能等技术的学习，这是我第一次写博客，不足之处希望大家多多谅解.</p><p><img src="http://fl.ljuuu.com/img/20210119163223168.png">————————————————<br>版权声明：本文为CSDN博主「Ferron Zhu」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。<br>原文链接：<a href="https://blog.csdn.net/Ferronzhu/article/details/112792747">https://blog.csdn.net/Ferronzhu/article/details/112792747</a></p>]]></content:encoded>
      
      
      <category domain="http://zhuferron.github.io/categories/SSM/">SSM</category>
      
      
      <category domain="http://zhuferron.github.io/tags/Spring/">Spring</category>
      
      
      <comments>http://zhuferron.github.io/2021/03/17/%E5%88%9D%E8%AF%86SpringMVC/#disqus_thread</comments>
      
    </item>
    
  </channel>
</rss>
