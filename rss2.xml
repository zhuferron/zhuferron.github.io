<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0"
  xmlns:atom="http://www.w3.org/2005/Atom"
  xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>Ferron的个人博客</title>
    <link>http://zhuferron.github.io/</link>
    
    <atom:link href="http://zhuferron.github.io/rss2.xml" rel="self" type="application/rss+xml"/>
    
    <description>何谈三观，褒贬任剪，笑骂随便</description>
    <pubDate>Thu, 06 May 2021 08:25:35 GMT</pubDate>
    <generator>http://hexo.io/</generator>
    
    <item>
      <title>Java中==与equals的区别浅谈</title>
      <link>http://zhuferron.github.io/2021/05/06/Java%E4%B8%AD==%E4%B8%8Eequals%E7%9A%84%E5%8C%BA%E5%88%AB/</link>
      <guid>http://zhuferron.github.io/2021/05/06/Java%E4%B8%AD==%E4%B8%8Eequals%E7%9A%84%E5%8C%BA%E5%88%AB/</guid>
      <pubDate>Thu, 06 May 2021 08:24:18 GMT</pubDate>
      
      <description>本文从基本数据类型和引用数据类型的视角出发，浅谈了==与equals的区别</description>
      
      
      
      <content:encoded><![CDATA[<h2 id="1、数据类型"><a href="#1、数据类型" class="headerlink" title="1、数据类型"></a>1、数据类型</h2><p>谈论<code>==</code>与<code>equal</code>的区别之前，我们先来回顾一下Java中的基本数据类型和引用数据类型。</p><p>基本数据类型：Java中包括八种基本数据类型，分别为char，byte，short，int，long，float，double，boolean。</p><p>引用数据类型：引用类型包括三种，分别为类(class)，接口(interface)，数组(array)，其中我们经常听到的Object，String，Date，Integer这些都属于类这种引用类型。</p><h2 id="2、区别"><a href="#2、区别" class="headerlink" title="2、区别"></a>2、区别</h2><ul><li>如果是用于基本数据类型的比较，则只能用<code>==</code>，而不能用<code>equals</code>，因为比较的数据类型是基本数据类型，它们没有equals()方法的实现，因此他们的比较只能用<code>==</code>来实现，<code>==</code>比较的是他们的值是否相等。</li><li>如果是用于引用数据类型的比较，不同情况下也有不同的结果。我们这里针对于类这种引用数据类型来说，所有的类都继承一个公共的父类<code>Object</code>，而该父类里面定义的比较方法为<code>equals</code>。但是，<code>Object</code>类里面的<code>equals</code>方法默认比较的结果是内存地址，而不是值，因此该方法返回的结果与<code>==</code>的结果相同。<strong>因此，这里判断<code>==</code>与<code>equals</code>的区别就变成了判断<code>equals</code>的具体实现是否用<code>==</code>来实现。</strong><ul><li>拿<code>String</code>，<code>Integer</code>，<code>Date</code>这些类来说，这些类在继承了<code>Object</code>之后，重写了父类的<code>equals</code>方法，因此这些引用数据类型使用<code>==</code>比较时，比较的是对象的内存地址，而使用<code>equals</code>方法比较时，则比较的是对象的值。</li><li>对于<code>StringBuffer</code>或者一些自定义的类，这些类没有重写覆盖父类<code>Object</code>的<code>equals</code>方法，因此这些对象使用<code>==</code>与<code>equals</code>返回的结果是一样，因为<code>equals</code>的实现方式就是使用<code>==</code>来实现的。</li><li>还有一个关于<code>字符串缓冲池</code>的概念，程序会在运行的时候创建一个字符串缓冲池，来存放一些创建的字符串。如果你同时定义了两个相同的字符串，并且没有进行new操作，则在定义第二个字符串的时候，会将第二个字符串的内存地址指向第一个相同的字符串，而不会再创建一个新对象。此时<code>==</code>与<code>equals</code>操作返回结果相同；而当第二个字符串进行了new操作，创建第二个字符串时会新建一个字符串，此时<code>==</code>与<code>equals</code>返回的结果不相同。</li></ul></li></ul>]]></content:encoded>
      
      
      <category domain="http://zhuferron.github.io/categories/Java%E5%90%8E%E7%AB%AF/">Java后端</category>
      
      
      <category domain="http://zhuferron.github.io/tags/Java%E5%9F%BA%E7%A1%80/">Java基础</category>
      
      
      <comments>http://zhuferron.github.io/2021/05/06/Java%E4%B8%AD==%E4%B8%8Eequals%E7%9A%84%E5%8C%BA%E5%88%AB/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>接口与抽象类的区别(包括JDK8新特征)</title>
      <link>http://zhuferron.github.io/2021/05/06/%E6%8E%A5%E5%8F%A3%E4%B8%8E%E6%8A%BD%E8%B1%A1%E7%B1%BB%E7%9A%84%E5%8C%BA%E5%88%AB(%E5%8C%85%E6%8B%ACJDK8%E6%96%B0%E7%89%B9%E6%80%A7)/</link>
      <guid>http://zhuferron.github.io/2021/05/06/%E6%8E%A5%E5%8F%A3%E4%B8%8E%E6%8A%BD%E8%B1%A1%E7%B1%BB%E7%9A%84%E5%8C%BA%E5%88%AB(%E5%8C%85%E6%8B%ACJDK8%E6%96%B0%E7%89%B9%E6%80%A7)/</guid>
      <pubDate>Thu, 06 May 2021 07:11:03 GMT</pubDate>
      
      <description>本文深入地分析了接口和抽象类的区别，也包括了JDK8前后的对比。</description>
      
      
      
      <content:encoded><![CDATA[<h2 id="1、概念"><a href="#1、概念" class="headerlink" title="1、概念"></a>1、概念</h2><p>抽象类：Java的核心就是面向对象，在面向对象的程序设计中，万物皆对象，所有的对象都应该用类来描述，但是并不是所有的类都是用来描述对象的。因为很多时候大部分对象都不能直接被描述，当一个类难于有足够的信息来描述一个具体的对象时，我们通常把它定义为抽象类，用关键字<code>abstract</code>来修饰。因此，凡是用关键字<code>abstract</code>修饰的类都是抽象类，凡是用关键字<code>abstract</code>修饰的方法都是抽象方法，抽象类不一定要拥有抽象方法，抽象方法一定在抽象类里面。</p><p>接口：广义上来说，接口算是一个只包含抽象方法的抽象类，但是严格上并不能这样说，因为接口不是直接说是抽象类，抽象类是包含属性和方法，而接口则是包含了类要实现的方法。接口在Java中算是一种抽象类型，是许多抽象方法的集合。接口需要用关键字<code>interface</code>来修饰。</p><h2 id="2、区别"><a href="#2、区别" class="headerlink" title="2、区别"></a>2、区别</h2><ol><li>抽象类可以有构造方法和普通成员变量，接口没有构造方法和普通成员变量，只能有<code>static final</code>关键字修饰的静态常量</li><li>抽象类可以有非抽象的普通方法，而对于接口来说，JDK8之前，接口只能有一系列的抽象方法；<strong>而在JDK8之后，接口不仅仅可以包含抽象方法，还可以包含默认方法和静态方法。</strong></li><li>一个类可以实现多个接口，但只能继承一个抽象类</li><li>抽象类中方法可以被所有关键字修饰，但是抽象方法只可以被<code>public</code>，<code>protected</code>，<code>default</code>关键字来修饰，不能用<code>private</code>修饰。JDK8之前，抽象类的方法默认访问权限为<code>protected</code>，JDK8以后，抽象类的方法默认访问权限变为<code>default</code>。而对于接口来说，JDK8之前，所有的抽象方法访问权限必须是<code>public</code>，JDK8时，抽象方法访问权限可以为<code>public</code>和<code>default</code>，JDK9及之后，抽象方法访问权限也可以是<code>private</code>。</li></ol><h2 id="3、其他"><a href="#3、其他" class="headerlink" title="3、其他"></a>3、其他</h2><ul><li><p>接口和抽象类的区别，本质上就是类和一系列抽象方法的集合的区别，抽象类可以有构造方法，普通方法，也可以有普通成员变量，而接口只能有静态常量和抽象方法(默认方法和静态方法)。</p></li><li><p>实际开发中，接口更像是一种开发规范，由架构师设计好了接口之后，再由项目开发团队分别把这些接口逐一去实现；而抽象类更多的是在具体代码实现方面发挥作用。</p></li><li><p>JDK8之后接口之所以要添加默认方法的原因，是因为当接口的实现类要实现接口时，需要重写接口里面的全部方法，这使接口与实现类的耦合度过高。因此如果需要给接口添加一个新的方法时，所有的实现类都需要修改，而默认方法可以实现为接口添加新的方法，并且不改变原有对接口的实现。</p></li><li><p>抽象类中的抽象方法不能用<code>private</code>修饰，因为抽象类中的抽象方法就是为了被子类重写而存在的，所以不能用<code>private</code>修饰。</p></li></ul>]]></content:encoded>
      
      
      <category domain="http://zhuferron.github.io/categories/Java%E5%90%8E%E7%AB%AF/">Java后端</category>
      
      
      <category domain="http://zhuferron.github.io/tags/Java%E5%9F%BA%E7%A1%80/">Java基础</category>
      
      
      <comments>http://zhuferron.github.io/2021/05/06/%E6%8E%A5%E5%8F%A3%E4%B8%8E%E6%8A%BD%E8%B1%A1%E7%B1%BB%E7%9A%84%E5%8C%BA%E5%88%AB(%E5%8C%85%E6%8B%ACJDK8%E6%96%B0%E7%89%B9%E6%80%A7)/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>面向对象详解(对比面向过程)</title>
      <link>http://zhuferron.github.io/2021/04/21/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%AF%A6%E8%A7%A3(%E5%AF%B9%E6%AF%94%E9%9D%A2%E5%90%91%E8%BF%87%E7%A8%8B)/</link>
      <guid>http://zhuferron.github.io/2021/04/21/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%AF%A6%E8%A7%A3(%E5%AF%B9%E6%AF%94%E9%9D%A2%E5%90%91%E8%BF%87%E7%A8%8B)/</guid>
      <pubDate>Wed, 21 Apr 2021 08:26:06 GMT</pubDate>
      
      <description>本文由浅入深地讲解了面向对象概念</description>
      
      
      
      <content:encoded><![CDATA[<h2 id="1、理解"><a href="#1、理解" class="headerlink" title="1、理解"></a>1、理解</h2><p>​    首先不要把面向对象(OOP)看成一个很复杂很复杂的东西，我们先不说面向对象是什么，面向对象有什么优点，解决了什么问题，先想想面向对象为什么会出现。</p><p>​    最早期的计算机编程是很繁琐的，如果要描述鸟吃虫子这件事情，原始的计算机编程便是：鸟在飞—&gt;发现了虫子—&gt;鸟把虫子吃了，这更关注的就是鸟吃虫子的这整个<strong>过程</strong>，以及这个过程所产生的影响，这也就是所谓的**面向过程(POP)**。但是逐渐地这种计算机编程便显得十分繁琐，冗余，因为随着需求改变，每一个过程都会改变，这也让我们的程序变得难于维护、拓展和复用。这时候，面向对象的编程思想便出现了。</p><p>​    **面向对象(OOP)**它不是凭空产生的，它是因为面向过程思想逐渐适应不了现在计算机编程的发展而出现的。面向对象的思想就是把万事万物都变成一个个对象，每个对象都有自己的属性和行为。同样拿前面描述鸟吃虫子这件事来举例，面向对象的思想就是把这个事件中的个体变成所谓的对象，即鸟和虫子，鸟和虫子都拥有种类，高度，颜色等属性，描述了这个对象的特征，也都有飞翔(爬行)，捕食，睡觉这些行为。面向对象就把鸟吃虫子的这个过程变成了有一只鸟进行了捕食这个行为，捕食的对象是这只虫子。看似复杂化了鸟吃虫子这个过程，实际上降低了计算机编程中的耦合性，提高了复用性和可维护性。</p><p>​    用一句话来描述，面向过程就是一个问题的解决过程被一步步拆解开来，逐个完成。而面向对象则是将解决这个问题的一些行为提取出来，并且找到执行这些行为的对象，定义出对象和其行为，通过操作对象来解决这个问题。</p><h2 id="2、POP-VS-OOP"><a href="#2、POP-VS-OOP" class="headerlink" title="2、POP VS OOP"></a>2、POP VS OOP</h2><p>POP：</p><ul><li>优点：因为面向过程是针对一个过程，不需要实例化对象，因此其性能一般会比面向对象高，这种思想一般应用于一些专用度高，性能需求强的地方，比如单片机、嵌入式开发、操作系统开发等等。</li><li>缺点：相比面向对象来说难于维护，难于拓展和难于复用</li></ul><p>OOP：</p><ul><li>优点：易维护、易复用、易扩展，由于面向对象有封装、继承、多态性的特性，可以设计出低耦合的系统，使系统 更加灵活、更加易于维护</li><li>缺点：性能比面向过程低</li></ul><h2 id="3、三大特性"><a href="#3、三大特性" class="headerlink" title="3、三大特性"></a>3、三大特性</h2><h3 id="3-1、封装"><a href="#3-1、封装" class="headerlink" title="3.1、封装"></a>3.1、封装</h3><p>​    封装的本质就是把一个对象的属性和行为隐藏起来，其细节不需要向外界或者客户展示，只需要知道如何使用即可。</p><h3 id="3-2、继承"><a href="#3-2、继承" class="headerlink" title="3.2、继承"></a>3.2、继承</h3><p>​    继承实际上就是面向对象的细化，打个比方，我们定义了两个对象，一个是几何图形的对象，一个是正方形的对象，我们都知道正方形属于几何图形，因此这就产生了对象继承。继承就是一个类可以使用现有类的所有功能，并在无需重新编写原来的类的情况下对这些功能进行扩展。比如，几何图形的对象有周长，面积，颜色等属性，但是不同的几何图形有不同的周长和面积计算方式，因此在几何图片的类里面很难具体实现周长和面积的计算，而当正方形继承了几何图片的类时，则可以具体定义周长和面积的计算方式。</p><p>​    由此，便引出了重载方法和重写方法的概念，父类中如果已经有了某一个方法，而当在其子类中需要修改该方法的实现方式时，则需要进行重写，重写方法的前提是保证子类的方法的签名和返回值与父类的一致；重写方法一定是在子类中进行，而重载方法则不是，它可以在同一个类中也可以不在同一个类中，之所以需要重载方法，是因为往往对象的同一个行为(方法)往往会在不同的输入下出现不同的结果，比如同样是做饭这个行为，加入的食材不一样，得到的结果也就不一样。</p><h3 id="3-3、多态"><a href="#3-3、多态" class="headerlink" title="3.3、多态"></a>3.3、多态</h3><p>​    简单地说，多态就是允许将子类类型的指针赋值给父类类型的指针，把不同的子类对象都当作父类来看。更简单地说，就是父类的引用指向子类的对象。为什么要有多态呢？实际上就是为了实现计算机程序的简单性，同样要创建一个对象，输入的初始条件不同，就会生成不同的对象，但是代码实现时我们不可能使用判断语句来判断输入条件并且返回对应的对象。这时候就需要多态了，多态可以动态地根据输入的参数生成不一样的对象，他们都属于一个公共父类，但生成的却是不一样的子类。</p><p>​    多态的实现方法有重写和重载、接口、抽象类和抽象方法三种实现方法。</p>]]></content:encoded>
      
      
      <category domain="http://zhuferron.github.io/categories/Java%E5%90%8E%E7%AB%AF/">Java后端</category>
      
      
      <category domain="http://zhuferron.github.io/tags/Java%E5%9F%BA%E7%A1%80/">Java基础</category>
      
      
      <comments>http://zhuferron.github.io/2021/04/21/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%AF%A6%E8%A7%A3(%E5%AF%B9%E6%AF%94%E9%9D%A2%E5%90%91%E8%BF%87%E7%A8%8B)/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>Hyperledger Fabric实验环境搭建，修改chaincode，部署chaincode以及测试chaincode</title>
      <link>http://zhuferron.github.io/2021/04/14/%E5%8C%BA%E5%9D%97%E9%93%BE/</link>
      <guid>http://zhuferron.github.io/2021/04/14/%E5%8C%BA%E5%9D%97%E9%93%BE/</guid>
      <pubDate>Wed, 14 Apr 2021 07:40:15 GMT</pubDate>
      
      <description>本文由浅入深地讲解了Hyperledger Fabric的实验环境搭建，并且对两个简单的项目进行修改，并且部署chaincode和测试chaincode</description>
      
      
      
      <content:encoded><![CDATA[<h2 id="1、环境准备"><a href="#1、环境准备" class="headerlink" title="1、环境准备"></a>1、环境准备</h2><ul><li><p>安装公共依赖</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install -y apt-transport-https ca-certificates software-properties-common </span><br><span class="line">sudo apt-get install -y unzip git  curl wget vim tree jq</span><br></pre></td></tr></table></figure></li><li><p>安装gradle</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> /tmp &amp;&amp; wget https://services.gradle.org/distributions/gradle-6.4-bin.zip</span><br><span class="line">unzip gradle-6.4-bin.zip</span><br><span class="line">sudo mv gradsle-6.4 /usr/<span class="built_in">local</span>/gradle</span><br><span class="line"><span class="comment">#修改配置文件</span></span><br><span class="line">sudo cat &gt;&gt; ~/.bashrc &lt;&lt;<span class="string">EOF</span></span><br><span class="line"><span class="string">export PATH=$PATH:/usr/local/gradle/bin</span></span><br><span class="line"><span class="string">EOF</span></span><br><span class="line"><span class="comment">#使配置文件生效</span></span><br><span class="line"><span class="built_in">source</span> ~/.bashrc </span><br></pre></td></tr></table></figure></li><li><p>需要安装的七个docker镜像(版本不确定是否有影响)</p><p><img src="http://fl.ljuuu.com/img/20210414155307.png"></p></li><li><p>下载docker-compose</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">wget https://get.daocloud.io/docker/compose/releases/download/1.25.3/docker-compose-`uname -s`-`uname -m`</span><br><span class="line">sudo mv docker-compose-`uname -s`-`uname -m` /usr/<span class="built_in">local</span>/bin/docker-compose</span><br><span class="line">sudo chmod +x /usr/<span class="built_in">local</span>/bin/docker-compose</span><br><span class="line">docker-compose -v <span class="comment">#检查是否安装成功</span></span><br></pre></td></tr></table></figure></li><li><p>java环境</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">java -version</span><br><span class="line"><span class="comment">#如果没有java环境，用下列命令安装</span></span><br><span class="line">sudo apt-get install -y openjdk-8-jdk</span><br></pre></td></tr></table></figure></li><li><p>下载<code>workspace</code>工作目录(将下载的workspace放在用户的home目录下即可)</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://gitlab.com/qubing/blockchain_lab_v2.git ~/workspace</span><br></pre></td></tr></table></figure><p>确保workspace下有以下的文件和文件夹</p><p><img src="http://fl.ljuuu.com/img/20210414155743.png"></p></li><li><p>为了开发和单元测试方便，可以在服务器或虚拟机上安装<strong>IDEA</strong>进行chaincode的开发。</p></li><li><p>使用虚拟机进行实验可安装gui，使用云服务器进行实验可以在云服务器上安装gui然后通过vnc进行连接，安装gui过程参见<a href="https://blog.csdn.net/Linrena/article/details/106309969">https://blog.csdn.net/Linrena/article/details/106309969</a></p></li></ul><h2 id="2、example01项目"><a href="#2、example01项目" class="headerlink" title="2、example01项目"></a>2、example01项目</h2><ul><li><p>因为<code>workspace</code>目录下的<code>chaincode</code>目录下有一个<code>example01</code>项目，主要是让大家熟悉chaincode怎么编写。</p></li><li><p>使用IDEA打开<code>example01</code>下的<code>java</code>项目，该项目是一个<code>gradle</code>项目，等待项目建立完成之后，打开<code>MyContract.java</code>文件，查看初始的智能合约代码。</p></li><li><p>在<code>workspace</code>文件夹下使用下列命令来体验如何部署一个区块链网络</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#检测区块链网络的环境，初始化区块链网络，并且建立每个区块链网络的结点</span></span><br><span class="line">. ./init.sh </span><br><span class="line"><span class="comment">#检测结点是否正常运行(当执行startup脚本时出现docker镜像问题时，是因为startup脚本本身的问题)</span></span><br><span class="line">. ./startup.sh</span><br><span class="line"><span class="comment">#部署example01的chaincode</span></span><br><span class="line">. scripts/deploy_chaincode.sh java <span class="variable">$&#123;PWD&#125;</span>/chaincode/chaincode_example01/java mycc_java</span><br><span class="line"><span class="comment">#测试example01的chaincode</span></span><br><span class="line">. scripts/test_example01.sh mycc_java</span><br><span class="line"><span class="comment">#清空区块链网络环境</span></span><br><span class="line">. ./teardown.sh</span><br></pre></td></tr></table></figure></li><li><p>解决<code>startup.sh</code>脚本执行错误：更改<code>startup.sh</code>中的<code>DB_IMAGE_TAG</code>，将原来的<code>DB_IMAGE_TA</code>替换成<code>DB_VERSION</code></p><p><img src="http://fl.ljuuu.com/img/20210413173035.png"></p></li></ul><h2 id="3、修改example01项目"><a href="#3、修改example01项目" class="headerlink" title="3、修改example01项目"></a>3、修改example01项目</h2><ul><li><p>为了更好的熟悉这个项目，我们来新增一个<code>GetValue</code>和<code>SetValue</code>方法，并将其部署区块链网络上</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">*SetValue</span></span><br><span class="line"><span class="comment">*<span class="doctag">@param</span> ctx context</span></span><br><span class="line"><span class="comment">*<span class="doctag">@param</span> key key</span></span><br><span class="line"><span class="comment">*<span class="doctag">@param</span> value value</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">@Transaction(name = &quot;SetValue&quot;,intent = Transaction.TYPE.SUBMIT)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">SetValue</span><span class="params">(<span class="keyword">final</span> Context ctx, <span class="keyword">final</span> String key, <span class="keyword">final</span> String value)</span></span>&#123;</span><br><span class="line">    ChaincodeStub stub = ctx.getStub();</span><br><span class="line">    stub.putStringState(key,value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">*GetValue</span></span><br><span class="line"><span class="comment">*<span class="doctag">@param</span> ctx context</span></span><br><span class="line"><span class="comment">*<span class="doctag">@param</span> key key</span></span><br><span class="line"><span class="comment">*<span class="doctag">@return</span> value state in ledger</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">@Transaction(name = &quot;GetValue&quot;,intent = Transaction.TYPE.EVALUATE)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">GetValue</span><span class="params">(<span class="keyword">final</span> Context ctx, <span class="keyword">final</span> String key)</span></span>&#123;</span><br><span class="line">    ChaincodeStub stub = ctx.getStub();</span><br><span class="line">    <span class="keyword">return</span> stub.getStringState(key);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>进行单元测试(需要进行实际的测试，看单元测试是否通过)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Nested</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">InvokeSetValueTransaction</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">SetValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        MyContract contract = <span class="keyword">new</span> MyContract();</span><br><span class="line">        Context ctx = mock(Context.class);</span><br><span class="line">        ChaincodeStub stub = mock(ChaincodeStub.class);</span><br><span class="line">        String key = <span class="string">&quot;truth&quot;</span>;</span><br><span class="line">        String value = <span class="string">&quot;ferron is a good boy&quot;</span>;</span><br><span class="line"></span><br><span class="line">        when(ctx.getStub()).thenReturn(stub);</span><br><span class="line"></span><br><span class="line">        contract.SetValue(ctx,key,value);</span><br><span class="line">        InOrder inOrder = inOrder(stub);</span><br><span class="line">        inOrder.verify(stub).putStringState(key, value);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Nested</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">InvokeGetValueTransaction</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">GetValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        MyContract contract = <span class="keyword">new</span> MyContract();</span><br><span class="line">        Context ctx = mock(Context.class);</span><br><span class="line">        ChaincodeStub stub = mock(ChaincodeStub.class);</span><br><span class="line">        String key = <span class="string">&quot;truth&quot;</span>;</span><br><span class="line">        when(ctx.getStub()).thenReturn(stub);</span><br><span class="line"></span><br><span class="line">        when(stub.getStringState(key)).thenReturn(<span class="string">&quot;ferron is a good boy&quot;</span>);</span><br><span class="line">        assertThat(contract.GetValue(ctx,key).equals(<span class="string">&quot;ferron is a good boy&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>重新部署<code>example01</code>目录下的<code>java</code>项目(<strong>不需要进行测试chaincode</strong>)，具体部署方式参见第二部分，部署之前一定要确保已经执行过<code>teardown.sh</code>脚本</p><p><img src="http://fl.ljuuu.com/img/20210413190158.png"></p></li><li><p>在<code>scripts</code>目录下新建一个的<code>new_test_example01.sh</code>脚本，并且原来的<code>test_example01.sh</code>脚本复制到新建的脚本内，并且修改脚本，新增<code>Getvalue</code>和<code>SetValue</code>方法的脚本</p><p><img src="http://fl.ljuuu.com/img/20210413195927.png"></p></li><li><p>测试部署的<code>chaincode</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">. scripts/new_test_example01.sh mycc_java</span><br></pre></td></tr></table></figure><p><img src="http://fl.ljuuu.com/img/20210413194032.png"></p></li></ul><h2 id="4、example02项目"><a href="#4、example02项目" class="headerlink" title="4、example02项目"></a>4、example02项目</h2><ul><li><p>example02项目是一个钱包的chaincode，初始java代码中包含<code>Init</code>，<code>Query</code>和<code>Transfer</code>三种方法，功能分别是初始化钱包账户和余额，查询钱包余额，两个钱包之间进行转账。</p></li><li><p>现在我们新增一个<code>Recharge</code>方法，用于给一个账户充值。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Transaction(name = &quot;Recharge&quot;, intent = Transaction.TYPE.SUBMIT)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">recharge</span><span class="params">(<span class="keyword">final</span> Context ctx, <span class="keyword">final</span> String keyAccount, <span class="keyword">final</span> String valueTrans)</span></span>&#123;</span><br><span class="line">    ChaincodeStub stub = ctx.getStub();</span><br><span class="line">    <span class="comment">//get value of account</span></span><br><span class="line">    String value = stub.getStringState(keyAccount);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// account not existing</span></span><br><span class="line">    <span class="keyword">if</span> (value.isEmpty()) &#123;</span><br><span class="line">        String errorMessage = String.format(Message.ACCOUNT_NOT_EXISTING.template(), keyAccount);</span><br><span class="line">        System.out.println(errorMessage);</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ChaincodeException(errorMessage);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//type conversion</span></span><br><span class="line">    <span class="keyword">int</span> intValue = Integer.parseInt(value);</span><br><span class="line">    <span class="keyword">int</span> intValueTrans = Integer.parseInt(valueTrans);</span><br><span class="line">    intValue+=intValueTrans;</span><br><span class="line">    stub.putStringState(keyAccount,String.valueOf(intValue));</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>进行单元测试</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Nested</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">InvokeRechargeTransaction</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">whenAccountExists</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        MyContract contract = <span class="keyword">new</span> MyContract();</span><br><span class="line">        Context ctx = mock(Context.class);</span><br><span class="line">        ChaincodeStub stub = mock(ChaincodeStub.class);</span><br><span class="line">        String keyAccount = <span class="string">&quot;A&quot;</span>;</span><br><span class="line">        String valueRech = <span class="string">&quot;100&quot;</span>;</span><br><span class="line"></span><br><span class="line">        when(ctx.getStub()).thenReturn(stub);</span><br><span class="line">        when(stub.getStringState(<span class="string">&quot;A&quot;</span>)).thenReturn(<span class="string">&quot;100&quot;</span>);</span><br><span class="line"></span><br><span class="line">        Throwable thrown = catchThrowable(() -&gt;&#123;</span><br><span class="line">            contract.recharge(ctx,keyAccount,valueRech);</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        assertThat(thrown).isNull();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">whenAccountNotExists</span><span class="params">()</span></span>&#123;</span><br><span class="line">        MyContract contract = <span class="keyword">new</span> MyContract();</span><br><span class="line">        Context ctx = mock(Context.class);</span><br><span class="line">        ChaincodeStub stub = mock(ChaincodeStub.class);</span><br><span class="line">        String keyAccount = <span class="string">&quot;A&quot;</span>;</span><br><span class="line">        String valueRech = <span class="string">&quot;100&quot;</span>;</span><br><span class="line"></span><br><span class="line">        when(ctx.getStub()).thenReturn(stub);</span><br><span class="line">        when(stub.getStringState(<span class="string">&quot;A&quot;</span>)).thenReturn(<span class="string">&quot;&quot;</span>);</span><br><span class="line"></span><br><span class="line">        Throwable thrown = catchThrowable(() -&gt;&#123;</span><br><span class="line">            contract.recharge(ctx,keyAccount,valueRech);</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        assertThat(thrown)</span><br><span class="line">            .isInstanceOf(ChaincodeException.class)</span><br><span class="line">            .hasNoCause()</span><br><span class="line">            .hasMessage(String.format(MyContract.Message.ACCOUNT_NOT_EXISTING.template(),<span class="string">&quot;A&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>部署<code>chaincode</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">. scripts/deploy_chaincode.sh java $&#123;PWD&#125;/chaincode/chaincode_example02/java mycc_java02</span><br></pre></td></tr></table></figure></li><li><p>将原来的<code>test_example02.sh</code>复制一份并且进行以下修改</p><p><img src="http://fl.ljuuu.com/img/20210413195743.png"></p></li><li><p>测试<code>chaincode</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">. scripts/new_test_example02.sh mycc_java02</span><br></pre></td></tr></table></figure><p><img src="http://fl.ljuuu.com/img/20210413195533.png"></p></li></ul>]]></content:encoded>
      
      
      <category domain="http://zhuferron.github.io/categories/%E5%8C%BA%E5%9D%97%E9%93%BE/">区块链</category>
      
      
      <category domain="http://zhuferron.github.io/tags/%E5%8C%BA%E5%9D%97%E9%93%BE/">区块链</category>
      
      
      <comments>http://zhuferron.github.io/2021/04/14/%E5%8C%BA%E5%9D%97%E9%93%BE/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>多人协同开发、版本管理---git分支使用(码云为例)</title>
      <link>http://zhuferron.github.io/2021/04/06/%E5%A4%9A%E4%BA%BA%E5%8D%8F%E5%90%8C%E5%BC%80%E5%8F%91%E3%80%81%E7%89%88%E6%9C%AC%E7%AE%A1%E7%90%86----git%E5%88%86%E6%94%AF%E4%BD%BF%E7%94%A8(%E7%A0%81%E4%BA%91%E4%B8%BA%E4%BE%8B)/</link>
      <guid>http://zhuferron.github.io/2021/04/06/%E5%A4%9A%E4%BA%BA%E5%8D%8F%E5%90%8C%E5%BC%80%E5%8F%91%E3%80%81%E7%89%88%E6%9C%AC%E7%AE%A1%E7%90%86----git%E5%88%86%E6%94%AF%E4%BD%BF%E7%94%A8(%E7%A0%81%E4%BA%91%E4%B8%BA%E4%BE%8B)/</guid>
      <pubDate>Tue, 06 Apr 2021 13:31:47 GMT</pubDate>
      
      <description>未完成</description>
      
      
      
      <content:encoded><![CDATA[<h2 id="1、Git安装与配置"><a href="#1、Git安装与配置" class="headerlink" title="1、Git安装与配置"></a>1、Git安装与配置</h2><ul><li><p>进入git官网<code>https://www.git-scm.com/download</code>下载git，安装，安装过程省略，注意要安装gui和bash。其他的配置参考<a href="https://blog.csdn.net/qq_31884737/article/details/108632492%E3%80%82">https://blog.csdn.net/qq_31884737/article/details/108632492。</a></p><p><img src="http://fl.ljuuu.com/img/20210406213801.png"></p></li><li><p>git安装好之后，打开git的安装目录，发现有<code>git-bash.exe</code>和<code>git-cmd.exe</code>两个程序，我们一般都使用bash，通过linux命令来操作。</p></li><li><p>刚安装好git，先用以下命令设置全局有效的用户名和邮箱(下面以我的用户名和邮箱为例)</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git config --global user.name <span class="string">&quot;ferron&quot;</span></span><br><span class="line">git config --gloabl user.email <span class="string">&quot;2963624004@qq.com&quot;</span></span><br></pre></td></tr></table></figure></li><li></li></ul><h2 id="2、连接码云"><a href="#2、连接码云" class="headerlink" title="2、连接码云"></a>2、连接码云</h2><ul><li></li></ul><h2 id="2、项目创建"><a href="#2、项目创建" class="headerlink" title="2、项目创建"></a>2、项目创建</h2>]]></content:encoded>
      
      
      <category domain="http://zhuferron.github.io/categories/Java%E5%90%8E%E7%AB%AF/">Java后端</category>
      
      
      <category domain="http://zhuferron.github.io/tags/%E4%B8%AD%E9%97%B4%E4%BB%B6/">中间件</category>
      
      
      <comments>http://zhuferron.github.io/2021/04/06/%E5%A4%9A%E4%BA%BA%E5%8D%8F%E5%90%8C%E5%BC%80%E5%8F%91%E3%80%81%E7%89%88%E6%9C%AC%E7%AE%A1%E7%90%86----git%E5%88%86%E6%94%AF%E4%BD%BF%E7%94%A8(%E7%A0%81%E4%BA%91%E4%B8%BA%E4%BE%8B)/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>AWS ec2服务器创建多用户登录(使用密码登录)</title>
      <link>http://zhuferron.github.io/2021/04/05/AWS%20ec2%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%88%9B%E5%BB%BA%E5%A4%9A%E7%94%A8%E6%88%B7%E7%99%BB%E5%BD%95(%E4%BD%BF%E7%94%A8%E5%AF%86%E7%A0%81%E7%99%BB%E5%BD%95)/</link>
      <guid>http://zhuferron.github.io/2021/04/05/AWS%20ec2%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%88%9B%E5%BB%BA%E5%A4%9A%E7%94%A8%E6%88%B7%E7%99%BB%E5%BD%95(%E4%BD%BF%E7%94%A8%E5%AF%86%E7%A0%81%E7%99%BB%E5%BD%95)/</guid>
      <pubDate>Mon, 05 Apr 2021 04:31:01 GMT</pubDate>
      
      <description>介绍AWS的ec2云服务器如何使用密码进行多用户登录</description>
      
      
      
      <content:encoded><![CDATA[<h2 id="1、使用ubuntu登录"><a href="#1、使用ubuntu登录" class="headerlink" title="1、使用ubuntu登录"></a>1、使用ubuntu登录</h2><ul><li><p>好像ec2服务器不支持使用root直接登录，但是却支持使用root用户组的用户名登录，不同服务器的登录名不同，具体对应名称参考<a href="https://blog.csdn.net/Linrena/article/details/106171588%E3%80%82%E6%9C%AC%E7%AF%87%E5%8D%9A%E5%AE%A2%E4%BD%BF%E7%94%A8%E7%9A%84%E6%98%AFUbuntu%EF%BC%8C%E7%94%A8%E6%88%B7%E5%90%8D%E4%B8%BAubuntu">https://blog.csdn.net/Linrena/article/details/106171588。本篇博客使用的是Ubuntu，用户名为ubuntu</a></p></li><li><p>使用xshell创建新连接</p><p><img src="http://fl.ljuuu.com/img/20210405124402.png"></p></li><li><p>输入用户名</p><p><img src="http://fl.ljuuu.com/img/20210405124809.png"></p></li><li><p>使用密钥文件登录</p><p><img src="http://fl.ljuuu.com/img/20210405124844.png"></p></li><li><p>登录成功</p><p><img src="http://fl.ljuuu.com/img/20210405124648.png"></p></li></ul><h2 id="2、创建新用户"><a href="#2、创建新用户" class="headerlink" title="2、创建新用户"></a>2、创建新用户</h2><ul><li><p>登录之后，当前用户为<code>ubuntu</code>，使用命令<code>sudo su </code>切换为<code>root</code>用户</p></li><li><p>使用<code>adduser user</code>命令创建一个名字为<code>user</code>新用户</p><p><img src="http://fl.ljuuu.com/img/20210405125309.png"></p><p>极少数情况创建用户时不会让你输入密码，这时候需要使用命令<code>passwd user</code>为该用户创建密码</p></li></ul><h2 id="3、修改配置文件"><a href="#3、修改配置文件" class="headerlink" title="3、修改配置文件"></a>3、修改配置文件</h2><p>因为ec2服务器默认是不允许使用密码登录的，因此需要修改ssh的配置文件让其允许使用密码登录</p><ul><li><p>使用<code>root</code>账户修改<code>sshd_config</code>文件，使用命令<code>vim /etc/ssh/sshd_config</code>。</p></li><li><p>切换成编辑模式将第56行的注释去掉，打开允许密码登录功能。</p><p><img src="http://fl.ljuuu.com/img/20210405125701.png"></p></li><li><p>切换成命令模式，输入<code>wq</code>保存退出。</p></li><li><p>使用命令<code>sudo service ssh restart</code>，重启ssh服务令配置文件生效。</p></li><li><p>重新用新创建的用户登录</p></li></ul><h2 id="4、新用户登录"><a href="#4、新用户登录" class="headerlink" title="4、新用户登录"></a>4、新用户登录</h2><ul><li><img src="http://fl.ljuuu.com/img/20210405130316.png"></li><li><img src="http://fl.ljuuu.com/img/20210405130337.png"></li><li><img src="http://fl.ljuuu.com/img/20210405130422.png"></li></ul><p>登录成功！</p><h2 id="5、允许root用户登录"><a href="#5、允许root用户登录" class="headerlink" title="5、允许root用户登录"></a>5、允许root用户登录</h2><ul><li><p>重新使用用户<code>ubuntu</code>登录，<strong>切换成root用户进行以下操作</strong></p></li><li><p>新的ec2服务器的root账户默认是没有密码的，需要使用命令<code>sudo passwd root</code>给<code>root</code>用户设置密码</p><p><img src="http://fl.ljuuu.com/img/20210405130634.png"></p></li><li><p>使用命令<code>vim /etc/ssh/sshd_config</code>修改<code>sshd_config</code>文件的第32行的<code>PermitRootLogin</code>，并保存退出。</p><p><img src="http://fl.ljuuu.com/img/20210405131026.png"></p></li><li><p>使用命令<code>sudo service ssh restart</code>，重启ssh服务令配置文件生效。</p></li><li><p>重新登录</p><p><img src="http://fl.ljuuu.com/img/20210405131321.png"></p></li></ul><p><img src="http://fl.ljuuu.com/img/20210405131213.png"></p><p><img src="http://fl.ljuuu.com/img/20210405131239.png"></p><p>登录成功，完结撒花！</p>]]></content:encoded>
      
      
      <category domain="http://zhuferron.github.io/categories/%E4%BA%91%E8%AE%A1%E7%AE%97/">云计算</category>
      
      
      <category domain="http://zhuferron.github.io/tags/%E4%BA%91%E8%AE%A1%E7%AE%97/">云计算</category>
      
      
      <comments>http://zhuferron.github.io/2021/04/05/AWS%20ec2%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%88%9B%E5%BB%BA%E5%A4%9A%E7%94%A8%E6%88%B7%E7%99%BB%E5%BD%95(%E4%BD%BF%E7%94%A8%E5%AF%86%E7%A0%81%E7%99%BB%E5%BD%95)/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>创建以太坊钱包</title>
      <link>http://zhuferron.github.io/2021/03/31/%E7%94%9F%E6%88%90%E4%BB%A5%E5%A4%AA%E5%9D%8A%E9%92%B1%E5%8C%85/</link>
      <guid>http://zhuferron.github.io/2021/03/31/%E7%94%9F%E6%88%90%E4%BB%A5%E5%A4%AA%E5%9D%8A%E9%92%B1%E5%8C%85/</guid>
      <pubDate>Wed, 31 Mar 2021 14:27:11 GMT</pubDate>
      
      <description>傻瓜式地介绍了如何创建一个以太坊钱包</description>
      
      
      
      <content:encoded><![CDATA[<h2 id="1、进入官网"><a href="#1、进入官网" class="headerlink" title="1、进入官网"></a>1、进入官网</h2><p>进入MyEtherWaller官网：<a href="https://www.myetherwallet.com/">https://www.myetherwallet.com/</a></p><p><img src="http://fl.ljuuu.com/img/20210331214557.png"></p><p>一路next</p><p><img src="http://fl.ljuuu.com/img/20210331214638.png"></p><p>一定要好好保存好你的密钥和密码，丢了就啥也没了~</p><p><img src="http://fl.ljuuu.com/img/20210331214816.png"></p><h2 id="2、新建钱包"><a href="#2、新建钱包" class="headerlink" title="2、新建钱包"></a>2、新建钱包</h2><p>官方更推荐使用第一种方法(NEW wallet钱包)来创建新钱包，我们使用第二种方式，即密钥库文件创建一个新的ETH钱包，输入密码，<strong>一定一定要记住密码</strong>！</p><p><img src="http://fl.ljuuu.com/img/20210331215120.png"></p><p>等待你的密钥库文件生成，下载密钥库文件，<strong>保存好！</strong></p><p><img src="http://fl.ljuuu.com/img/20210331215521.png"></p><p><strong>下载保存好！</strong></p><p><img src="http://fl.ljuuu.com/img/20210331215815.png"></p><p>开始使用。</p><p><img src="http://fl.ljuuu.com/img/20210331215900.png"></p><p><strong>打开你的密钥库文件，mac后面跟着的就是你钱包的私钥！</strong></p><p><img src="http://fl.ljuuu.com/img/20210331221723.png"></p><h2 id="3、登录钱包"><a href="#3、登录钱包" class="headerlink" title="3、登录钱包"></a>3、登录钱包</h2><p>虽然官方不推荐，但是我们还是使用密钥库文件来登录，<strong>毕竟你的账户也没多少钱，被盗走或者丢失影响也不大！</strong>，</p><p><img src="http://fl.ljuuu.com/img/20210331220048.png"></p><p>可以选择<strong>密钥库文件</strong>或者<strong>私钥</strong>进行登录，这里使用密钥库文件进行登录，第二种方式是助记词方法登录，对应创建ETH钱包时的第三种创建方法！</p><p><img src="http://fl.ljuuu.com/img/20210331220227.png"></p><p>选择你刚刚保存的密钥库文件</p><p><img src="http://fl.ljuuu.com/img/20210331220314.png"></p><p>输入密码</p><p><img src="http://fl.ljuuu.com/img/20210331220345.png"></p><p>钱包页面！</p><p><img src="http://fl.ljuuu.com/img/20210331221320.png"></p><p>这样你就拥有了一个属于你的ETH钱包了！</p>]]></content:encoded>
      
      
      <category domain="http://zhuferron.github.io/categories/%E5%8C%BA%E5%9D%97%E9%93%BE/">区块链</category>
      
      
      <category domain="http://zhuferron.github.io/tags/%E5%8C%BA%E5%9D%97%E9%93%BE/">区块链</category>
      
      
      <comments>http://zhuferron.github.io/2021/03/31/%E7%94%9F%E6%88%90%E4%BB%A5%E5%A4%AA%E5%9D%8A%E9%92%B1%E5%8C%85/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>剑指offer刷题笔记</title>
      <link>http://zhuferron.github.io/2021/03/28/%E5%89%91%E6%8C%87offer%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0/</link>
      <guid>http://zhuferron.github.io/2021/03/28/%E5%89%91%E6%8C%87offer%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0/</guid>
      <pubDate>Sun, 28 Mar 2021 13:45:29 GMT</pubDate>
      
      <description>这是笔者在力扣上刷剑指offer的题目的刷题笔记，持续更新!!!</description>
      
      
      
      <content:encoded><![CDATA[<p>标题：力扣(LeetCode)剑指offer第4题(Java实现)：二维数组中的查找</p><h2 id="3、数组中重复的数字"><a href="#3、数组中重复的数字" class="headerlink" title="3、数组中重复的数字"></a>3、数组中重复的数字</h2><p><strong>题目描述</strong></p><p>找出数组中重复的数字。</p><p>在一个长度为 n 的数组 nums 里的所有数字都在 0～n-1 的范围内。数组中某些数字是重复的，但不知道有几个数字重复了，也不知道每个数字重复了几次。请找出数组中任意一个重复的数字。</p><p><strong>示例</strong></p><p>输入：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[2, 3, 1, 0, 2, 5, 3]</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2或3</span><br></pre></td></tr></table></figure><p><strong>思路分析</strong></p><p>思路一：题目说要寻找一个重复的元素，因此可以考虑使用<code>HashSet</code>来解决该问题。集合中不能存在重复的元素，将数组中每个元素都添加到<code>Set</code>中，如果添加失败，则代表该元素是重复元素。使用这种方法相当于以空间换时间，<strong>时间复杂度会最小</strong>。</p><p>思路二：原地交换法，题目隐藏了条件就是<code>所有数字都在 0～n-1 的范围内</code>，因此我们可以考虑使用原地交换的方法。遍历数组，如果数组索引等于对应的元素，则跳过，否则；则进行交换，即把数值为n的元素放在数组的第n个索引，当发现第n个索引已经有相同的元素时，则返回重复的元素。</p><p><strong>代码</strong></p><p>思路一：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findRepeatNumber</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        Set&lt;Integer&gt; set = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        <span class="keyword">int</span> result = -<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> num:nums)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!set.add(num))&#123;</span><br><span class="line">                result=num;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>思路二：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findRepeatNumber</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;nums.length; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i == nums[i])&#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">if</span>(nums[i] == nums[nums[i]]) <span class="keyword">return</span> nums[i];</span><br><span class="line">                <span class="keyword">int</span> temp = nums[i];</span><br><span class="line">                nums[i]=nums[nums[i]];</span><br><span class="line">                nums[temp]=temp;      </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4、二维数组中的查找"><a href="#4、二维数组中的查找" class="headerlink" title="4、二维数组中的查找"></a>4、二维数组中的查找</h2><p><strong>题目描述</strong></p><p>在一个二维数组中（每个一维数组的长度相同），每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。</p><p><strong>示例</strong></p><p>输入：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[[1,2,8,9],[2,4,9,12],[4,7,10,13],[6,8,11,15]],7</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">true</span><br></pre></td></tr></table></figure><p><strong>思路分析</strong></p><p>因为这个一个排好序的二维数组，查找时考虑使用二分查找。然而由题目可知，这个二维数组的排序有一定规律，按照二分查找的思路就是选定一个mid点，然而进行查找。因此考虑选择二维数组右上方的元素作为mid，如果target等于mid，则找到；如果target大于mid，就说明target不在第一行，此时接着判断第二行和最后一列，循环即可；如歌targte小于mid，就说明target不在最后一列，此时接着判断第一行和倒数第二列，循环即可。</p><p><strong>代码</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">findNumberIn2DArray</span><span class="params">(<span class="keyword">int</span>[][] matrix, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(matrix.length == <span class="number">0</span> || matrix[<span class="number">0</span>].length == <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> j = matrix[<span class="number">0</span>].length-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">boolean</span> flag = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">while</span>(i&lt;=matrix.length-<span class="number">1</span> &amp;&amp; j&gt;=<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(target == matrix[i][j])&#123;</span><br><span class="line">                flag=<span class="keyword">true</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(target &gt; matrix[i][j])&#123;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                j--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> flag;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="5、替换空格"><a href="#5、替换空格" class="headerlink" title="5、替换空格"></a>5、替换空格</h2><p><strong>题目描述</strong></p><p>请实现一个函数，将一个字符串中的每个空格替换成“%20”。</p><p><strong>示例</strong></p><p>输入：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&quot;We Are Happy&quot;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&quot;We%20Are%20Happy&quot;</span><br></pre></td></tr></table></figure><p><strong>思路分析</strong></p><p>题目需要替换字符串，因此考虑使用StringBuffer类来实现。新建一个StringBuffer，遍历原字符串，如果字符为空格，则在sb中添加一个%20，如果字符不为空格，则添加该字符。</p><p><strong>代码</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">replaceSpace</span> <span class="params">(String s)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// write code here</span></span><br><span class="line"></span><br><span class="line">    StringBuffer sb = <span class="keyword">new</span> StringBuffer();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;s.length(); i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(s.charAt(i)==<span class="string">&#x27; &#x27;</span>)&#123;</span><br><span class="line">            sb.append(<span class="string">&quot;%20&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            sb.append(s.charAt(i));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sb.toString();     </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="6、从尾到头打印链表"><a href="#6、从尾到头打印链表" class="headerlink" title="6、从尾到头打印链表"></a>6、从尾到头打印链表</h2><p><strong>题目描述</strong></p><p>输入一个链表，按链表从尾到头的顺序返回一个ArrayList。</p><p><strong>示例</strong></p><p>输入：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;67,0,24,58&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[58,24,0,67]</span><br></pre></td></tr></table></figure><p><strong>思路分析</strong></p><p>题目说需要从尾到头打印这个链表，因此考虑使用栈来解决。</p><p><strong>代码</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] reversePrint(ListNode head) &#123;</span><br><span class="line">        Stack&lt;ListNode&gt; stack = <span class="keyword">new</span> Stack&lt;ListNode&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(ListNode node=head; node!=<span class="keyword">null</span>; node=node.next)&#123;</span><br><span class="line">            stack.push(node);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> size = stack.size();</span><br><span class="line">        <span class="keyword">int</span>[] result = <span class="keyword">new</span> <span class="keyword">int</span>[size];</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;size; i++)&#123;</span><br><span class="line">            result[i]=stack.pop().val;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="7、重建二叉树"><a href="#7、重建二叉树" class="headerlink" title="7、重建二叉树"></a>7、重建二叉树</h2><p><strong>题目描述</strong></p><p>输入某二叉树的前序遍历和中序遍历的结果，请重建出该二叉树。假设输入的前序遍历和中序遍历的结果中都不含重复的数字。例如输入前序遍历序列{1,2,4,7,3,5,6,8}和中序遍历序列{4,7,2,1,5,3,8,6}，则重建二叉树并返回。</p><p><strong>示例</strong></p><p>输入：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[1,2,3,4,5,6,7],[3,2,4,1,6,5,7]</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;1,2,5,3,4,6,7&#125;</span><br></pre></td></tr></table></figure><p><strong>思路分析</strong></p><p>知道二叉树的前序遍历和中序遍历，可以考虑使用递归来解决。首先通过前序遍历得到该二叉树的root结点，示例中root结点为1。知道root结点后，通过中序遍历知道了root的左子树的前序遍历为<code>[2,3,4]</code>，中序遍历为<code>[3,2,4]</code>，右子树前序遍历为<code>[5,6,7]</code>，<code>[6,5,7]</code>，接着分别对root的左子树和右子树进行同样的递归操作即可。</p><p><strong>代码</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">buildTree</span><span class="params">(<span class="keyword">int</span>[] preorder, <span class="keyword">int</span>[] inorder)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(preorder.length==<span class="number">0</span> | inorder.length==<span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">            TreeNode root = <span class="keyword">new</span> TreeNode(preorder[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;inorder.length; i++)&#123;</span><br><span class="line">            <span class="comment">//从前序遍历中找到中序遍历中的二叉树的根结点</span></span><br><span class="line">            <span class="keyword">if</span>(inorder[i] == preorder[<span class="number">0</span>])&#123;</span><br><span class="line">                root.left=buildTree(Arrays.copyOfRange(preorder,<span class="number">1</span>,i+<span class="number">1</span>),Arrays.copyOfRange(inorder,<span class="number">0</span>,i));</span><br><span class="line">                root.right=buildTree(Arrays.copyOfRange(preorder,i+<span class="number">1</span>,preorder.length),Arrays.copyOfRange(inorder,i+<span class="number">1</span>,inorder.length));</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="9、两个栈来实现一个队列"><a href="#9、两个栈来实现一个队列" class="headerlink" title="9、两个栈来实现一个队列"></a>9、两个栈来实现一个队列</h2><p><strong>题目描述</strong></p><p>用两个栈来实现一个队列，完成队列的Push和Pop操作。 队列中的元素为int类型。</p><p><strong>思路分析</strong></p><p>考虑使用两个栈来实现一个队列，首先考虑的是该队列只进不出，这样就可以直接使用stack1来存储该“队列”的所有元素。一旦考虑到出列的情况，就相当于要把stack1的所有元素先倒置，即把stack1的元素全部装进stack2，这样stack2中的元素就是stack1中所有元素的倒置，这样出列操作就可以通过stack2的pop方法来完成。考虑到这里还不够完整，如果该“队列”需要在出列之后再进列，则应该继续完善进列方法，即把stack2中的元素再push到stack1中，此时为进列模式下的“队列”，此时只需把需要进列的元素push进stack1即可。</p><p><strong>代码</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CQueue</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    Stack&lt;Integer&gt; stack1;</span><br><span class="line">    Stack&lt;Integer&gt; stack2;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CQueue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        stack1 = <span class="keyword">new</span> Stack&lt;Integer&gt;();</span><br><span class="line">        stack2 = <span class="keyword">new</span> Stack&lt;Integer&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">appendTail</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">        stack1.push(value);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">deleteHead</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(stack2.isEmpty())&#123;</span><br><span class="line">            <span class="keyword">while</span>(!stack1.isEmpty())&#123;</span><br><span class="line">                stack2.push(stack1.pop());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(stack2.isEmpty())&#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> stack2.pop();</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="10-1、斐波那契数列"><a href="#10-1、斐波那契数列" class="headerlink" title="10-1、斐波那契数列"></a>10-1、斐波那契数列</h2><p><strong>题目描述</strong></p><p>写一个函数，输入 n ，求斐波那契（Fibonacci）数列的第 n 项（即 F(N)）。斐波那契数列的定义如下：</p><p>F(0) = 0,   F(1) = 1<br>F(N) = F(N - 1) + F(N - 2), 其中 N &gt; 1.</p><p>斐波那契数列由 0 和 1 开始，之后的斐波那契数就是由之前的两数相加而得出。</p><p>答案需要取模 1e9+7（1000000007），如计算初始结果为：1000000008，请返回 1。</p><p><strong>示例</strong></p><p>输入：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">4</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">3</span><br></pre></td></tr></table></figure><p><strong>思路分析</strong></p><p>因为每次计算只需要两个数，使用动态规划。</p><p><strong>代码</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">fib</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n&lt;=<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> n;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> a=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> b=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> sum;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;n; i++)&#123;</span><br><span class="line">            sum=(a+b)%<span class="number">1000000007</span>;</span><br><span class="line">            a=b;</span><br><span class="line">            b=sum;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="10-2、跳台阶"><a href="#10-2、跳台阶" class="headerlink" title="10-2、跳台阶"></a>10-2、跳台阶</h2><p><strong>题目描述</strong></p><p>一只青蛙一次可以跳上1级台阶，也可以跳上2级。求该青蛙跳上一个n级的台阶总共有多少种跳法（先后次序不同算不同的结果）。</p><p><strong>思路分析</strong></p><p>这道题跟前面的斐波那契数列很类似。我们可以用反向思维来理解，假设青蛙跳到第n阶台阶，那么它的上一步会在哪呢？要么在n-1阶台阶，要么在n-2阶台阶，这样我们就可以得到青蛙跳到第n阶台阶的跳法等于青蛙跳到第n-1阶台阶的跳法与跳到第n-2阶台阶的跳法之和。</p><p><strong>代码</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">numWays</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> a=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> b=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> sum;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;n; i++)&#123;</span><br><span class="line">            sum=(a+b)%<span class="number">1000000007</span>;</span><br><span class="line">            a=b;</span><br><span class="line">            b=sum;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="11、旋转数组的最小数字"><a href="#11、旋转数组的最小数字" class="headerlink" title="11、旋转数组的最小数字"></a>11、旋转数组的最小数字</h2><p><strong>题目描述</strong></p><p>把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。<br> 输入一个非递减排序的数组的一个旋转，输出旋转数组的最小元素。<br> NOTE：给出的所有元素都大于0，若数组大小为0，请返回0。</p><p><strong>示例</strong></p><p>输入：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[3,4,5,1,2]</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1</span><br></pre></td></tr></table></figure><p><strong>思路分析</strong></p><p>这题最开始没有思路，网上比较流行的就是使用二分搜索来完成，但是实现的过程也有一些细微的差异，下面列了一个我觉得较为理想的答案。首先mid大于high时，更新左边界值，而当mid小于high时，则更新右边界值，当两者相等时，很难判断，则让high自减1继续判断。</p><p><strong>代码</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minArray</span><span class="params">(<span class="keyword">int</span>[] numbers)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(numbers.length == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> low = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> high = numbers.length-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(low&lt;high)&#123;</span><br><span class="line">            <span class="keyword">int</span> mid=(low+high)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(numbers[mid]&gt;numbers[high])&#123;</span><br><span class="line">                low=mid+<span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(numbers[mid]==numbers[high])&#123;</span><br><span class="line">                high=high-<span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                high=mid;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> numbers[high];    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="15、二进制中1的个数"><a href="#15、二进制中1的个数" class="headerlink" title="15、二进制中1的个数"></a>15、二进制中1的个数</h2><p><strong>题目描述</strong><br>输入一个整数，输出该数32位二进制表示中1的个数。其中负数用补码表示。<br>输入：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">10</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2</span><br></pre></td></tr></table></figure><p><strong>思路分析</strong><br>本题因为博主不太熟悉进制转换之间的一些性质，因此只能在百度上找一些参考答案。该答案是把输入数依次无符号右移，并与1进行与运算，然后计算结果为1的个数。<br><strong>代码</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">NumberOf1</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">32</span>; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>((n &gt;&gt;&gt; i &amp; <span class="number">1</span>) == <span class="number">1</span>)</span><br><span class="line">                count++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="16、数值的整数次方"><a href="#16、数值的整数次方" class="headerlink" title="16、数值的整数次方"></a>16、数值的整数次方</h2><p><strong>题目描述</strong></p><p> 给定一个double类型的浮点数base和int类型的整数exponent。求base的exponent次方。 </p><p> 保证base和exponent不同时为0 </p><p>输入：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2,3</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">8.00000</span><br></pre></td></tr></table></figure><p><strong>思路分析</strong></p><p>都需要考虑进行exponent的判断，当exponent小于0时，将base取分数并且exponent取反，当exponent等于0时，直接返回1。使用递归的快速幂求解，当我们要求一个数的8次方时，我们只需要将这个的4次方再平方即可，奇数次方则将其再乘多一个base即可，可构造递归。</p><p><strong>代码</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">q_power</span><span class="params">(<span class="keyword">double</span> base, <span class="keyword">long</span> exponent)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(exponent ==<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">double</span> result = q_power(base,exponent/<span class="number">2</span>);</span><br><span class="line">        <span class="keyword">if</span>(exponent%<span class="number">2</span> == <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> result*result*base;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> result * result;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">myPow</span><span class="params">(<span class="keyword">double</span> base, <span class="keyword">int</span> exponent)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> b = exponent;</span><br><span class="line">        <span class="keyword">if</span>(exponent&lt;<span class="number">0</span>)&#123;</span><br><span class="line">            base = <span class="number">1</span> / base;</span><br><span class="line">            b = -b;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> q_power(base,b);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="17、打印从1到最大的n位数"><a href="#17、打印从1到最大的n位数" class="headerlink" title="17、打印从1到最大的n位数"></a>17、打印从1到最大的n位数</h2><p><strong>题目描述</strong></p><p>输入数字 <code>n</code>，按顺序打印出从 1 到最大的 n 位十进制数。比如输入 3，则打印出 1、2、3 一直到最大的 3 位数 999。</p><p>输入：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[1,2,3,4,5,6,7,8,9]</span><br></pre></td></tr></table></figure><p><strong>思路分析</strong></p><p><strong>代码</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><h2 id="21、调整数组顺序使奇数位于偶数前面"><a href="#21、调整数组顺序使奇数位于偶数前面" class="headerlink" title="21、调整数组顺序使奇数位于偶数前面"></a>21、调整数组顺序使奇数位于偶数前面</h2><p>输入一个整数数组，实现一个函数来调整该数组中数字的顺序，使得所有的奇数位于数组的前半部分，所有的偶数位于数组的后半部分，并保证奇数和奇数，偶数和偶数之间的相对位置不变。</p><p>输入：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[1,2,3,4]</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[1,3,2,4]</span><br></pre></td></tr></table></figure><p><strong>思路分析</strong></p><p>可以参考使用几种常见的排序思想，因为题目要求保证稳定性，故只能考虑使用插入排序和冒泡排序，这里使用插入排序的思想。比较相邻两个元素，当前者是偶数，后者是奇数时调换两者位置。</p><p><strong>代码</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">judge</span><span class="params">(<span class="keyword">int</span> front, <span class="keyword">int</span> back)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(front%<span class="number">2</span>==<span class="number">0</span> &amp;&amp; back%<span class="number">2</span>==<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] reOrderArray (<span class="keyword">int</span>[] array) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;array.length-<span class="number">1</span>; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=i+<span class="number">1</span>; j&gt;<span class="number">0</span> &amp;&amp; judge(array[j-<span class="number">1</span>],array[j]); j--)&#123;</span><br><span class="line">                <span class="keyword">int</span> temp = array[j-<span class="number">1</span>];</span><br><span class="line">                array[j-<span class="number">1</span>] = array[j];</span><br><span class="line">                array[j] = temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> array;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="22、链表中倒数第k个结点"><a href="#22、链表中倒数第k个结点" class="headerlink" title="22、链表中倒数第k个结点"></a>22、链表中倒数第k个结点</h2><p>  输入一个链表，输出该链表中倒数第k个结点。 </p><p>  如果该链表长度小于k，请返回空。 </p><p>输入：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;1,2,3,4,5&#125;,1 </span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;5&#125;</span><br></pre></td></tr></table></figure><p><strong>思路分析</strong></p><p>思路一：首先求出链表的长度len，然后将len与k进行比较，若k大于链表长度，则返回空，否则，就返回链表的第len-k个元素。</p><p>思路二：双指针法。首先定义一个快指针和一个慢指针，快指针先走k步，然后两个指针一起走，当快指针走到链尾时，慢指针刚好在倒数第k个结点。</p><p><strong>代码</strong></p><p>思路一：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">FindKthToTail</span> <span class="params">(ListNode pHead, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> count=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(ListNode node = pHead; node!=<span class="keyword">null</span>; node=node.next)&#123;</span><br><span class="line">            count++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(k&gt;count)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">int</span> step = count-k;</span><br><span class="line">            ListNode node = pHead;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;step; i++)&#123;</span><br><span class="line">                node=node.next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> node;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>思路二：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">FindKthToTail</span> <span class="params">(ListNode pHead, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">        ListNode fast = pHead;</span><br><span class="line">        ListNode slow = pHead;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;k; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(fast==<span class="keyword">null</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            fast=fast.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(fast!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            fast=fast.next;</span><br><span class="line">            slow=slow.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> slow;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="23、反转链表"><a href="#23、反转链表" class="headerlink" title="23、反转链表"></a>23、反转链表</h2><p>输入一个链表，反转链表后，输出新链表的表头。</p><p>输入：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;1,2,3&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;3,2,1&#125;</span><br></pre></td></tr></table></figure><p><strong>思路分析</strong></p><p>使用三个指针，三个指针分别为当前结点的前结点pre，当前结点head，当前结点的后结点next。对当前结点进行循环操作，首先使用next指针记录下当前结点head的下一个结点，然后将当前结点head的下一个结点设为pre，此时这局部的三个结点的前面两个结点就相当于反转了，而后面的结点还在，然后将pre设为head，将head设为next，继续循环即可。</p><p><strong>代码</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">ReverseList</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">        ListNode pre=<span class="keyword">null</span>;</span><br><span class="line">        ListNode next=<span class="keyword">null</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(head!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            next=head.next;</span><br><span class="line">            head.next=pre;</span><br><span class="line">            pre=head;</span><br><span class="line">            head=next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pre;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="24、合并两个排序的链表"><a href="#24、合并两个排序的链表" class="headerlink" title="24、合并两个排序的链表"></a>24、合并两个排序的链表</h2><p>输入两个单调递增的链表，输出两个链表合成后的链表，当然我们需要合成后的链表满足单调不减规则。</p><p>输入：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;1,3,5&#125;,&#123;2,4,6&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;1,2,3,4,5,6&#125;</span><br></pre></td></tr></table></figure><p><strong>思路分析</strong></p><p>使用最容易想到的遍历即可，比较两个链表节点值的大小，然后循环迭代即可！</p><p><strong>代码</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">Merge</span><span class="params">(ListNode list1,ListNode list2)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">        ListNode head = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">        ListNode new_list = head;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(list1 != <span class="keyword">null</span> &amp;&amp; list2 != <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(list1.val &gt;= list2.val)&#123;</span><br><span class="line">                new_list.next = list2;</span><br><span class="line">                list2=list2.next;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                new_list.next = list1;</span><br><span class="line">                list1 = list1.next;</span><br><span class="line">            &#125;</span><br><span class="line">            new_list=new_list.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(list1 != <span class="keyword">null</span>) new_list.next = list1;</span><br><span class="line">        <span class="keyword">if</span>(list2 != <span class="keyword">null</span>) new_list.next = list2;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> head.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="25、树的子结构"><a href="#25、树的子结构" class="headerlink" title="25、树的子结构"></a>25、树的子结构</h2><p>输入两棵二叉树A，B，判断B是不是A的子结构。（ps：我们约定空树不是任意一个树的子结构）</p><p>输入：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;8,8,#,9,#,2,#,5&#125;,&#123;8,9,#,2&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">true</span><br></pre></td></tr></table></figure><p><strong>思路分析</strong></p><p>思路的话就是首先就是从B的根节点开始判断，如果A树中有与B树的根节点一样的节点，再循环遍历B树的左右节点是否跟该节点的左右节点相同即可。</p><p><strong>代码</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">judge</span><span class="params">(TreeNode root1, TreeNode subtree)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(subtree == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">if</span>(root1 == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">if</span>(root1.val == subtree.val)&#123;</span><br><span class="line">            <span class="keyword">return</span> judge(root1.left,subtree.left) &amp;&amp; judge(root1.right, subtree.right);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">HasSubtree</span><span class="params">(TreeNode root1,TreeNode root2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root1 == <span class="keyword">null</span> || root2==<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(root1.val == root2.val)&#123;</span><br><span class="line">            <span class="keyword">if</span>(judge(root1,root2))&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> HasSubtree(root1.left, root2) || HasSubtree(root1.right, root2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="18、二叉树的镜像"><a href="#18、二叉树的镜像" class="headerlink" title="18、二叉树的镜像"></a>18、二叉树的镜像</h2><p><strong>题目描述</strong></p><p>操作给定的二叉树，将其变换为源二叉树的镜像。 </p><p>比如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">源二叉树 </span><br><span class="line">            8</span><br><span class="line">           &#x2F;  \</span><br><span class="line">          6   10</span><br><span class="line">         &#x2F; \  &#x2F; \</span><br><span class="line">        5  7 9 11</span><br><span class="line">        镜像二叉树</span><br><span class="line">            8</span><br><span class="line">           &#x2F;  \</span><br><span class="line">          10   6</span><br><span class="line">         &#x2F; \  &#x2F; \</span><br><span class="line">        11 9 7  5</span><br></pre></td></tr></table></figure><p><strong>示例</strong></p><p>输入：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;8,6,10,5,7,9,11&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;8,10,6,11,9,7,5&#125;</span><br></pre></td></tr></table></figure><p><strong>思路分析</strong></p><p>思路一：使用递归判断，将每个节点的左右节点反转即可。</p><p>思路二：考虑到使用递归存在极大地复杂度，因此提供思路二和思路三，分别使用二叉树的广度优先遍历和深度优先遍历来实现。使用二叉树的广度优先遍历(BFS)，将该二叉树依据广度优先遍历的准则进行左右节点反转。</p><p>思路三：使用二叉树的深度优先遍历(DFS)，将该二叉树依据深度优先遍历的准则进行左右节点反转。</p><p><strong>代码</strong></p><p>思路一：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> TreeNode <span class="title">exchange</span><span class="params">(TreeNode pRoot)</span></span>&#123;</span><br><span class="line">        TreeNode temp = pRoot.left;</span><br><span class="line">        pRoot.left = pRoot.right;</span><br><span class="line">        pRoot.right = temp;</span><br><span class="line">        <span class="keyword">return</span> pRoot;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">Mirror</span> <span class="params">(TreeNode pRoot)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(pRoot == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> pRoot;</span><br><span class="line">        &#125;</span><br><span class="line">        exchange(pRoot);</span><br><span class="line">        Mirror(pRoot.left);</span><br><span class="line">        Mirror(pRoot.right);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> pRoot;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>思路二：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> TreeNode <span class="title">exchange</span><span class="params">(TreeNode pRoot)</span></span>&#123;</span><br><span class="line">        TreeNode temp = pRoot.left;</span><br><span class="line">        pRoot.left = pRoot.right;</span><br><span class="line">        pRoot.right = temp;</span><br><span class="line">        <span class="keyword">return</span> pRoot;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">Mirror</span> <span class="params">(TreeNode pRoot)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(pRoot == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> pRoot;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> LinkedList&lt;TreeNode&gt;();</span><br><span class="line">        queue.add(pRoot);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(!queue.isEmpty())&#123;</span><br><span class="line">            TreeNode node = queue.poll();</span><br><span class="line">            exchange(node);</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span>(node.left != <span class="keyword">null</span>) queue.add(node.left);</span><br><span class="line">            <span class="keyword">if</span>(node.right != <span class="keyword">null</span>) queue.add(node.right);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pRoot;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>思路三：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> TreeNode <span class="title">exchange</span><span class="params">(TreeNode pRoot)</span></span>&#123;</span><br><span class="line">        TreeNode temp = pRoot.left;</span><br><span class="line">        pRoot.left = pRoot.right;</span><br><span class="line">        pRoot.right = temp;</span><br><span class="line">        <span class="keyword">return</span> pRoot;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">Mirror</span> <span class="params">(TreeNode pRoot)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(pRoot == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> pRoot;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        Stack&lt;TreeNode&gt; stack = <span class="keyword">new</span> Stack&lt;TreeNode&gt;();</span><br><span class="line">        stack.push(pRoot);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(!stack.isEmpty())&#123;</span><br><span class="line">            TreeNode node = stack.pop();</span><br><span class="line">            exchange(node);</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span>(node.left != <span class="keyword">null</span>) stack.add(node.left);</span><br><span class="line">            <span class="keyword">if</span>(node.right != <span class="keyword">null</span>) stack.add(node.right);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pRoot;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="19、顺时针打印矩阵"><a href="#19、顺时针打印矩阵" class="headerlink" title="19、顺时针打印矩阵"></a>19、顺时针打印矩阵</h2><p><strong>题目描述</strong></p><p>输入一个矩阵，按照从外向里以顺时针的顺序依次打印出每一个数字，例如，如果输入如下4 X 4矩阵： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 则依次打印出数字1,2,3,4,8,12,16,15,14,13,9,5,6,7,11,10. </p><p><strong>示例</strong></p><p>输入：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[[1,2],[3,4]]</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[1,2,4,3]</span><br></pre></td></tr></table></figure><p><strong>思路分析</strong></p><p>思路一：按顺序输出，定义上下左右四个结点，找到顺时针打印矩阵的规律，当上边界大于下边界或左边界大于右边界时，停止循环。</p><p><strong>代码</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ArrayList&lt;Integer&gt; <span class="title">printMatrix</span><span class="params">(<span class="keyword">int</span> [][] matrix)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">        ArrayList&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> top = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> bottom = matrix.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> right = matrix[<span class="number">0</span>].length - <span class="number">1</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=left; i&lt;=right; i++)&#123;</span><br><span class="line">            list.add(matrix[top][i]);</span><br><span class="line">            &#125;</span><br><span class="line">            top++;</span><br><span class="line">            <span class="keyword">if</span>(top&gt;bottom) <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=top; j&lt;=bottom; j++)&#123;</span><br><span class="line">                list.add(matrix[j][right]);</span><br><span class="line">            &#125;</span><br><span class="line">            right--;</span><br><span class="line">            <span class="keyword">if</span>(left&gt;right) <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> k=right; k&gt;=left; k--)&#123;</span><br><span class="line">                list.add(matrix[bottom][k]);</span><br><span class="line">            &#125;</span><br><span class="line">            bottom--;</span><br><span class="line">            <span class="keyword">if</span>(top&gt;bottom) <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=bottom; j&gt;=top; j--)&#123;</span><br><span class="line">                list.add(matrix[j][left]);</span><br><span class="line">            &#125;</span><br><span class="line">            left++;</span><br><span class="line">            <span class="keyword">if</span>(left&gt;right) <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> list;  </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="20、包含min函数的栈"><a href="#20、包含min函数的栈" class="headerlink" title="20、包含min函数的栈"></a>20、包含min函数的栈</h2><p><strong>题目描述</strong></p><p>定义栈的数据结构，请在该类型中实现一个能够得到栈中所含最小元素的min函数（时间复杂度应为O（1））。</p><p><strong>思路分析</strong></p><p>参考了别人的思路，这里也是使用了两个栈。<br>一个用来存所有的元素<code>stackTotal</code>,另一个用来存加入新的元素后当前<code>stackTotal</code>中对应的最小值。<br>两个栈中的元素数量始终保持一致，当新的元素小于<code>stackLittle</code>栈顶元素时，<code>stackLittle</code>像栈顶push新来的元素，否则，<code>stackLittle</code>向栈顶加入原栈顶元素。<br>执行“pop”方法时，两个栈同时弹出各自的栈顶元素。</p><p><strong>代码</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Stack;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    Stack&lt;Integer&gt; stackTotal = <span class="keyword">new</span> Stack&lt;Integer&gt;();</span><br><span class="line">    Stack&lt;Integer&gt; stackLittle = <span class="keyword">new</span> Stack&lt;Integer&gt;();</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> node)</span> </span>&#123;</span><br><span class="line">        stackTotal.push(node);</span><br><span class="line">        <span class="keyword">if</span>(stackLittle.empty())&#123;</span><br><span class="line">            stackLittle.push(node);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(node &lt;= stackLittle.peek())&#123;</span><br><span class="line">                stackLittle.push(node);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                stackLittle.push(stackLittle.peek());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        stackTotal.pop();</span><br><span class="line">        stackLittle.pop();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">top</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> stackTotal.peek();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">min</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> stackLittle.peek();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="21、栈的压入、弹出序列"><a href="#21、栈的压入、弹出序列" class="headerlink" title="21、栈的压入、弹出序列"></a>21、栈的压入、弹出序列</h2><p><strong>题目描述</strong></p><p>输入两个整数序列，第一个序列表示栈的压入顺序，请判断第二个序列是否可能为该栈的弹出顺序。假设压入栈的所有数字均不相等。例如序列1,2,3,4,5是某栈的压入顺序，序列4,5,3,2,1是该压栈序列对应的一个弹出序列，但4,3,5,1,2就不可能是该压栈序列的弹出序列。（注意：这两个序列的长度是相等的）</p><p><strong>示例</strong></p><p>输入：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[1,2,3,4,5],[4,3,5,1,2]</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">false</span><br></pre></td></tr></table></figure><p><strong>思路分析</strong></p><p>这道题主要是使用模拟的思想，定义一个压入栈，将<code>pushA</code>中的元素一个个压入栈，每次将元素压入栈之后，循环判断栈顶元素是否与出栈列表的元素相等，如果相等则将对应元素出栈，出栈<code>count</code>加1，则循环判断。最后返回压入栈的<code>isEmpty()</code>即可。</p><p><strong>代码</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Stack;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">IsPopOrder</span><span class="params">(<span class="keyword">int</span> [] pushA,<span class="keyword">int</span> [] popA)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">        Stack&lt;Integer&gt; stack = <span class="keyword">new</span> Stack();</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;pushA.length; i++)&#123;</span><br><span class="line">            stack.push(pushA[i]);</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">while</span>(!stack.isEmpty() &amp;&amp; stack.peek()==popA[count])&#123;</span><br><span class="line">                stack.pop();</span><br><span class="line">                count++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> stack.isEmpty();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="22、从上往下打印二叉树"><a href="#22、从上往下打印二叉树" class="headerlink" title="22、从上往下打印二叉树"></a>22、从上往下打印二叉树</h2><p><strong>题目描述</strong></p><p>从上往下打印出二叉树的每个节点，同层节点从左至右打印。</p><p><strong>示例</strong></p><p>输入：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;5,4,#,3,#,2,#,1&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[5,4,3,2,1]</span><br></pre></td></tr></table></figure><p><strong>思路分析</strong></p><p>这道题主要运用的思想就是二叉树的广度优先遍历(BFS)，具体实现参见代码或者第18题的思路分析。</p><p><strong>代码</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ArrayList&lt;Integer&gt; <span class="title">PrintFromTopToBottom</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">        ArrayList&lt;Integer&gt; array = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>) <span class="keyword">return</span> array;</span><br><span class="line">        </span><br><span class="line">        queue.add(root);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(!queue.isEmpty())&#123;</span><br><span class="line">            </span><br><span class="line">            TreeNode node = queue.poll();</span><br><span class="line">            array.add(node.val);</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span>(node.left != <span class="keyword">null</span>) queue.add(node.left);</span><br><span class="line">            <span class="keyword">if</span>(node.right != <span class="keyword">null</span>) queue.add(node.right);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> array;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="23、二叉搜索树的后序遍历序列"><a href="#23、二叉搜索树的后序遍历序列" class="headerlink" title="23、二叉搜索树的后序遍历序列"></a>23、二叉搜索树的后序遍历序列</h2><p><strong>题目描述</strong></p><p>输入一个整数数组，判断该数组是不是某二叉搜索树的后序遍历的结果。如果是则返回true,否则返回false。假设输入的数组的任意两个数字都互不相同。（ps：我们约定空树不是二叉搜素树）</p><p><strong>示例</strong></p><p>输入：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[4,8,6,12,16,14,10]</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">true</span><br></pre></td></tr></table></figure><p><strong>思路分析</strong></p><p>思路一：使用递归判断，二叉树的后序遍历输出时，其最后一个结点为root结点，因此我们将该数组从后往前遍历，找到第一个小于root结点的元素，该节点就是root结点的左子树的根节点，该节点加左边的元素就是root结点的左子树，该节点右边的元素就是root结点的右子树。BST的特点就是左子结点&lt;根结点&lt;右子结点，因此，循环递归判断即可。</p><p><strong>代码</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isBST</span><span class="params">(<span class="keyword">int</span>[] seq, <span class="keyword">int</span> start, <span class="keyword">int</span> root)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(start &gt;= root)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> i = root;</span><br><span class="line">        <span class="keyword">while</span>(i&gt;start &amp;&amp; seq[i-<span class="number">1</span>] &gt; seq[root])&#123;</span><br><span class="line">            i--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = start ; j&lt; i-<span class="number">1</span>;j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(seq[j]&gt;seq[root])&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> isBST(seq,start , i-<span class="number">1</span>)&amp;&amp;isBST(seq,i,root-<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">VerifySquenceOfBST</span><span class="params">(<span class="keyword">int</span> [] sequence)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(sequence.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">return</span> isBST(sequence, <span class="number">0</span>, sequence.length-<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="24、二叉树中和未某一值的路径"><a href="#24、二叉树中和未某一值的路径" class="headerlink" title="24、二叉树中和未某一值的路径"></a>24、二叉树中和未某一值的路径</h2><p><strong>题目描述</strong></p><p>输入一颗二叉树的根节点和一个整数，按字典序打印出二叉树中结点值的和为输入整数的所有路径。路径定义为从树的根结点开始往下一直到叶结点所经过的结点形成一条路径。</p><p><strong>示例</strong></p><p>输入：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;10,5,12,4,7&#125;,22</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[[10,5,7],[10,12]]</span><br></pre></td></tr></table></figure><p><strong>思路分析</strong></p><p>使用递归判断，新建一个result集和list集。当root结点为null时就直接返回result，否则将lroot的值加入list，同时target减去root的值。然后判断此时是否为叶结点，如果是叶结点且target为0，表示此时这条路径就是一个答案，将list加入result，否则继续遍历该结点的左右结点。如果这条路径不合适，则最后去掉list中这条路径上的元素。</p><p><strong>代码</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    ArrayList&lt;ArrayList&lt;Integer&gt;&gt; result = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    ArrayList&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> ArrayList&lt;ArrayList&lt;Integer&gt;&gt; FindPath(TreeNode root,<span class="keyword">int</span> target) &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>) <span class="keyword">return</span> result;</span><br><span class="line">        </span><br><span class="line">        list.add(root.val);</span><br><span class="line">        target-=root.val;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(target==<span class="number">0</span> &amp;&amp; root.left==<span class="keyword">null</span> &amp;&amp; root.right==<span class="keyword">null</span>)&#123;</span><br><span class="line">            result.add(<span class="keyword">new</span> ArrayList&lt;Integer&gt;(list));</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        FindPath(root.left,target);</span><br><span class="line">        FindPath(root.right,target);</span><br><span class="line">        </span><br><span class="line">        list.remove(list.size()-<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="25、复杂链表的拷贝"><a href="#25、复杂链表的拷贝" class="headerlink" title="25、复杂链表的拷贝"></a>25、复杂链表的拷贝</h2><p><strong>题目描述</strong></p><p>输入一个复杂链表（每个节点中有节点值，以及两个指针，一个指向下一个节点，另一个特殊指针random指向一个随机节点），请对此链表进行深拷贝，并返回拷贝后的头结点。（注意，输出结果中请不要返回参数中的节点引用，否则判题程序会直接返回空）</p><p><strong>思路分析</strong></p><p>题目说的是需要进行深拷贝，即返回的复杂链表不能有原有链表的引用，这就需要考虑建立一个原有链表的值与新链表的一一对应的关系。新建一个<code>HashMap</code>，使用原有的结点引用作为键，使用结点的引用的label新建一个结点，来作为值。接下来只需要依据<code>HashMap</code>来建立新的链表即可。</p><p><strong>代码</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> RandomListNode <span class="title">Clone</span><span class="params">(RandomListNode pHead)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(pHead == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        </span><br><span class="line">        RandomListNode target = <span class="keyword">new</span> RandomListNode(pHead.label);</span><br><span class="line">        RandomListNode p = target;</span><br><span class="line">        RandomListNode cur = pHead;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//存储映射关系</span></span><br><span class="line">        HashMap&lt;RandomListNode, RandomListNode&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">while</span>(pHead != <span class="keyword">null</span>)&#123;</span><br><span class="line">            map.put(pHead, <span class="keyword">new</span> RandomListNode(pHead.label));</span><br><span class="line">            pHead=pHead.next;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//用键值对对应的方式取出对应的值</span></span><br><span class="line">        <span class="keyword">while</span>(cur != <span class="keyword">null</span>)&#123;</span><br><span class="line">            p.next = map.get(cur.next);</span><br><span class="line">            p.random = map.get(cur.random);</span><br><span class="line">            </span><br><span class="line">            cur=cur.next;</span><br><span class="line">            p=p.next;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> target;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="26、二叉搜索树和双向链表"><a href="#26、二叉搜索树和双向链表" class="headerlink" title="26、二叉搜索树和双向链表"></a>26、二叉搜索树和双向链表</h2><p><strong>题目描述</strong></p><p>输入一棵二叉搜索树，将该二叉搜索树转换成一个排序的双向链表。要求不能创建任何新的结点，只能调整树中结点指针的指向。</p><p><strong>思路分析</strong></p><p>思路一：最简单的一种思路就是，因为题目给的是二叉搜索树，使用中序遍历将二叉树的每个节点保存在一个<code>ArrayList</code>里，然后构造双向链表即可。</p><p>思路二：借鉴评论区一位大佬的答案，使用线索二叉树去解决</p><p><strong>代码</strong></p><p>思路一：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">Convert</span><span class="params">(TreeNode pRootOfTree)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(pRootOfTree == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        </span><br><span class="line">        ArrayList&lt;TreeNode&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        Stack&lt;TreeNode&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(pRootOfTree!=<span class="keyword">null</span> || !stack.isEmpty())&#123;</span><br><span class="line">            <span class="keyword">if</span>(pRootOfTree!=<span class="keyword">null</span>)&#123;</span><br><span class="line">                stack.push(pRootOfTree);</span><br><span class="line">                pRootOfTree=pRootOfTree.left;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                pRootOfTree = stack.pop();</span><br><span class="line">                list.add(pRootOfTree);</span><br><span class="line">                pRootOfTree=pRootOfTree.right;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;list.size()-<span class="number">1</span>; i++)&#123;</span><br><span class="line">            list.get(i).right = list.get(i+<span class="number">1</span>);</span><br><span class="line">            list.get(i+<span class="number">1</span>).left = list.get(i);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> list.get(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>思路二：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    TreeNode pre=<span class="keyword">null</span>;</span><br><span class="line">    TreeNode root=<span class="keyword">null</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">Convert</span><span class="params">(TreeNode pRootOfTree)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(pRootOfTree == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        </span><br><span class="line">        Convert(pRootOfTree.left);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(root==<span class="keyword">null</span>)&#123;</span><br><span class="line">            root=pRootOfTree;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(pre!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            pRootOfTree.left=pre;</span><br><span class="line">            pre.right=pRootOfTree;</span><br><span class="line">        &#125;</span><br><span class="line">        pre=pRootOfTree;</span><br><span class="line">        Convert(pRootOfTree.right);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="27、字符串的排列"><a href="#27、字符串的排列" class="headerlink" title="27、字符串的排列"></a>27、字符串的排列</h2><p><strong>题目描述</strong></p><p>输入一个字符串,按字典序打印出该字符串中字符的所有排列。例如输入字符串abc,则按字典序打印出由字符a,b,c所能排列出来的所有字符串abc,acb,bac,bca,cab和cba。</p><p><strong>示例</strong></p><p>输入：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&quot;ab&quot;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[&quot;ab&quot;,&quot;ba&quot;]</span><br></pre></td></tr></table></figure><p><strong>思路分析</strong></p><p>使用递归思路解决。</p><p><strong>代码</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ArrayList&lt;String&gt; <span class="title">Permutation</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">       ArrayList&lt;String&gt; result = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">       <span class="keyword">if</span>(str.length() == <span class="number">0</span>)&#123;</span><br><span class="line">           <span class="keyword">return</span> result;</span><br><span class="line">       &#125;</span><br><span class="line">       recur(str,<span class="string">&quot;&quot;</span>,result);</span><br><span class="line">       <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">recur</span><span class="params">(String str,String cur,ArrayList&lt;String&gt; result)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(str.length() == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!result.contains(cur))&#123;</span><br><span class="line">                result.add(cur);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; str.length();i++)&#123;</span><br><span class="line">            recur(str.substring(<span class="number">0</span>,i)+str.substring(i+<span class="number">1</span>,str.length()),cur+str.charAt(i),result);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="28、数组中出现数超过一半的数字"><a href="#28、数组中出现数超过一半的数字" class="headerlink" title="28、数组中出现数超过一半的数字"></a>28、数组中出现数超过一半的数字</h2><p><strong>题目描述</strong></p><p>数组中有一个数字出现的次数超过数组长度的一半，请找出这个数字。例如输入一个长度为9的数组{1,2,3,2,2,2,5,4,2}。由于数字2在数组中出现了5次，超过数组长度的一半，因此输出2。如果不存在则输出0。</p><p><strong>示例</strong></p><p>输入：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[1,2,3,2,2,2,5,4,2]</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2</span><br></pre></td></tr></table></figure><p><strong>思路分析</strong></p><p>思路一：这种计数类的题目，可以选择新建一个<code>HashMap</code>来存储数组的计数结果，键为数组中出现的数字，值为数字出现的次数，然后选择出超过数组长度一半的值就行了。</p><p>思路二：第二种思路是借鉴的摩尔投票法的思路。摩尔投票法的大概思路就是<strong>每次从序列里选择两个不相同的数字删除掉（或称为“抵消”），最后剩下一个数字或几个相同的数字，就是出现次数大于总数一半的那个。</strong>本题使用摩尔投票法的大概思路就是如果存在一个出现次数超过数组长度一半的众数，则使用摩尔投票法之后最后留下的一个或多个数字一定就是那个众数。但为了排除不存在众数的情况下，则最后需要验证一下是否为出现次数超过数组长度一半的那个众数。</p><p><strong>代码</strong></p><p>思路一：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">MoreThanHalfNum_Solution</span><span class="params">(<span class="keyword">int</span> [] array)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(array.length ==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        HashMap&lt;Integer,Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">int</span> len = array.length;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;array.length; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(map.keySet().contains(array[i]))&#123;</span><br><span class="line">                map.put(array[i],map.get(array[i])+<span class="number">1</span>);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                map.put(array[i],<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(Integer key: map.keySet())&#123;</span><br><span class="line">            <span class="keyword">if</span>(map.get(key)&gt;len/<span class="number">2</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> key;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>思路二：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">MoreThanHalfNum_Solution</span><span class="params">(<span class="keyword">int</span> [] array)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(array.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> morgen=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> vote=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;array.length; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(vote==<span class="number">0</span>)&#123;</span><br><span class="line">                morgen=array[i];</span><br><span class="line">                vote++;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">if</span>(array[i]==morgen)&#123;</span><br><span class="line">                    vote++;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    vote--;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//检查morgen是否为众数</span></span><br><span class="line">        <span class="keyword">int</span> tmp=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;array.length; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(array[i]==morgen)&#123;</span><br><span class="line">                tmp++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(tmp&gt;array.length/<span class="number">2</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> morgen;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="29、最小的K个数"><a href="#29、最小的K个数" class="headerlink" title="29、最小的K个数"></a>29、最小的K个数</h2><p><strong>题目描述</strong></p><p>给定一个数组，找出其中最小的K个数。例如数组元素是4,5,1,6,2,7,3,8这8个数字，则最小的4个数字是1,2,3,4。如果K&gt;数组的长度，那么返回一个空的数组</p><p><strong>示例</strong></p><p>输入：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[4,5,1,6,2,7,3,8],4 </span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[1,2,3,4]</span><br></pre></td></tr></table></figure><p><strong>思路分析</strong></p><p>思路一：最简单的思路就是首先使用排序算法将<code>input</code>数组排序，然后输出前k个值就行了。这里使用的排序算法是冒泡排序。</p><p>思路二：沿用第一种思路，排序算法用快速排序</p><p><strong>代码</strong></p><p>思路一：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ArrayList&lt;Integer&gt; <span class="title">GetLeastNumbers_Solution</span><span class="params">(<span class="keyword">int</span> [] input, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(k&gt;input.length) <span class="keyword">return</span> <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">       </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;input.length; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;input.length-i-<span class="number">1</span>; j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(input[j]&gt;input[j+<span class="number">1</span>])&#123;</span><br><span class="line">                    <span class="keyword">int</span> temp = input[j];</span><br><span class="line">                    input[j] = input[j+<span class="number">1</span>];</span><br><span class="line">                    input[j+<span class="number">1</span>] = temp;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ArrayList&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;k; i++)&#123;</span><br><span class="line">            list.add(input[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>思路二：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ArrayList&lt;Integer&gt; <span class="title">GetLeastNumbers_Solution</span><span class="params">(<span class="keyword">int</span> [] input, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(k&gt;input.length) <span class="keyword">return</span> <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">        </span><br><span class="line">        quickSort(input,<span class="number">0</span>,input.length-<span class="number">1</span>);</span><br><span class="line">        </span><br><span class="line">        ArrayList&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;k; i++)&#123;</span><br><span class="line">            list.add(input[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">quickSort</span><span class="params">(<span class="keyword">int</span>[] array, <span class="keyword">int</span> high, <span class="keyword">int</span> low)</span></span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(low&gt;high) <span class="keyword">return</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> i=low;</span><br><span class="line">        <span class="keyword">int</span> j=high;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> key=array[low];</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(i&lt;j)&#123;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">while</span>(i&lt;j &amp;&amp; array[j]&gt;key)&#123;</span><br><span class="line">                j--;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span>(i&lt;j &amp;&amp; array[i]&lt;=key)&#123;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(i&lt;j)&#123;</span><br><span class="line">                <span class="keyword">int</span> temp=array[i];</span><br><span class="line">                array[i]=array[j];</span><br><span class="line">                array[j]=temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//调整key</span></span><br><span class="line">        <span class="keyword">int</span> p = array[i];</span><br><span class="line">array[i] = array[low];</span><br><span class="line">array[low] = p;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//对左右子序列进行排序</span></span><br><span class="line">        quickSort(array,low,i-<span class="number">1</span>);</span><br><span class="line">        quickSort(array,i+<span class="number">1</span>,high);</span><br><span class="line">        </span><br><span class="line">    &#125;  </span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="30、连续子数组的最大和"><a href="#30、连续子数组的最大和" class="headerlink" title="30、连续子数组的最大和"></a>30、连续子数组的最大和</h2><p><strong>题目描述</strong></p><p>输入一个整型数组，数组里有正数也有负数。数组中的一个或连续多个整数组成一个子数组。求所有子数组的和的最大值。要求时间复杂度为 O(n).</p><p><strong>示例</strong></p><p>输入：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[1,-2,3,10,-4,7,2,-5]</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">18</span><br></pre></td></tr></table></figure><p><strong>思路分析</strong></p><p>思路一：该题运用动态规划的思想，我们假设该数组全为正数，则最大和的求解过程就是第一个元素累加到最后一个元素，但如果其中包含负数怎么办呢？</p><p>我们再来回忆全为正数的累加过程，第一个元素和第二个元素相加，必定大于第二个元素，但如果第一个元素为负数，那结果就是第二个元素大，那为何不从第二个元素开始累加呢？</p><p>于是我们有了思路：如果以i为截断点，之前的array[i]累加小于单个的array[i]，那就说明前面元素累加相对于当前array[i]来说是负作用，应该舍弃，累加从array[i]开始，反之，则前面的累加为正作用，累加应从上一个前面累加开始，每次记录最大的max，遍历数组之后就可以得到连续子数组的最大和。</p><p><strong>代码</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">FindGreatestSumOfSubArray</span><span class="params">(<span class="keyword">int</span>[] array)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> len = array.length;</span><br><span class="line">        <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[len];</span><br><span class="line">        <span class="keyword">int</span> max = array[<span class="number">0</span>];</span><br><span class="line">        dp[<span class="number">0</span>] = array[<span class="number">0</span>];</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;len; i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> newMax = dp[i-<span class="number">1</span>] +array[i];</span><br><span class="line">            <span class="keyword">if</span>(newMax&gt;array[i])&#123;</span><br><span class="line">                dp[i]=newMax;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                dp[i]=array[i];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(dp[i]&gt;max)</span><br><span class="line">                max=dp[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id=""><a href="#" class="headerlink" title=""></a></h2><h2 id="9、变态跳台阶"><a href="#9、变态跳台阶" class="headerlink" title="9、变态跳台阶"></a>9、变态跳台阶</h2><p><strong>题目描述</strong></p><p>一只青蛙一次可以跳上1级台阶，也可以跳上2级……它也可以跳上n级。求该青蛙跳上一个n级的台阶总共有多少种跳法。</p><p><strong>思路分析</strong></p><p>思路一：这道题跟是跳台阶的拓展，使用数组来存储每次计算的结果即可。比起原来的跳台阶问题，这次跳台阶只需要每次循环加总前面数组的元素即可。</p><p>思路二：f(n)=f(n-1)+f(n-2)……+f(1)；f(n-1)=f(n-2)+f(n-3)……+f(1)；由此可得到f(n)=2f(n-1)，而f(1)等于1，f(2)就等于2，因此f(n)=2的n-1次方。</p><p><strong>代码</strong></p><p>思路一：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">jumpFloorII</span><span class="params">(<span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span>[] array = <span class="keyword">new</span> <span class="keyword">int</span>[target+<span class="number">1</span>];</span><br><span class="line">        array[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">        array[<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>; i&lt;target+<span class="number">1</span>; i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;array.length; j++)&#123;</span><br><span class="line">                count+=array[j];</span><br><span class="line">            &#125;</span><br><span class="line">            array[i]=count;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> array[target];</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>思路二：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">jumpFloorII</span><span class="params">(<span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">int</span>)Math.pow(<span class="number">2</span>,target-<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="10、矩阵覆盖"><a href="#10、矩阵覆盖" class="headerlink" title="10、矩阵覆盖"></a>10、矩阵覆盖</h2><p><strong>题目描述</strong><br>我们可以用2<em>1的小矩形横着或者竖着去覆盖更大的矩形。请问用n个2</em>1的小矩形无重叠地覆盖一个2*n的大矩形，总共有多少种方法？<br>输入：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">4</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">5</span><br></pre></td></tr></table></figure><p><strong>思路分析</strong><br>这同样也是一道递归的题目一个2<em>n的大矩形的覆盖方法，等于2</em>(n-1)的大矩形的覆盖方法加上2*(n-2)的大矩形的覆盖方法，使用数组的方式存储递归结果。<br><strong>代码</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">rectCover</span><span class="params">(<span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] array = <span class="keyword">new</span> <span class="keyword">int</span>[target+<span class="number">5</span>];</span><br><span class="line">        </span><br><span class="line">        array[<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">        array[<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">        array[<span class="number">2</span>]=<span class="number">2</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">3</span>; i&lt;target+<span class="number">1</span>; i++)&#123;</span><br><span class="line">            array[i]=array[i-<span class="number">1</span>]+array[i-<span class="number">2</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> array[target];</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="-1"><a href="#-1" class="headerlink" title=""></a></h2>]]></content:encoded>
      
      
      <category domain="http://zhuferron.github.io/categories/%E5%89%91%E6%8C%87offer/">剑指offer</category>
      
      
      <category domain="http://zhuferron.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/">数据结构与算法</category>
      
      
      <comments>http://zhuferron.github.io/2021/03/28/%E5%89%91%E6%8C%87offer%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>MybatisPlus学习笔记</title>
      <link>http://zhuferron.github.io/2021/03/24/MybatisPlus%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</link>
      <guid>http://zhuferron.github.io/2021/03/24/MybatisPlus%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</guid>
      <pubDate>Wed, 24 Mar 2021 03:59:49 GMT</pubDate>
      
      <description>根据狂神学习MybatisPlus的笔记，本文深入浅出地讲解了MybatisPlus的使用</description>
      
      
      
      <content:encoded><![CDATA[<h2 id="1、MybatisPlus概述"><a href="#1、MybatisPlus概述" class="headerlink" title="1、MybatisPlus概述"></a>1、MybatisPlus概述</h2><h3 id="1-1、简介"><a href="#1-1、简介" class="headerlink" title="1.1、简介"></a>1.1、简介</h3><p>Mybatis本来就是简化JDBC操作的，<a href="https://github.com/baomidou/mybatis-plus">MyBatis-Plus</a><a href="https://github.com/baomidou/mybatis-plus"> </a><a href="https://github.com/baomidou/mybatis-plus"> (opens new window)</a>（简称 MP）是一个 <a href="http://www.mybatis.org/mybatis-3/">MyBatis</a><a href="http://www.mybatis.org/mybatis-3/"> </a><a href="http://www.mybatis.org/mybatis-3/"> (opens new window)</a> 的增强工具，在 MyBatis 的基础上只做增强不做改变，为简化开发、提高效率而生。</p><p>官网：<a href="https://mp.baomidou.com/">https://mp.baomidou.com/</a></p><p><img src="http://fl.ljuuu.com/img/20210324090355.png"></p><h3 id="1-2、特性"><a href="#1-2、特性" class="headerlink" title="1.2、特性"></a>1.2、特性</h3><ul><li><strong>无侵入</strong>：只做增强不做改变，引入它不会对现有工程产生影响，如丝般顺滑</li><li><strong>损耗小</strong>：启动即会自动注入基本 CURD，性能基本无损耗，直接面向对象操作</li><li><strong>强大的 CRUD 操作</strong>：内置通用 Mapper、通用 Service，仅仅通过少量配置即可实现单表大部分 CRUD 操作，更有强大的条件构造器，满足各类使用需求</li><li><strong>支持 Lambda 形式调用</strong>：通过 Lambda 表达式，方便的编写各类查询条件，无需再担心字段写错</li><li><strong>支持主键自动生成</strong>：支持多达 4 种主键策略（内含分布式唯一 ID 生成器 - Sequence），可自由配置，完美解决主键问题</li><li><strong>支持 ActiveRecord 模式</strong>：支持 ActiveRecord 形式调用，实体类只需继承 Model 类即可进行强大的 CRUD 操作</li><li><strong>支持自定义全局通用操作</strong>：支持全局通用方法注入（ Write once, use anywhere ）</li><li><strong>内置代码生成器</strong>：采用代码或者 Maven 插件可快速生成 Mapper 、 Model 、 Service 、 Controller 层代码，支持模板引擎，更有超多自定义配置等您来使用（<strong>自动帮你生成代码</strong>）</li><li><strong>内置分页插件</strong>：基于 MyBatis 物理分页，开发者无需关心具体操作，配置好插件之后，写分页等同于普通 List 查询</li><li><strong>分页插件支持多种数据库</strong>：支持 MySQL、MariaDB、Oracle、DB2、H2、HSQL、SQLite、Postgre、SQLServer 等多种数据库</li><li><strong>内置性能分析插件</strong>：可输出 Sql 语句以及其执行时间，建议开发测试时启用该功能，能快速揪出慢查询</li><li><strong>内置全局拦截插件</strong>：提供全表 delete 、 update 操作智能分析阻断，也可自定义拦截规则，预防误操作</li></ul><h2 id="2、快速入门"><a href="#2、快速入门" class="headerlink" title="2、快速入门"></a>2、快速入门</h2><ul><li><p>创建数据库<code>db01</code>，创建表<code>user</code>：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span> IF <span class="keyword">EXISTS</span> <span class="keyword">user</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="keyword">user</span></span><br><span class="line">(</span><br><span class="line">id <span class="type">BIGINT</span>(<span class="number">20</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;主键ID&#x27;</span>,</span><br><span class="line">name <span class="type">VARCHAR</span>(<span class="number">30</span>) <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;姓名&#x27;</span>,</span><br><span class="line">age <span class="type">INT</span>(<span class="number">11</span>) <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;年龄&#x27;</span>,</span><br><span class="line">email <span class="type">VARCHAR</span>(<span class="number">50</span>) <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;邮箱&#x27;</span>,</span><br><span class="line"><span class="keyword">PRIMARY</span> KEY (id)</span><br><span class="line">);</span><br><span class="line"><span class="comment">--真实开发中，version(乐观锁)、delete(逻辑删除)、gmt_create、gmt_modified</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="keyword">user</span> (id, name, age, email) <span class="keyword">VALUES</span></span><br><span class="line">(<span class="number">1</span>, <span class="string">&#x27;Jone&#x27;</span>, <span class="number">18</span>, <span class="string">&#x27;test1@baomidou.com&#x27;</span>),</span><br><span class="line">(<span class="number">2</span>, <span class="string">&#x27;Jack&#x27;</span>, <span class="number">20</span>, <span class="string">&#x27;test2@baomidou.com&#x27;</span>),</span><br><span class="line">(<span class="number">3</span>, <span class="string">&#x27;Tom&#x27;</span>, <span class="number">28</span>, <span class="string">&#x27;test3@baomidou.com&#x27;</span>),</span><br><span class="line">(<span class="number">4</span>, <span class="string">&#x27;Sandy&#x27;</span>, <span class="number">21</span>, <span class="string">&#x27;test4@baomidou.com&#x27;</span>),</span><br><span class="line">(<span class="number">5</span>, <span class="string">&#x27;Billie&#x27;</span>, <span class="number">24</span>, <span class="string">&#x27;test5@baomidou.com&#x27;</span>);</span><br></pre></td></tr></table></figure></li><li><p>编写springboot项目，导入依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.1.47<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.projectlombok<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>lombok<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.18.12<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- mybatisplus依赖 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.baomidou<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis-plus-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.0.5<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>说明：我们使用mybatisplus可以节省我们大量的代码，尽量不要同时导入mybatis和mybatisplus</p></li><li><p>连接数据库</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">8080</span></span><br><span class="line"></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">datasource:</span></span><br><span class="line">    <span class="attr">driver-class-name:</span> <span class="string">com.mysql.jdbc.Driver</span></span><br><span class="line">    <span class="attr">url:</span> <span class="string">jdbc:mysql://localhost:3306/db01?useSSL=false&amp;useUnicode=true&amp;characterEncoding=UTF-8&amp;serverTimezone=UTC</span></span><br><span class="line">    <span class="attr">username:</span> <span class="string">root</span></span><br><span class="line">    <span class="attr">password:</span> <span class="string">*********</span></span><br></pre></td></tr></table></figure></li><li><p>传统：pojo-dao(连接mybatis、配置mapper.xml)-service-controller</p></li><li><p>使用mybatisplus</p><ul><li><p>dao</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="meta">@NoArgsConstructor</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> Integer age;</span><br><span class="line">    <span class="keyword">private</span> String email;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>mapper：继承<code>BaseMapper</code>类即可，基本的CRUD方法都有了，你如果需要拓展的方法跟往常一样编写即可</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//在对应的Mapper上面集成基本的类BaseMapper</span></span><br><span class="line"><span class="meta">@Repository</span></span><br><span class="line"><span class="meta">@Mapper</span>  <span class="comment">//这里加@Mapper注解，否则就是在主启动类上添加@MapperScan注解</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserMapper</span> <span class="keyword">extends</span> <span class="title">BaseMapper</span>&lt;<span class="title">User</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">//所有的CRUD已经完成</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>测试</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">contextLoads</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//查询全部用户</span></span><br><span class="line">    <span class="comment">//参数是一个Wrapper，条件构造器</span></span><br><span class="line">    List&lt;User&gt; users = userMapper.selectList(<span class="keyword">null</span>);</span><br><span class="line">    users.forEach(System.out::println);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul><h2 id="3、CRUD"><a href="#3、CRUD" class="headerlink" title="3、CRUD"></a>3、CRUD</h2><h3 id="3-1、插入"><a href="#3-1、插入" class="headerlink" title="3.1、插入"></a>3.1、插入</h3><ul><li><p>测试插入</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//插入测试</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span></span>&#123;</span><br><span class="line">    User user = <span class="keyword">new</span> User();</span><br><span class="line">    user.setName(<span class="string">&quot;ferron&quot;</span>);</span><br><span class="line">    user.setAge(<span class="number">20</span>);</span><br><span class="line">    user.setEmail(<span class="string">&quot;2963624004@qq.com&quot;</span>);</span><br><span class="line">    System.out.println(user);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> insert = userMapper.insert(user);  <span class="comment">//会帮我们自动生成id</span></span><br><span class="line">    System.out.println(insert);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>发现我们没有填写id它竟然会自动帮我们生成id！—&gt;<strong>主键生成算法</strong></p></li><li><p>默认策略：全局唯一ID</p><p><img src="http://fl.ljuuu.com/img/20210324090136.png"></p></li><li><p>雪花算法</p><ul><li>分布式唯一id生成算法汇总：<a href="https://blog.csdn.net/cyl101816/article/details/107002852">https://blog.csdn.net/cyl101816/article/details/107002852</a></li><li>snowflake是Twitter开源的分布式ID生成算法，结果是一个long型的ID。其核心思想是：使用41bit作为毫秒数，10bit作为机器的ID（5个bit是数据中心，5个bit的机器ID），12bit作为毫秒内的流水号（意味着每个节点在每毫秒可以产生 4096 个 ID），最后还有一个符号位，永远是0。具体实现的代码可以参看<a href="https://github.com/twitter/snowflake%E3%80%82">https://github.com/twitter/snowflake。</a></li><li>snowflake算法可以根据自身项目的需要进行一定的修改。比如估算未来的数据中心个数，每个数据中心的机器数以及统一毫秒可以能的并发数来调整在算法中所需要的bit数。</li><li>优点：<ul><li>不依赖于数据库，灵活方便，且性能优于数据库。</li><li>ID按照时间在单机上是递增的。</li></ul></li><li>缺点：<ul><li>在单机上是递增的，但是由于涉及到分布式环境，每台机器上的时钟不可能完全同步，也许有时候也会出现不是全局递增的情况。</li></ul></li></ul></li><li><p>主键自增：</p><ul><li>实体类字段上增加<code>@TableId(type = IdType.AUTO)</code></li><li>数据字段一定要是自增的</li></ul></li><li><p>其他的主键生成策略源代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">enum</span> <span class="title">IdType</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 数据库ID自增</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    AUTO(<span class="number">0</span>),</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 该类型为未设置主键类型</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    NONE(<span class="number">1</span>),</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 用户输入ID</span></span><br><span class="line"><span class="comment">     * 该类型可以通过自己注册自动填充插件进行填充</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    INPUT(<span class="number">2</span>),</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 以下3种类型、只有当插入对象ID 为空，才自动填充。 */</span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 全局唯一ID (idWorker)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    ID_WORKER(<span class="number">3</span>),</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 全局唯一ID (UUID)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    UUID(<span class="number">4</span>),</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 字符串全局唯一ID (idWorker 的字符串表示)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    ID_WORKER_STR(<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> key;</span><br><span class="line"></span><br><span class="line">    IdType(<span class="keyword">int</span> key) &#123;</span><br><span class="line">        <span class="keyword">this</span>.key = key;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="3-2、更新"><a href="#3-2、更新" class="headerlink" title="3.2、更新"></a>3.2、更新</h3><ul><li><p>测试更新</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//更新测试</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span></span>&#123;</span><br><span class="line">    User user = <span class="keyword">new</span> User();</span><br><span class="line">    user.setId(<span class="number">1L</span>);</span><br><span class="line">    user.setEmail(<span class="string">&quot;2963624004@qq.com&quot;</span>);</span><br><span class="line">    System.out.println(user);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> i = userMapper.updateById(user);</span><br><span class="line">    System.out.println(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>探索：发现了我们使用id来更新，想修改什么就创建好对象之后传什么就行了，mybatisplus会帮我们自动使用<strong>动态SQL</strong></p><p><img src="http://fl.ljuuu.com/img/20210324091342.png"></p></li></ul><h3 id="3-3、自动填充"><a href="#3-3、自动填充" class="headerlink" title="3.3、自动填充"></a>3.3、自动填充</h3><p>创建时间、修改时间！这些操作一般都是自动化完成的，我们不希望手动更新</p><p>阿里巴巴开发手册：所有的数据库表都需要有<code>gmt_create</code>和<code>gmt_modified</code>这两个字段，而且需要自动化实现！</p><ul><li><p>方式一：数据库修改(工作中不能使用)</p><ul><li><p>在表中新增字段<code>create_time</code>和<code>update_time</code></p><p><img src="http://fl.ljuuu.com/img/20210324091941.png"></p></li><li><p>同步实体类：使用驼峰命名</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="meta">@NoArgsConstructor</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line">    <span class="keyword">private</span> String email;</span><br><span class="line">    <span class="keyword">private</span> Date createTime;</span><br><span class="line">    <span class="keyword">private</span> Date updateTime;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>再次更新测试</p></li></ul></li><li><p>方式二：代码修改</p><ul><li><p>恢复开始的修改，数据库只添加字段，不修改值等</p><p><img src="http://fl.ljuuu.com/img/20210324092327.png"></p></li><li><p>在实体类的字段上<strong>添加注解</strong>了！</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@TableField(fill = FieldFill.INSERT)</span></span><br><span class="line"><span class="keyword">private</span> Date createTime;</span><br><span class="line"><span class="meta">@TableField(fill = FieldFill.INSERT_UPDATE)</span></span><br><span class="line"><span class="keyword">private</span> Date updateTime;</span><br></pre></td></tr></table></figure></li><li><p>新建<code>handler</code>包，编写对应的处理器来处理注解</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@Component</span>  <span class="comment">//一定不要忘记把处理器加到IOC容器中</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyMetaObjectHandler</span> <span class="keyword">implements</span> <span class="title">MetaObjectHandler</span> </span>&#123;</span><br><span class="line">    <span class="comment">//插入时候的填充策略</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insertFill</span><span class="params">(MetaObject metaObject)</span> </span>&#123;</span><br><span class="line">        log.info(<span class="string">&quot;start insert fill......&quot;</span>);</span><br><span class="line">        <span class="comment">//String fieldName, Object fieldVal, MetaObject metaObject</span></span><br><span class="line">        <span class="keyword">this</span>.setFieldValByName(<span class="string">&quot;createTime&quot;</span>,<span class="keyword">new</span> Date(),metaObject);</span><br><span class="line">        <span class="keyword">this</span>.setFieldValByName(<span class="string">&quot;updateTime&quot;</span>,<span class="keyword">new</span> Date(),metaObject);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//填充时候的填充策略</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">updateFill</span><span class="params">(MetaObject metaObject)</span> </span>&#123;</span><br><span class="line">        log.info(<span class="string">&quot;start update fill......&quot;</span>);</span><br><span class="line">        <span class="keyword">this</span>.setFieldValByName(<span class="string">&quot;updateTime&quot;</span>,<span class="keyword">new</span> Date(),metaObject);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>测试插入</p><p><img src="http://fl.ljuuu.com/img/20210324093255.png"></p></li><li><p>测试更新</p><p><img src="http://fl.ljuuu.com/img/20210324093358.png"></p></li></ul></li></ul><h3 id="3-4、乐观锁"><a href="#3-4、乐观锁" class="headerlink" title="3.4、乐观锁"></a>3.4、乐观锁</h3><p>在面试过程中，我们经常会被遇到乐观锁和悲观锁。</p><p><strong>乐观锁</strong>：它总是会认为不会出现问题，无论干什么都不会上锁，如果出现了问题，再次更新值测试(<strong>version</strong>)</p><p><strong>悲观锁</strong>：它认为怎么都会出现问题，无论干嘛都会上锁，再去操作！</p><p>乐观锁实现方式：</p><ul><li>取出记录时，获取当前version</li><li>更新时，带上这个version</li><li>执行更新时， set version = newVersion where version = oldVersion</li><li>如果version不对，就更新失败</li></ul><p><strong>测试</strong>：</p><ul><li><p>将数据库中添加一个<code>version</code>字段</p><p><img src="http://fl.ljuuu.com/img/20210324094133.png"></p></li><li><p>添加实体类字段</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Version</span></span><br><span class="line"><span class="keyword">private</span> Integer version;</span><br></pre></td></tr></table></figure></li><li><p>新建<code>config</code>包，编写<code>MybatisPlusConfig</code>类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@EnableTransactionManagement</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MybatisPlusConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> OptimisticLockerInterceptor <span class="title">optimisticLockerInterceptor</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> OptimisticLockerInterceptor();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>测试修改成功</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//测试乐观锁</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test3</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//查询用户信息</span></span><br><span class="line">    User user = userMapper.selectById(<span class="number">1L</span>);</span><br><span class="line">    <span class="comment">//修改用户信息</span></span><br><span class="line">    user.setName(<span class="string">&quot;ferron测试&quot;</span>);</span><br><span class="line">    <span class="comment">//执行更新</span></span><br><span class="line">    userMapper.updateById(user);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="http://fl.ljuuu.com/img/20210324094924.png"></p></li><li><p>测试修改实现：乐观锁起作用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//测试乐观锁失败  多线程下</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test4</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//线程1</span></span><br><span class="line">    User user1 = userMapper.selectById(<span class="number">1L</span>);</span><br><span class="line">    user1.setName(<span class="string">&quot;ferron测试1111&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//线程2</span></span><br><span class="line">    User user2 = userMapper.selectById(<span class="number">1L</span>);</span><br><span class="line">    user2.setName(<span class="string">&quot;ferron测试2222&quot;</span>);</span><br><span class="line">    userMapper.updateById(user2);</span><br><span class="line"></span><br><span class="line">    userMapper.updateById(user1);  <span class="comment">//如果没有乐观锁，user1就会覆盖user2的修改</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="http://fl.ljuuu.com/img/20210324095240.png"></p></li><li><p>user1修改失败，可以考虑使用<strong>自旋锁</strong>来尝试多次提交</p></li></ul><h3 id="3-5、查询"><a href="#3-5、查询" class="headerlink" title="3.5、查询"></a>3.5、查询</h3><ul><li><p>按单个id查询</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//查询单个ID</span></span><br><span class="line">User user = userMapper.selectById(<span class="number">1L</span>);</span><br><span class="line">System.out.println(user);</span><br></pre></td></tr></table></figure></li><li><p>按多个id查询</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//查询多个ID</span></span><br><span class="line">List&lt;User&gt; users = userMapper.selectBatchIds(Arrays.asList(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>));</span><br><span class="line">users.forEach(System.out::println);</span><br></pre></td></tr></table></figure></li><li><p>按条件查询</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//条件查询</span></span><br><span class="line"><span class="comment">//new一个查询Map</span></span><br><span class="line">HashMap&lt;String, Object&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"><span class="comment">//添加查询条件</span></span><br><span class="line">map.put(<span class="string">&quot;name&quot;</span>,<span class="string">&quot;ferron&quot;</span>);</span><br><span class="line"><span class="comment">//执行查询</span></span><br><span class="line">List&lt;User&gt; users1 = userMapper.selectByMap(map);</span><br><span class="line">System.out.println(users1);</span><br></pre></td></tr></table></figure></li></ul><h3 id="3-6、分页查询"><a href="#3-6、分页查询" class="headerlink" title="3.6、分页查询"></a>3.6、分页查询</h3><p>原始的分页：原始的limit进行分页</p><p>MybatisPlus分页：</p><ul><li><p>在<code>MybatisPlusConfig</code>中配置分页拦截器插件：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 旧版</span></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> PaginationInterceptor <span class="title">paginationInterceptor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    PaginationInterceptor paginationInterceptor = <span class="keyword">new</span> PaginationInterceptor();</span><br><span class="line">    <span class="keyword">return</span> paginationInterceptor;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>直接使用<code>Page</code>对象即可</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//测试分页</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test6</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//参数一：当前页</span></span><br><span class="line">    <span class="comment">//参数二：页面大小</span></span><br><span class="line">    Page&lt;User&gt; page = <span class="keyword">new</span> Page&lt;&gt;(<span class="number">1</span>,<span class="number">5</span>);</span><br><span class="line">    userMapper.selectPage(page,<span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">    page.getRecords().forEach(System.out::println);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="3-7、删除"><a href="#3-7、删除" class="headerlink" title="3.7、删除"></a>3.7、删除</h3><ul><li><p>根据id删除记录</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i = userMapper.deleteById(<span class="number">1L</span>);</span><br><span class="line">System.out.println(i);</span><br></pre></td></tr></table></figure></li><li><p>根据id批量删除</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i1 = userMapper.deleteBatchIds(Arrays.asList(<span class="number">2</span>, <span class="number">3</span>));</span><br><span class="line">System.out.println(i1);</span><br></pre></td></tr></table></figure></li><li><p>根据条件删除</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">HashMap&lt;String, Object&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">map.put(<span class="string">&quot;name&quot;</span>,<span class="string">&quot;ferron&quot;</span>);</span><br><span class="line">userMapper.deleteByMap(map);</span><br></pre></td></tr></table></figure></li></ul><h3 id="3-8、逻辑删除"><a href="#3-8、逻辑删除" class="headerlink" title="3.8、逻辑删除"></a>3.8、逻辑删除</h3><p>物理删除：从数据库中直接移除</p><p>逻辑删除：在数据库中没有被移除，而是通过一个变量来让他失效！delete=0 =&gt;delete=1</p><p>逻辑删除就相当于一个回收站，网站管理员可以看到被删除的数据！</p><ul><li><p>新增数据库字段</p><p><img src="http://fl.ljuuu.com/img/20210324101615.png"></p></li><li><p>在实体类中添加字段</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@TableLogic</span> <span class="comment">//逻辑删除</span></span><br><span class="line"><span class="keyword">private</span> Integer deleted;</span><br></pre></td></tr></table></figure></li><li><p>在<code>MybatisPlusConfig</code>中配置</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//逻辑删除配置</span></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ISqlInjector <span class="title">sqlInjector</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> LogicSqlInjector();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>在yml文件中添加配置</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">mybatis-plus:</span></span><br><span class="line">  <span class="attr">global-config:</span></span><br><span class="line">    <span class="attr">db-config:</span></span><br><span class="line">      <span class="attr">logic-delete-field:</span> <span class="string">flag</span>  <span class="comment"># 全局逻辑删除的实体字段名(since 3.3.0,配置后可以忽略不配置步骤2)</span></span><br><span class="line">      <span class="attr">logic-delete-value:</span> <span class="number">1</span> <span class="comment"># 逻辑已删除值(默认为 1)</span></span><br><span class="line">      <span class="attr">logic-not-delete-value:</span> <span class="number">0</span> <span class="comment"># 逻辑未删除值(默认为 0)</span></span><br></pre></td></tr></table></figure></li><li><p>测试<strong>逻辑删除</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">/测试逻辑删除</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">test7</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = userMapper.deleteById(<span class="number">4L</span>);</span><br><span class="line">    System.out.println(i);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>注意：<strong>逻辑删除本质是更新操作</strong></p><p><img src="http://fl.ljuuu.com/img/20210324102115.png"></p><p><img src="http://fl.ljuuu.com/img/20210324102151.png"></p></li><li><p>再去查询操作：发现查不到4号用户，deleted属性会被自动拼接上</p><p><img src="http://fl.ljuuu.com/img/20210324102335.png"></p></li></ul><h3 id="3-9、配置日志"><a href="#3-9、配置日志" class="headerlink" title="3.9、配置日志"></a>3.9、配置日志</h3><p>使用了mybatisplus之后，我们所有的SQL语句都不可见，我们需要输出日志</p><ul><li><p>在yml文件中配置日志输出，将其输出在控制台</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">mybatis-plus:</span></span><br><span class="line">  <span class="attr">configuration:</span></span><br><span class="line">    <span class="attr">log-impl:</span> <span class="string">org.apache.ibatis.logging.stdout.StdOutImpl</span></span><br></pre></td></tr></table></figure></li><li><p>测试</p><p><img src="http://fl.ljuuu.com/img/20210324090326.png"></p></li></ul><h2 id="4、MybatisPlus进阶"><a href="#4、MybatisPlus进阶" class="headerlink" title="4、MybatisPlus进阶"></a>4、MybatisPlus进阶</h2><h3 id="4-1、性能分析插件"><a href="#4-1、性能分析插件" class="headerlink" title="4.1、性能分析插件"></a>4.1、性能分析插件</h3><p>我们在平时的开发中，会遇到一些慢sql，MybatisPlus提供了性能分析插件，如果超过一个时间就停止运行</p><ul><li><p>在<code>MybatisPlusConfig</code>中配置</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//性能分析工具</span></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="meta">@Profile(&#123;&quot;dev&quot;,&quot;test&quot;&#125;)</span>  <span class="comment">//在开发环境和测试环境使用，提高效率</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> PerformanceInterceptor <span class="title">performanceInterceptor</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    PerformanceInterceptor performanceInterceptor = <span class="keyword">new</span> PerformanceInterceptor();</span><br><span class="line">    performanceInterceptor.setMaxTime(<span class="number">100</span>);  <span class="comment">//毫秒级别  设置sql查询最大时间</span></span><br><span class="line">    performanceInterceptor.setFormat(<span class="keyword">true</span>);  <span class="comment">//设置sql格式化</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> performanceInterceptor();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>在yml中设置为开发环境</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">profiles:</span></span><br><span class="line">    <span class="attr">active:</span> <span class="string">dev</span></span><br></pre></td></tr></table></figure></li><li><p>测试查询：只要超过了限制时间，就会报异常</p></li></ul><h3 id="4-2、条件查询器Wrapper"><a href="#4-2、条件查询器Wrapper" class="headerlink" title="4.2、条件查询器Wrapper"></a>4.2、条件查询器Wrapper</h3><p><strong>十分重要：Wrapper</strong></p><p>我们如果要使用一些复制的sql就可以使用条件构造器</p><ul><li><p>查询name不为空的用户，并且邮箱不为空的用户，年龄大于等于12</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//查询name不为空的用户，并且邮箱不为空的用户，年龄大于等于12</span></span><br><span class="line">    QueryWrapper&lt;User&gt; wrapper = <span class="keyword">new</span> QueryWrapper&lt;&gt;();</span><br><span class="line">    wrapper</span><br><span class="line">        .isNotNull(<span class="string">&quot;name&quot;</span>)</span><br><span class="line">        .isNotNull(<span class="string">&quot;email&quot;</span>)</span><br><span class="line">        .ge(<span class="string">&quot;age&quot;</span>,<span class="number">12</span>);</span><br><span class="line">    userMapper.selectList(wrapper).forEach(System.out::println);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>查询特定的一个用户，多个用户会模糊</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//查询名字为Ferron超级无敌的用户</span></span><br><span class="line">    QueryWrapper&lt;User&gt; wrapper = <span class="keyword">new</span> QueryWrapper&lt;&gt;();</span><br><span class="line">    wrapper.eq(<span class="string">&quot;name&quot;</span>,<span class="string">&quot;Ferron超级无敌的用户&quot;</span>);</span><br><span class="line">    User user = userMapper.selectOne(wrapper);</span><br><span class="line">    System.out.println(user);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>查询age在20-30的用户的用户个数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test3</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//查询age在20-30的用户的用户个数</span></span><br><span class="line">    QueryWrapper&lt;User&gt; wrapper = <span class="keyword">new</span> QueryWrapper&lt;&gt;();</span><br><span class="line">    wrapper</span><br><span class="line">        .between(<span class="string">&quot;age&quot;</span>,<span class="number">20</span>,<span class="number">30</span>);</span><br><span class="line">    Integer integer = userMapper.selectCount(wrapper);</span><br><span class="line">    System.out.println(integer);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>模糊查询</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test4</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//模糊查询</span></span><br><span class="line">    QueryWrapper&lt;User&gt; wrapper = <span class="keyword">new</span> QueryWrapper&lt;&gt;();</span><br><span class="line">    <span class="comment">//左和右 %e%</span></span><br><span class="line">    wrapper.notLike(<span class="string">&quot;name&quot;</span>,<span class="string">&quot;e&quot;</span>)</span><br><span class="line">        .likeRight(<span class="string">&quot;email&quot;</span>,<span class="string">&quot;t&quot;</span>);</span><br><span class="line"></span><br><span class="line">    List&lt;Map&lt;String, Object&gt;&gt; maps = userMapper.selectMaps(wrapper);</span><br><span class="line">    maps.forEach(System.out::println);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="http://fl.ljuuu.com/img/20210324104753.png"></p></li><li><p>内查询</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test5</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//内查询</span></span><br><span class="line">    QueryWrapper&lt;User&gt; wrapper = <span class="keyword">new</span> QueryWrapper&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//id在子查询中查询出来</span></span><br><span class="line">    wrapper.inSql(<span class="string">&quot;id&quot;</span>,<span class="string">&quot;select id from user where id&gt;3&quot;</span>);</span><br><span class="line"></span><br><span class="line">    List&lt;Object&gt; objects = userMapper.selectObjs(wrapper);</span><br><span class="line">    objects.forEach(System.out::println);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="http://fl.ljuuu.com/img/20210324105125.png"></p></li><li><p>通过id降序排序</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test6</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//通过id降序排序</span></span><br><span class="line">    QueryWrapper&lt;User&gt; wrapper = <span class="keyword">new</span> QueryWrapper&lt;&gt;();</span><br><span class="line">    wrapper.orderByDesc(<span class="string">&quot;id&quot;</span>);</span><br><span class="line"></span><br><span class="line">    List&lt;User&gt; users = userMapper.selectList(wrapper);</span><br><span class="line">    users.forEach(System.out::println);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="http://fl.ljuuu.com/img/20210324105314.png"></p></li></ul><h3 id="4-3、代码自动生成器-牛逼"><a href="#4-3、代码自动生成器-牛逼" class="headerlink" title="4.3、代码自动生成器(牛逼)"></a>4.3、代码自动生成器(牛逼)</h3><p><strong>AutoGenerator 是 MyBatis-Plus 的代码生成器，通过 AutoGenerator 可以快速生成 Entity、Mapper、Mapper XML、Service、Controller 等各个模块的代码，极大的提升了开发效率。</strong></p><p>测试：</p><ul><li><p>在test目录下新建一个代码生成类<code>FerronCode</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FerronCode</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//需要构建一个代码自动生成器 对象</span></span><br><span class="line">        AutoGenerator mpg = <span class="keyword">new</span> AutoGenerator();</span><br><span class="line">        <span class="comment">//配置策略</span></span><br><span class="line">        <span class="comment">//1.全局配置</span></span><br><span class="line">        GlobalConfig gc = <span class="keyword">new</span> GlobalConfig();</span><br><span class="line">        String propertyPath = System.getProperty(<span class="string">&quot;user.dir&quot;</span>);</span><br><span class="line">        gc.setOutputDir(propertyPath+<span class="string">&quot;/src/main/java&quot;</span>);  <span class="comment">//设置生成代码的路径</span></span><br><span class="line">        gc.setAuthor(<span class="string">&quot;Ferron&quot;</span>);</span><br><span class="line">        gc.setOpen(<span class="keyword">false</span>);  <span class="comment">//打开资源管理器</span></span><br><span class="line">        gc.setFileOverride(<span class="keyword">false</span>);  <span class="comment">//是否覆盖原来的代码</span></span><br><span class="line">        gc.setServiceImplName(<span class="string">&quot;%sService&quot;</span>);  <span class="comment">//去掉Service的I前缀</span></span><br><span class="line">        gc.setIdType(IdType.ID_WORKER);  <span class="comment">//设置id策略</span></span><br><span class="line">        gc.setDateType(DateType.ONLY_DATE);</span><br><span class="line">        gc.setSwagger2(<span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">        mpg.setGlobalConfig(gc);  <span class="comment">//添加全局配置</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//2.设置数据源</span></span><br><span class="line">        DataSourceConfig dsc = <span class="keyword">new</span> DataSourceConfig();</span><br><span class="line">        dsc.setUrl(<span class="string">&quot;jdbc:mysql://localhost:3306/db01?useSSL=false&amp;useUnicode=true&amp;characterEncoding=UTF-8&amp;serverTimezone=UTC&quot;</span>);</span><br><span class="line">        dsc.setDriverName(<span class="string">&quot;com.mysql.jdbc.Driver&quot;</span>);</span><br><span class="line">        dsc.setUsername(<span class="string">&quot;root&quot;</span>);</span><br><span class="line">        dsc.setPassword(<span class="string">&quot;sanfashi&quot;</span>);</span><br><span class="line">        dsc.setDbType(DbType.MYSQL);  <span class="comment">//数据库</span></span><br><span class="line">        mpg.setDataSource(dsc);  <span class="comment">//设置数据源</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//3.包的配置</span></span><br><span class="line">        PackageConfig pc = <span class="keyword">new</span> PackageConfig();</span><br><span class="line">        pc.setModuleName(<span class="string">&quot;blog&quot;</span>);</span><br><span class="line">        pc.setParent(<span class="string">&quot;com.ferron&quot;</span>);</span><br><span class="line">        pc.setEntity(<span class="string">&quot;pojo&quot;</span>);</span><br><span class="line">        pc.setMapper(<span class="string">&quot;mapper&quot;</span>);</span><br><span class="line">        pc.setService(<span class="string">&quot;service&quot;</span>);</span><br><span class="line">        pc.setController(<span class="string">&quot;controller&quot;</span>);</span><br><span class="line">        mpg.setPackageInfo(pc);  <span class="comment">//设置包的配置</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4.策略配置</span></span><br><span class="line">        StrategyConfig strategy = <span class="keyword">new</span> StrategyConfig();</span><br><span class="line">        strategy.setInclude(<span class="string">&quot;user&quot;</span>);  <span class="comment">//设置要映射的表名</span></span><br><span class="line">        strategy.setNaming(NamingStrategy.underline_to_camel);</span><br><span class="line">        strategy.setColumnNaming(NamingStrategy.underline_to_camel);</span><br><span class="line">        strategy.setSuperEntityClass(<span class="string">&quot;你自己的父类实体,没有就不用设置!&quot;</span>);</span><br><span class="line">        strategy.setEntityLombokModel(<span class="keyword">true</span>);</span><br><span class="line">        strategy.setRestControllerStyle(<span class="keyword">true</span>);</span><br><span class="line">        <span class="comment">//逻辑删除的字段</span></span><br><span class="line">        strategy.setLogicDeleteFieldName(<span class="string">&quot;deleted&quot;</span>);</span><br><span class="line">        <span class="comment">//自动填充配置</span></span><br><span class="line">        TableFill gmtCreate = <span class="keyword">new</span> TableFill(<span class="string">&quot;gmt_create&quot;</span>, FieldFill.INSERT);</span><br><span class="line">        TableFill gmtModified = <span class="keyword">new</span> TableFill(<span class="string">&quot;gmt_modified&quot;</span>, FieldFill.INSERT_UPDATE);</span><br><span class="line">        ArrayList&lt;TableFill&gt; tableFills = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        tableFills.add(gmtCreate);</span><br><span class="line">        tableFills.add(gmtModified);</span><br><span class="line">        strategy.setTableFillList(tableFills);</span><br><span class="line">        <span class="comment">//乐观锁</span></span><br><span class="line">        strategy.setVersionFieldName(<span class="string">&quot;version&quot;</span>);</span><br><span class="line"></span><br><span class="line">        mpg.setStrategy(strategy);  <span class="comment">//设置策略</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">//执行</span></span><br><span class="line">        mpg.execute();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>这代码可以生成<code>user</code>表的对应包，如果需要生成别的表，<strong>就改一下<code>strategy.setInclude(&quot;user&quot;)</code>的表名就行</strong>，参数也可以传List</p></li></ul>]]></content:encoded>
      
      
      <category domain="http://zhuferron.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">学习笔记</category>
      
      
      <category domain="http://zhuferron.github.io/tags/MybatisPlus/">MybatisPlus</category>
      
      
      <comments>http://zhuferron.github.io/2021/03/24/MybatisPlus%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>数据结构与算法学习笔记(一)：排序算法(一)</title>
      <link>http://zhuferron.github.io/2021/03/18/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(%E4%B8%80)%EF%BC%9A%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95(%E4%B8%80)/</link>
      <guid>http://zhuferron.github.io/2021/03/18/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(%E4%B8%80)%EF%BC%9A%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95(%E4%B8%80)/</guid>
      <pubDate>Thu, 18 Mar 2021 09:57:57 GMT</pubDate>
      
      <description>这是学习数据结构与算法笔记的第一部分，主要介绍了冒泡，选择，插入和希尔排序这四种排序算法</description>
      
      
      
      <content:encoded><![CDATA[<h2 id="1、冒泡排序"><a href="#1、冒泡排序" class="headerlink" title="1、冒泡排序"></a>1、冒泡排序</h2><h3 id="1-1、算法"><a href="#1-1、算法" class="headerlink" title="1.1、算法"></a>1.1、算法</h3><ol><li>比较待排序序列中两个相邻的元素，前者比后者大则交换</li><li>对于j=i，对j与j+1的元素进行步骤一</li><li>i=0 -&gt; i=N-1</li></ol><h3 id="1-2、性质"><a href="#1-2、性质" class="headerlink" title="1.2、性质"></a>1.2、性质</h3><ul><li>当a[j]=a[j+1]时，冒泡排序不进行交换，因此冒泡排序是<strong>稳定</strong>的</li><li>冒泡排序的平均时间复杂度为o(n^2)，最坏时间复杂度为o(n^2)，最好时间复杂度为o(n)</li></ul><h3 id="1-3、代码实现"><a href="#1-3、代码实现" class="headerlink" title="1.3、代码实现"></a>1.3、代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//比较函数，下同</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">less</span><span class="params">(Comparable v, Comparable w)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> v.compareTo(w) &lt; <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//交换函数，下同</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">exchange</span><span class="params">(Comparable v, Comparable w)</span></span>&#123;</span><br><span class="line">    Comparable temp = v;</span><br><span class="line">    v = w;</span><br><span class="line">    w = temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//冒泡排序</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">bubblesort</span><span class="params">(Comparable[] a)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;a.length; i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=i+<span class="number">1</span>; j&lt;a.length; j++)&#123;  </span><br><span class="line">            <span class="keyword">if</span>(less(a[j+<span class="number">1</span>], a[j]))&#123;</span><br><span class="line">                exchange(a[j], a[j+<span class="number">1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2、选择排序"><a href="#2、选择排序" class="headerlink" title="2、选择排序"></a>2、选择排序</h2><h3 id="2-1、算法"><a href="#2-1、算法" class="headerlink" title="2.1、算法"></a>2.1、算法</h3><ol><li>初始i=0，无序区为[i, N]，有序区为空</li><li>将[i, N]中的最小的元素a[min]取出，并且将a[i]与a[min]交换，此时有序区为[0, i]</li><li>i=0 -&gt; i=N-1</li></ol><h3 id="2-2、性质"><a href="#2-2、性质" class="headerlink" title="2.2、性质"></a>2.2、性质</h3><ul><li>因为选择排序可能将较前面的相等元素交换到后面，所以选择排序是<strong>不稳定</strong>的</li><li>选择排序的平均时间复杂度为o(n^2)，最坏时间复杂度为o(n^2)，最好时间复杂度为o(n^2)</li></ul><h3 id="2-3、代码实现"><a href="#2-3、代码实现" class="headerlink" title="2.3、代码实现"></a>2.3、代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//选择排序</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">selectsort</span><span class="params">(Comparable[] a)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;a.length; i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> min=i;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=i+<span class="number">1</span>; j&lt;a.length; j++)&#123;  <span class="comment">//j=i+1是因为初始min为i，第一次比较是j=i+1与i的比较</span></span><br><span class="line">            <span class="keyword">if</span>(less(a[j], a[min]))&#123;</span><br><span class="line">                min=j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        exchange(a[i],a[min]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3、插入排序"><a href="#3、插入排序" class="headerlink" title="3、插入排序"></a>3、插入排序</h2><h3 id="3-1、算法"><a href="#3-1、算法" class="headerlink" title="3.1、算法"></a>3.1、算法</h3><ol><li>初始i=1，无序区为[i, N]，有序区为第一个元素</li><li>将第i+1个元素取出，依次与第i，i-1…1个元素[<strong>有序区的元素</strong>]比较，将其交换到合适的位置</li><li>i=0 -&gt; i=N-1</li></ol><h3 id="3-2、性质"><a href="#3-2、性质" class="headerlink" title="3.2、性质"></a>3.2、性质</h3><ul><li>插入排序交换与冒泡排序类似，都是相邻两个元素交换，因此是<strong>稳定</strong>的</li><li>插入排序的平均时间复杂度为o(n^2)，最坏时间复杂度为o(n^2)，最好时间复杂度为o(n)</li></ul><h3 id="3-3、代码实现"><a href="#3-3、代码实现" class="headerlink" title="3.3、代码实现"></a>3.3、代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//插入排序</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">insertsort</span><span class="params">(Comparable[] a)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;a.length; i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=i+<span class="number">1</span>; j&gt;<span class="number">0</span> &amp;&amp; less(a[j-<span class="number">1</span>],a[j]))&#123; <span class="comment">//停止条件：a[j]到了合适的位置或者a[j]到了需要的最开始</span></span><br><span class="line">            exchange(a[j-<span class="number">1</span>],a[j]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4、希尔排序"><a href="#4、希尔排序" class="headerlink" title="4、希尔排序"></a>4、希尔排序</h2><h3 id="4-1、算法"><a href="#4-1、算法" class="headerlink" title="4.1、算法"></a>4.1、算法</h3><ol><li>选择一组增量序列：t1, t2,…tq,…tk，其中tk=1，这里选择：N/2, N/4,…, 1</li><li>选择增量序列中一个合适的数字开始排序，这里初始以N/2开始</li><li>h=N/2，将原序列变成h组序列，此时每组序列有2个元素，分别对这h组序列执行插入排序的第一，二步</li><li>h=N/2 -&gt; h=1</li></ol><h3 id="4-2、性质"><a href="#4-2、性质" class="headerlink" title="4.2、性质"></a>4.2、性质</h3><ul><li>希尔排序又叫缩小增量排序，因为它会优先比较距离较远的元素，可以说希尔排序是插入排序的改进版</li><li>希尔排序的核心在于间隔序列的设定。既可以提前设定好间隔序列，也可以动态的定义间隔序列比如：h=h/3或h=h/2</li><li>希尔排序最开始有可能进行长距离的交换，因此是<strong>不稳定</strong>的</li><li>希尔排序的平均时间复杂度为o(n^1.3)，最坏时间复杂度为o(n^2)，最好时间复杂度为o(n)</li></ul><h3 id="4-3、代码实现"><a href="#4-3、代码实现" class="headerlink" title="4.3、代码实现"></a>4.3、代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//希尔排序</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">shellsort</span><span class="params">(Comparable[] a)</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(h&gt;=<span class="number">1</span>)&#123; <span class="comment">//希尔排序停止条件</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=h; i&lt;a.length; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=i; j&gt;=h &amp;&amp; less(a[j], a[j-h]), j-=h)&#123;</span><br><span class="line">                exchange(a[j],a[j-h]);</span><br><span class="line">            &#125;</span><br><span class="line">            h/=<span class="number">3</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content:encoded>
      
      
      <category domain="http://zhuferron.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/">数据结构与算法</category>
      
      
      <category domain="http://zhuferron.github.io/tags/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/">排序算法</category>
      
      
      <comments>http://zhuferron.github.io/2021/03/18/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(%E4%B8%80)%EF%BC%9A%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95(%E4%B8%80)/#disqus_thread</comments>
      
    </item>
    
  </channel>
</rss>
