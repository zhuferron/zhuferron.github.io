<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0"
  xmlns:atom="http://www.w3.org/2005/Atom"
  xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>Ferron的个人博客</title>
    <link>http://zhuferron.github.io/</link>
    
    <atom:link href="http://zhuferron.github.io/rss2.xml" rel="self" type="application/rss+xml"/>
    
    <description>何谈三观，褒贬任剪，笑骂随便</description>
    <pubDate>Wed, 31 Mar 2021 09:09:07 GMT</pubDate>
    <generator>http://hexo.io/</generator>
    
    <item>
      <title>剑指offer刷题笔记</title>
      <link>http://zhuferron.github.io/2021/03/28/%E5%89%91%E6%8C%87offer%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0/</link>
      <guid>http://zhuferron.github.io/2021/03/28/%E5%89%91%E6%8C%87offer%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0/</guid>
      <pubDate>Sun, 28 Mar 2021 13:45:29 GMT</pubDate>
      
      <description>这是笔者在牛客网上刷剑指offer的题目的刷题笔记，持续更新!!!</description>
      
      
      
      <content:encoded><![CDATA[<h2 id="1、二维数组中的查找"><a href="#1、二维数组中的查找" class="headerlink" title="1、二维数组中的查找"></a>1、二维数组中的查找</h2><p><strong>题目描述</strong></p><p>在一个二维数组中（每个一维数组的长度相同），每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。</p><p><strong>示例</strong></p><p>输入：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">7,[[1,2,8,9],[2,4,9,12],[4,7,10,13],[6,8,11,15]]</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">true</span><br></pre></td></tr></table></figure><p><strong>思路分析</strong></p><p>因为这个一个排好序的二维数组，查找时考虑使用二分查找。然而由题目可知，这个二维数组的排序有一定规律，按照二分查找的思路就是选定一个mid点，然而进行查找。因此考虑选择二维数组右上方的元素作为mid，如果target等于mid，则找到；如果target大于mid，就说明target不在第一行，此时接着判断第二行和最后一列，循环即可；如歌targte小于mid，就说明target不在最后一列，此时接着判断第一行和倒数第二列，循环即可。</p><p><strong>代码</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">Find</span><span class="params">(<span class="keyword">int</span> target, <span class="keyword">int</span> [][] array)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> j = array[<span class="number">0</span>].length-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">boolean</span> flag = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">while</span>(i&lt;=array.length-<span class="number">1</span> &amp;&amp; j&gt;=<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(target == array[i][j])&#123;</span><br><span class="line">                flag=<span class="keyword">true</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(target &gt; array[i][j])&#123;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                j--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> flag;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2、替换空格"><a href="#2、替换空格" class="headerlink" title="2、替换空格"></a>2、替换空格</h2><p><strong>题目描述</strong></p><p>请实现一个函数，将一个字符串中的每个空格替换成“%20”。</p><p><strong>示例</strong></p><p>输入：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&quot;We Are Happy&quot;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&quot;We%20Are%20Happy&quot;</span><br></pre></td></tr></table></figure><p><strong>思路分析</strong></p><p>题目需要替换字符串，因此考虑使用StringBuffer类来实现。新建一个StringBuffer，遍历原字符串，如果字符为空格，则在sb中添加一个%20，如果字符不为空格，则添加该字符。</p><p><strong>代码</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">replaceSpace</span> <span class="params">(String s)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// write code here</span></span><br><span class="line"></span><br><span class="line">    StringBuffer sb = <span class="keyword">new</span> StringBuffer();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;s.length(); i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(s.charAt(i)==<span class="string">&#x27; &#x27;</span>)&#123;</span><br><span class="line">            sb.append(<span class="string">&quot;%20&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            sb.append(s.charAt(i));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sb.toString();     </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3、从尾到头打印链表"><a href="#3、从尾到头打印链表" class="headerlink" title="3、从尾到头打印链表"></a>3、从尾到头打印链表</h2><p><strong>题目描述</strong></p><p>输入一个链表，按链表从尾到头的顺序返回一个ArrayList。</p><p><strong>示例</strong></p><p>输入：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;67,0,24,58&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[58,24,0,67]</span><br></pre></td></tr></table></figure><p><strong>思路分析</strong></p><p>题目说需要从尾到头打印这个链表，因此考虑使用栈来解决。</p><p><strong>代码</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ArrayList&lt;Integer&gt; <span class="title">printListFromTailToHead</span><span class="params">(ListNode listNode)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">        ArrayList array = <span class="keyword">new</span> ArrayList();</span><br><span class="line">        Stack&lt;Integer&gt; stack = <span class="keyword">new</span> Stack&lt;Integer&gt;();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(ListNode node=listNode; node!=<span class="keyword">null</span>; node=node.next)&#123;</span><br><span class="line">            stack.push(node.val);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(!stack.isEmpty())&#123;</span><br><span class="line">            array.add(stack.pop());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> array;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4、重建二叉树"><a href="#4、重建二叉树" class="headerlink" title="4、重建二叉树"></a>4、重建二叉树</h2><p><strong>题目描述</strong></p><p>输入某二叉树的前序遍历和中序遍历的结果，请重建出该二叉树。假设输入的前序遍历和中序遍历的结果中都不含重复的数字。例如输入前序遍历序列{1,2,4,7,3,5,6,8}和中序遍历序列{4,7,2,1,5,3,8,6}，则重建二叉树并返回。</p><p><strong>示例</strong></p><p>输入：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[1,2,3,4,5,6,7],[3,2,4,1,6,5,7]</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;1,2,5,3,4,6,7&#125;</span><br></pre></td></tr></table></figure><p><strong>思路分析</strong></p><p>知道二叉树的前序遍历和中序遍历，可以考虑使用递归来解决。首先通过前序遍历得到该二叉树的root结点，示例中root结点为1。知道root结点后，通过中序遍历知道了root的左子树的前序遍历为<code>[2,3,4]</code>，中序遍历为<code>[3,2,4]</code>，右子树前序遍历为<code>[5,6,7]</code>，<code>[6,5,7]</code>，接着分别对root的左子树和右子树进行同样的递归操作即可。</p><p><strong>代码</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">reConstructBinaryTree</span><span class="params">(<span class="keyword">int</span> [] pre,<span class="keyword">int</span> [] in)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//当前序和中序都为0时，返回null；</span></span><br><span class="line">        <span class="keyword">if</span>(pre.length==<span class="number">0</span> | in.length==<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        TreeNode root = <span class="keyword">new</span> TreeNode(pre[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;in.length; i++)&#123;</span><br><span class="line">            <span class="comment">//从前序遍历中找到中序遍历中的二叉树的根结点</span></span><br><span class="line">            <span class="keyword">if</span>(in[i] == pre[<span class="number">0</span>])&#123;</span><br><span class="line">                root.left=reConstructBinaryTree(Arrays.copyOfRange(pre,<span class="number">1</span>,i+<span class="number">1</span>),Arrays.copyOfRange(in,<span class="number">0</span>,i));</span><br><span class="line">                root.right=reConstructBinaryTree(Arrays.copyOfRange(pre,i+<span class="number">1</span>,pre.length),Arrays.copyOfRange(in,i+<span class="number">1</span>,in.length));</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="5、两个栈来实现一个队列"><a href="#5、两个栈来实现一个队列" class="headerlink" title="5、两个栈来实现一个队列"></a>5、两个栈来实现一个队列</h2><p><strong>题目描述</strong></p><p>用两个栈来实现一个队列，完成队列的Push和Pop操作。 队列中的元素为int类型。</p><p><strong>思路分析</strong></p><p>考虑使用两个栈来实现一个队列，首先考虑的是该队列只进不出，这样就可以直接使用stack1来存储该“队列”的所有元素。一旦考虑到出列的情况，就相当于要把stack1的所有元素先倒置，即把stack1的元素全部装进stack2，这样stack2中的元素就是stack1中所有元素的倒置，这样出列操作就可以通过stack2的pop方法来完成。考虑到这里还不够完整，如果该“队列”需要在出列之后再进列，则应该继续完善进列方法，即把stack2中的元素再push到stack1中，此时为进列模式下的“队列”，此时只需把需要进列的元素push进stack1即可。</p><p><strong>代码</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Stack;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    Stack&lt;Integer&gt; stack1 = <span class="keyword">new</span> Stack&lt;Integer&gt;();</span><br><span class="line">    Stack&lt;Integer&gt; stack2 = <span class="keyword">new</span> Stack&lt;Integer&gt;();</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> node)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(stack1.isEmpty())&#123;</span><br><span class="line">            <span class="keyword">while</span>(!stack2.isEmpty())&#123;</span><br><span class="line">                stack1.push(stack2.pop());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        stack1.push(node);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(stack2.isEmpty())&#123;</span><br><span class="line">            <span class="keyword">while</span>(!stack1.isEmpty())&#123;</span><br><span class="line">                stack2.push(stack1.pop());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> stack2.pop();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="6、旋转数组的最小数字"><a href="#6、旋转数组的最小数字" class="headerlink" title="6、旋转数组的最小数字"></a>6、旋转数组的最小数字</h2><p><strong>题目描述</strong></p><p>把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。<br> 输入一个非递减排序的数组的一个旋转，输出旋转数组的最小元素。<br> NOTE：给出的所有元素都大于0，若数组大小为0，请返回0。</p><p><strong>示例</strong></p><p>输入：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[3,4,5,1,2]</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1</span><br></pre></td></tr></table></figure><p><strong>思路分析</strong></p><p>这题最开始没有思路，网上比较流行的就是使用二分搜索来完成，但是实现的过程也有一些细微的差异，下面列了一个我觉得较为理想的答案。首先mid大于high时，更新左边界值，而当mid小于high时，则更新右边界值，当两者相等时，很难判断，则让high自减1继续判断。</p><p><strong>代码</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minNumberInRotateArray</span><span class="params">(<span class="keyword">int</span> [] array)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(array.length == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> low = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> high = array.length-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(low&lt;high)&#123;</span><br><span class="line">            <span class="keyword">int</span> mid=(low+high)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(array[mid]&gt;array[high])&#123;</span><br><span class="line">                low=mid+<span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(array[mid]==array[high])&#123;</span><br><span class="line">                high=high-<span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                high=mid;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> array[high];    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="7、斐波那契数列"><a href="#7、斐波那契数列" class="headerlink" title="7、斐波那契数列"></a>7、斐波那契数列</h2><p><strong>题目描述</strong></p><p>大家都知道斐波那契数列，现在要求输入一个整数n，请你输出斐波那契数列的第n项（从0开始，第0项为0，第1项是1）。 </p><p><strong>示例</strong></p><p>输入：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">4</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">3</span><br></pre></td></tr></table></figure><p><strong>思路分析</strong></p><p>思路一：递归</p><p>思路二：递归会造成大量的相同的数据，我们可以考虑使用数组来简化存储</p><p>思路三：因此每次递归都只需要用到相邻的两个数，因此可以在思路二的前提下优化存储。</p><p><strong>代码</strong></p><p>思路一：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">Fibonacci</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n==<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(n==<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> Fibonacci(n-<span class="number">1</span>)+Fibonacci(n-<span class="number">2</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>思路二：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">Fibonacci</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] array = <span class="keyword">new</span> <span class="keyword">int</span>[n+<span class="number">5</span>];</span><br><span class="line">        </span><br><span class="line">        array[<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">        array[<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>; i&lt;array.length; i++)&#123;</span><br><span class="line">            array[i]=array[i-<span class="number">1</span>]+array[i-<span class="number">2</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> array[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>思路三：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">Fibonacci</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] array = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">2</span>];</span><br><span class="line">        </span><br><span class="line">        array[<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">        array[<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>; i&lt;=n; i++)&#123;</span><br><span class="line">            array[i%<span class="number">2</span>]=array[(i-<span class="number">1</span>)%<span class="number">2</span>]+array[i%<span class="number">2</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> array[n%<span class="number">2</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="8、跳台阶"><a href="#8、跳台阶" class="headerlink" title="8、跳台阶"></a>8、跳台阶</h2><p><strong>题目描述</strong></p><p>一只青蛙一次可以跳上1级台阶，也可以跳上2级。求该青蛙跳上一个n级的台阶总共有多少种跳法（先后次序不同算不同的结果）。</p><p><strong>思路分析</strong></p><p>思路一：这道题跟前面的斐波那契数列很类似。我们可以用反向思维来理解，假设青蛙跳到第n阶台阶，那么它的上一步会在哪呢？要么在n-1阶台阶，要么在n-2阶台阶，这样我们就可以得到青蛙跳到第n阶台阶的跳法等于青蛙跳到第n-1阶台阶的跳法与跳到第n-2阶台阶的跳法之和。</p><p>思路二：次递归都只需要用到相邻的两个数，因此使用一个长度为2的数组来进行存储每次计算的数。</p><p><strong>代码</strong></p><p>思路一：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">JumpFloor</span><span class="params">(<span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(target==<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(target==<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(target==<span class="number">2</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> JumpFloor(target-<span class="number">1</span>)+JumpFloor(target-<span class="number">2</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>思路二：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">JumpFloor</span><span class="params">(<span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] array = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">2</span>];</span><br><span class="line">        array[<span class="number">0</span>]=<span class="number">1</span>;  <span class="comment">//index=0代表跳上target=1的跳法</span></span><br><span class="line">        array[<span class="number">1</span>]=<span class="number">2</span>;  <span class="comment">//index=1代表跳上target=2的跳法</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>; i&lt;target; i++)&#123;</span><br><span class="line">            array[i%<span class="number">2</span>]=array[(i-<span class="number">1</span>)%<span class="number">2</span>]+array[i%<span class="number">2</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> array[(target-<span class="number">1</span>)%<span class="number">2</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="9、变态跳台阶"><a href="#9、变态跳台阶" class="headerlink" title="9、变态跳台阶"></a>9、变态跳台阶</h2><p><strong>题目描述</strong></p><p>一只青蛙一次可以跳上1级台阶，也可以跳上2级……它也可以跳上n级。求该青蛙跳上一个n级的台阶总共有多少种跳法。</p><p><strong>思路分析</strong></p><p>思路一：这道题跟是跳台阶的拓展，使用数组来存储每次计算的结果即可。比起原来的跳台阶问题，这次跳台阶只需要每次循环加总前面数组的元素即可。</p><p>思路二：f(n)=f(n-1)+f(n-2)……+f(1)；f(n-1)=f(n-2)+f(n-3)……+f(1)；由此可得到f(n)=2f(n-1)，而f(1)等于1，f(2)就等于2，因此f(n)=2的n-1次方。</p><p><strong>代码</strong></p><p>思路一：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">jumpFloorII</span><span class="params">(<span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span>[] array = <span class="keyword">new</span> <span class="keyword">int</span>[target+<span class="number">1</span>];</span><br><span class="line">        array[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">        array[<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>; i&lt;target+<span class="number">1</span>; i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;array.length; j++)&#123;</span><br><span class="line">                count+=array[j];</span><br><span class="line">            &#125;</span><br><span class="line">            array[i]=count;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> array[target];</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>思路二：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">jumpFloorII</span><span class="params">(<span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">int</span>)Math.pow(<span class="number">2</span>,target-<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content:encoded>
      
      
      <category domain="http://zhuferron.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/">数据结构与算法</category>
      
      
      <category domain="http://zhuferron.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/">数据结构与算法</category>
      
      
      <comments>http://zhuferron.github.io/2021/03/28/%E5%89%91%E6%8C%87offer%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>MybatisPlus学习笔记</title>
      <link>http://zhuferron.github.io/2021/03/24/MybatisPlus%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</link>
      <guid>http://zhuferron.github.io/2021/03/24/MybatisPlus%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</guid>
      <pubDate>Wed, 24 Mar 2021 03:59:49 GMT</pubDate>
      
      <description>根据狂神学习MybatisPlus的笔记，本文深入浅出地讲解了MybatisPlus的使用</description>
      
      
      
      <content:encoded><![CDATA[<h2 id="1、MybatisPlus概述"><a href="#1、MybatisPlus概述" class="headerlink" title="1、MybatisPlus概述"></a>1、MybatisPlus概述</h2><h3 id="1-1、简介"><a href="#1-1、简介" class="headerlink" title="1.1、简介"></a>1.1、简介</h3><p>Mybatis本来就是简化JDBC操作的，<a href="https://github.com/baomidou/mybatis-plus">MyBatis-Plus</a><a href="https://github.com/baomidou/mybatis-plus"> </a><a href="https://github.com/baomidou/mybatis-plus"> (opens new window)</a>（简称 MP）是一个 <a href="http://www.mybatis.org/mybatis-3/">MyBatis</a><a href="http://www.mybatis.org/mybatis-3/"> </a><a href="http://www.mybatis.org/mybatis-3/"> (opens new window)</a> 的增强工具，在 MyBatis 的基础上只做增强不做改变，为简化开发、提高效率而生。</p><p>官网：<a href="https://mp.baomidou.com/">https://mp.baomidou.com/</a></p><p><img src="http://fl.ljuuu.com/img/20210324090355.png"></p><h3 id="1-2、特性"><a href="#1-2、特性" class="headerlink" title="1.2、特性"></a>1.2、特性</h3><ul><li><strong>无侵入</strong>：只做增强不做改变，引入它不会对现有工程产生影响，如丝般顺滑</li><li><strong>损耗小</strong>：启动即会自动注入基本 CURD，性能基本无损耗，直接面向对象操作</li><li><strong>强大的 CRUD 操作</strong>：内置通用 Mapper、通用 Service，仅仅通过少量配置即可实现单表大部分 CRUD 操作，更有强大的条件构造器，满足各类使用需求</li><li><strong>支持 Lambda 形式调用</strong>：通过 Lambda 表达式，方便的编写各类查询条件，无需再担心字段写错</li><li><strong>支持主键自动生成</strong>：支持多达 4 种主键策略（内含分布式唯一 ID 生成器 - Sequence），可自由配置，完美解决主键问题</li><li><strong>支持 ActiveRecord 模式</strong>：支持 ActiveRecord 形式调用，实体类只需继承 Model 类即可进行强大的 CRUD 操作</li><li><strong>支持自定义全局通用操作</strong>：支持全局通用方法注入（ Write once, use anywhere ）</li><li><strong>内置代码生成器</strong>：采用代码或者 Maven 插件可快速生成 Mapper 、 Model 、 Service 、 Controller 层代码，支持模板引擎，更有超多自定义配置等您来使用（<strong>自动帮你生成代码</strong>）</li><li><strong>内置分页插件</strong>：基于 MyBatis 物理分页，开发者无需关心具体操作，配置好插件之后，写分页等同于普通 List 查询</li><li><strong>分页插件支持多种数据库</strong>：支持 MySQL、MariaDB、Oracle、DB2、H2、HSQL、SQLite、Postgre、SQLServer 等多种数据库</li><li><strong>内置性能分析插件</strong>：可输出 Sql 语句以及其执行时间，建议开发测试时启用该功能，能快速揪出慢查询</li><li><strong>内置全局拦截插件</strong>：提供全表 delete 、 update 操作智能分析阻断，也可自定义拦截规则，预防误操作</li></ul><h2 id="2、快速入门"><a href="#2、快速入门" class="headerlink" title="2、快速入门"></a>2、快速入门</h2><ul><li><p>创建数据库<code>db01</code>，创建表<code>user</code>：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span> IF <span class="keyword">EXISTS</span> <span class="keyword">user</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="keyword">user</span></span><br><span class="line">(</span><br><span class="line">id <span class="type">BIGINT</span>(<span class="number">20</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;主键ID&#x27;</span>,</span><br><span class="line">name <span class="type">VARCHAR</span>(<span class="number">30</span>) <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;姓名&#x27;</span>,</span><br><span class="line">age <span class="type">INT</span>(<span class="number">11</span>) <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;年龄&#x27;</span>,</span><br><span class="line">email <span class="type">VARCHAR</span>(<span class="number">50</span>) <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;邮箱&#x27;</span>,</span><br><span class="line"><span class="keyword">PRIMARY</span> KEY (id)</span><br><span class="line">);</span><br><span class="line"><span class="comment">--真实开发中，version(乐观锁)、delete(逻辑删除)、gmt_create、gmt_modified</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="keyword">user</span> (id, name, age, email) <span class="keyword">VALUES</span></span><br><span class="line">(<span class="number">1</span>, <span class="string">&#x27;Jone&#x27;</span>, <span class="number">18</span>, <span class="string">&#x27;test1@baomidou.com&#x27;</span>),</span><br><span class="line">(<span class="number">2</span>, <span class="string">&#x27;Jack&#x27;</span>, <span class="number">20</span>, <span class="string">&#x27;test2@baomidou.com&#x27;</span>),</span><br><span class="line">(<span class="number">3</span>, <span class="string">&#x27;Tom&#x27;</span>, <span class="number">28</span>, <span class="string">&#x27;test3@baomidou.com&#x27;</span>),</span><br><span class="line">(<span class="number">4</span>, <span class="string">&#x27;Sandy&#x27;</span>, <span class="number">21</span>, <span class="string">&#x27;test4@baomidou.com&#x27;</span>),</span><br><span class="line">(<span class="number">5</span>, <span class="string">&#x27;Billie&#x27;</span>, <span class="number">24</span>, <span class="string">&#x27;test5@baomidou.com&#x27;</span>);</span><br></pre></td></tr></table></figure></li><li><p>编写springboot项目，导入依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.1.47<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.projectlombok<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>lombok<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.18.12<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- mybatisplus依赖 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.baomidou<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis-plus-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.0.5<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>说明：我们使用mybatisplus可以节省我们大量的代码，尽量不要同时导入mybatis和mybatisplus</p></li><li><p>连接数据库</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">8080</span></span><br><span class="line"></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">datasource:</span></span><br><span class="line">    <span class="attr">driver-class-name:</span> <span class="string">com.mysql.jdbc.Driver</span></span><br><span class="line">    <span class="attr">url:</span> <span class="string">jdbc:mysql://localhost:3306/db01?useSSL=false&amp;useUnicode=true&amp;characterEncoding=UTF-8&amp;serverTimezone=UTC</span></span><br><span class="line">    <span class="attr">username:</span> <span class="string">root</span></span><br><span class="line">    <span class="attr">password:</span> <span class="string">*********</span></span><br></pre></td></tr></table></figure></li><li><p>传统：pojo-dao(连接mybatis、配置mapper.xml)-service-controller</p></li><li><p>使用mybatisplus</p><ul><li><p>dao</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="meta">@NoArgsConstructor</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> Integer age;</span><br><span class="line">    <span class="keyword">private</span> String email;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>mapper：继承<code>BaseMapper</code>类即可，基本的CRUD方法都有了，你如果需要拓展的方法跟往常一样编写即可</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//在对应的Mapper上面集成基本的类BaseMapper</span></span><br><span class="line"><span class="meta">@Repository</span></span><br><span class="line"><span class="meta">@Mapper</span>  <span class="comment">//这里加@Mapper注解，否则就是在主启动类上添加@MapperScan注解</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserMapper</span> <span class="keyword">extends</span> <span class="title">BaseMapper</span>&lt;<span class="title">User</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">//所有的CRUD已经完成</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>测试</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">contextLoads</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//查询全部用户</span></span><br><span class="line">    <span class="comment">//参数是一个Wrapper，条件构造器</span></span><br><span class="line">    List&lt;User&gt; users = userMapper.selectList(<span class="keyword">null</span>);</span><br><span class="line">    users.forEach(System.out::println);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul><h2 id="3、CRUD"><a href="#3、CRUD" class="headerlink" title="3、CRUD"></a>3、CRUD</h2><h3 id="3-1、插入"><a href="#3-1、插入" class="headerlink" title="3.1、插入"></a>3.1、插入</h3><ul><li><p>测试插入</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//插入测试</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span></span>&#123;</span><br><span class="line">    User user = <span class="keyword">new</span> User();</span><br><span class="line">    user.setName(<span class="string">&quot;ferron&quot;</span>);</span><br><span class="line">    user.setAge(<span class="number">20</span>);</span><br><span class="line">    user.setEmail(<span class="string">&quot;2963624004@qq.com&quot;</span>);</span><br><span class="line">    System.out.println(user);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> insert = userMapper.insert(user);  <span class="comment">//会帮我们自动生成id</span></span><br><span class="line">    System.out.println(insert);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>发现我们没有填写id它竟然会自动帮我们生成id！—&gt;<strong>主键生成算法</strong></p></li><li><p>默认策略：全局唯一ID</p><p><img src="http://fl.ljuuu.com/img/20210324090136.png"></p></li><li><p>雪花算法</p><ul><li>分布式唯一id生成算法汇总：<a href="https://blog.csdn.net/cyl101816/article/details/107002852">https://blog.csdn.net/cyl101816/article/details/107002852</a></li><li>snowflake是Twitter开源的分布式ID生成算法，结果是一个long型的ID。其核心思想是：使用41bit作为毫秒数，10bit作为机器的ID（5个bit是数据中心，5个bit的机器ID），12bit作为毫秒内的流水号（意味着每个节点在每毫秒可以产生 4096 个 ID），最后还有一个符号位，永远是0。具体实现的代码可以参看<a href="https://github.com/twitter/snowflake%E3%80%82">https://github.com/twitter/snowflake。</a></li><li>snowflake算法可以根据自身项目的需要进行一定的修改。比如估算未来的数据中心个数，每个数据中心的机器数以及统一毫秒可以能的并发数来调整在算法中所需要的bit数。</li><li>优点：<ul><li>不依赖于数据库，灵活方便，且性能优于数据库。</li><li>ID按照时间在单机上是递增的。</li></ul></li><li>缺点：<ul><li>在单机上是递增的，但是由于涉及到分布式环境，每台机器上的时钟不可能完全同步，也许有时候也会出现不是全局递增的情况。</li></ul></li></ul></li><li><p>主键自增：</p><ul><li>实体类字段上增加<code>@TableId(type = IdType.AUTO)</code></li><li>数据字段一定要是自增的</li></ul></li><li><p>其他的主键生成策略源代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">enum</span> <span class="title">IdType</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 数据库ID自增</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    AUTO(<span class="number">0</span>),</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 该类型为未设置主键类型</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    NONE(<span class="number">1</span>),</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 用户输入ID</span></span><br><span class="line"><span class="comment">     * 该类型可以通过自己注册自动填充插件进行填充</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    INPUT(<span class="number">2</span>),</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 以下3种类型、只有当插入对象ID 为空，才自动填充。 */</span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 全局唯一ID (idWorker)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    ID_WORKER(<span class="number">3</span>),</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 全局唯一ID (UUID)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    UUID(<span class="number">4</span>),</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 字符串全局唯一ID (idWorker 的字符串表示)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    ID_WORKER_STR(<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> key;</span><br><span class="line"></span><br><span class="line">    IdType(<span class="keyword">int</span> key) &#123;</span><br><span class="line">        <span class="keyword">this</span>.key = key;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="3-2、更新"><a href="#3-2、更新" class="headerlink" title="3.2、更新"></a>3.2、更新</h3><ul><li><p>测试更新</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//更新测试</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span></span>&#123;</span><br><span class="line">    User user = <span class="keyword">new</span> User();</span><br><span class="line">    user.setId(<span class="number">1L</span>);</span><br><span class="line">    user.setEmail(<span class="string">&quot;2963624004@qq.com&quot;</span>);</span><br><span class="line">    System.out.println(user);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> i = userMapper.updateById(user);</span><br><span class="line">    System.out.println(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>探索：发现了我们使用id来更新，想修改什么就创建好对象之后传什么就行了，mybatisplus会帮我们自动使用<strong>动态SQL</strong></p><p><img src="http://fl.ljuuu.com/img/20210324091342.png"></p></li></ul><h3 id="3-3、自动填充"><a href="#3-3、自动填充" class="headerlink" title="3.3、自动填充"></a>3.3、自动填充</h3><p>创建时间、修改时间！这些操作一般都是自动化完成的，我们不希望手动更新</p><p>阿里巴巴开发手册：所有的数据库表都需要有<code>gmt_create</code>和<code>gmt_modified</code>这两个字段，而且需要自动化实现！</p><ul><li><p>方式一：数据库修改(工作中不能使用)</p><ul><li><p>在表中新增字段<code>create_time</code>和<code>update_time</code></p><p><img src="http://fl.ljuuu.com/img/20210324091941.png"></p></li><li><p>同步实体类：使用驼峰命名</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="meta">@NoArgsConstructor</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line">    <span class="keyword">private</span> String email;</span><br><span class="line">    <span class="keyword">private</span> Date createTime;</span><br><span class="line">    <span class="keyword">private</span> Date updateTime;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>再次更新测试</p></li></ul></li><li><p>方式二：代码修改</p><ul><li><p>恢复开始的修改，数据库只添加字段，不修改值等</p><p><img src="http://fl.ljuuu.com/img/20210324092327.png"></p></li><li><p>在实体类的字段上<strong>添加注解</strong>了！</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@TableField(fill = FieldFill.INSERT)</span></span><br><span class="line"><span class="keyword">private</span> Date createTime;</span><br><span class="line"><span class="meta">@TableField(fill = FieldFill.INSERT_UPDATE)</span></span><br><span class="line"><span class="keyword">private</span> Date updateTime;</span><br></pre></td></tr></table></figure></li><li><p>新建<code>handler</code>包，编写对应的处理器来处理注解</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@Component</span>  <span class="comment">//一定不要忘记把处理器加到IOC容器中</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyMetaObjectHandler</span> <span class="keyword">implements</span> <span class="title">MetaObjectHandler</span> </span>&#123;</span><br><span class="line">    <span class="comment">//插入时候的填充策略</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insertFill</span><span class="params">(MetaObject metaObject)</span> </span>&#123;</span><br><span class="line">        log.info(<span class="string">&quot;start insert fill......&quot;</span>);</span><br><span class="line">        <span class="comment">//String fieldName, Object fieldVal, MetaObject metaObject</span></span><br><span class="line">        <span class="keyword">this</span>.setFieldValByName(<span class="string">&quot;createTime&quot;</span>,<span class="keyword">new</span> Date(),metaObject);</span><br><span class="line">        <span class="keyword">this</span>.setFieldValByName(<span class="string">&quot;updateTime&quot;</span>,<span class="keyword">new</span> Date(),metaObject);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//填充时候的填充策略</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">updateFill</span><span class="params">(MetaObject metaObject)</span> </span>&#123;</span><br><span class="line">        log.info(<span class="string">&quot;start update fill......&quot;</span>);</span><br><span class="line">        <span class="keyword">this</span>.setFieldValByName(<span class="string">&quot;updateTime&quot;</span>,<span class="keyword">new</span> Date(),metaObject);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>测试插入</p><p><img src="http://fl.ljuuu.com/img/20210324093255.png"></p></li><li><p>测试更新</p><p><img src="http://fl.ljuuu.com/img/20210324093358.png"></p></li></ul></li></ul><h3 id="3-4、乐观锁"><a href="#3-4、乐观锁" class="headerlink" title="3.4、乐观锁"></a>3.4、乐观锁</h3><p>在面试过程中，我们经常会被遇到乐观锁和悲观锁。</p><p><strong>乐观锁</strong>：它总是会认为不会出现问题，无论干什么都不会上锁，如果出现了问题，再次更新值测试(<strong>version</strong>)</p><p><strong>悲观锁</strong>：它认为怎么都会出现问题，无论干嘛都会上锁，再去操作！</p><p>乐观锁实现方式：</p><ul><li>取出记录时，获取当前version</li><li>更新时，带上这个version</li><li>执行更新时， set version = newVersion where version = oldVersion</li><li>如果version不对，就更新失败</li></ul><p><strong>测试</strong>：</p><ul><li><p>将数据库中添加一个<code>version</code>字段</p><p><img src="http://fl.ljuuu.com/img/20210324094133.png"></p></li><li><p>添加实体类字段</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Version</span></span><br><span class="line"><span class="keyword">private</span> Integer version;</span><br></pre></td></tr></table></figure></li><li><p>新建<code>config</code>包，编写<code>MybatisPlusConfig</code>类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@EnableTransactionManagement</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MybatisPlusConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> OptimisticLockerInterceptor <span class="title">optimisticLockerInterceptor</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> OptimisticLockerInterceptor();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>测试修改成功</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//测试乐观锁</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test3</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//查询用户信息</span></span><br><span class="line">    User user = userMapper.selectById(<span class="number">1L</span>);</span><br><span class="line">    <span class="comment">//修改用户信息</span></span><br><span class="line">    user.setName(<span class="string">&quot;ferron测试&quot;</span>);</span><br><span class="line">    <span class="comment">//执行更新</span></span><br><span class="line">    userMapper.updateById(user);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="http://fl.ljuuu.com/img/20210324094924.png"></p></li><li><p>测试修改实现：乐观锁起作用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//测试乐观锁失败  多线程下</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test4</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//线程1</span></span><br><span class="line">    User user1 = userMapper.selectById(<span class="number">1L</span>);</span><br><span class="line">    user1.setName(<span class="string">&quot;ferron测试1111&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//线程2</span></span><br><span class="line">    User user2 = userMapper.selectById(<span class="number">1L</span>);</span><br><span class="line">    user2.setName(<span class="string">&quot;ferron测试2222&quot;</span>);</span><br><span class="line">    userMapper.updateById(user2);</span><br><span class="line"></span><br><span class="line">    userMapper.updateById(user1);  <span class="comment">//如果没有乐观锁，user1就会覆盖user2的修改</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="http://fl.ljuuu.com/img/20210324095240.png"></p></li><li><p>user1修改失败，可以考虑使用<strong>自旋锁</strong>来尝试多次提交</p></li></ul><h3 id="3-5、查询"><a href="#3-5、查询" class="headerlink" title="3.5、查询"></a>3.5、查询</h3><ul><li><p>按单个id查询</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//查询单个ID</span></span><br><span class="line">User user = userMapper.selectById(<span class="number">1L</span>);</span><br><span class="line">System.out.println(user);</span><br></pre></td></tr></table></figure></li><li><p>按多个id查询</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//查询多个ID</span></span><br><span class="line">List&lt;User&gt; users = userMapper.selectBatchIds(Arrays.asList(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>));</span><br><span class="line">users.forEach(System.out::println);</span><br></pre></td></tr></table></figure></li><li><p>按条件查询</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//条件查询</span></span><br><span class="line"><span class="comment">//new一个查询Map</span></span><br><span class="line">HashMap&lt;String, Object&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"><span class="comment">//添加查询条件</span></span><br><span class="line">map.put(<span class="string">&quot;name&quot;</span>,<span class="string">&quot;ferron&quot;</span>);</span><br><span class="line"><span class="comment">//执行查询</span></span><br><span class="line">List&lt;User&gt; users1 = userMapper.selectByMap(map);</span><br><span class="line">System.out.println(users1);</span><br></pre></td></tr></table></figure></li></ul><h3 id="3-6、分页查询"><a href="#3-6、分页查询" class="headerlink" title="3.6、分页查询"></a>3.6、分页查询</h3><p>原始的分页：原始的limit进行分页</p><p>MybatisPlus分页：</p><ul><li><p>在<code>MybatisPlusConfig</code>中配置分页拦截器插件：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 旧版</span></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> PaginationInterceptor <span class="title">paginationInterceptor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    PaginationInterceptor paginationInterceptor = <span class="keyword">new</span> PaginationInterceptor();</span><br><span class="line">    <span class="keyword">return</span> paginationInterceptor;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>直接使用<code>Page</code>对象即可</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//测试分页</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test6</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//参数一：当前页</span></span><br><span class="line">    <span class="comment">//参数二：页面大小</span></span><br><span class="line">    Page&lt;User&gt; page = <span class="keyword">new</span> Page&lt;&gt;(<span class="number">1</span>,<span class="number">5</span>);</span><br><span class="line">    userMapper.selectPage(page,<span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">    page.getRecords().forEach(System.out::println);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="3-7、删除"><a href="#3-7、删除" class="headerlink" title="3.7、删除"></a>3.7、删除</h3><ul><li><p>根据id删除记录</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i = userMapper.deleteById(<span class="number">1L</span>);</span><br><span class="line">System.out.println(i);</span><br></pre></td></tr></table></figure></li><li><p>根据id批量删除</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i1 = userMapper.deleteBatchIds(Arrays.asList(<span class="number">2</span>, <span class="number">3</span>));</span><br><span class="line">System.out.println(i1);</span><br></pre></td></tr></table></figure></li><li><p>根据条件删除</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">HashMap&lt;String, Object&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">map.put(<span class="string">&quot;name&quot;</span>,<span class="string">&quot;ferron&quot;</span>);</span><br><span class="line">userMapper.deleteByMap(map);</span><br></pre></td></tr></table></figure></li></ul><h3 id="3-8、逻辑删除"><a href="#3-8、逻辑删除" class="headerlink" title="3.8、逻辑删除"></a>3.8、逻辑删除</h3><p>物理删除：从数据库中直接移除</p><p>逻辑删除：在数据库中没有被移除，而是通过一个变量来让他失效！delete=0 =&gt;delete=1</p><p>逻辑删除就相当于一个回收站，网站管理员可以看到被删除的数据！</p><ul><li><p>新增数据库字段</p><p><img src="http://fl.ljuuu.com/img/20210324101615.png"></p></li><li><p>在实体类中添加字段</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@TableLogic</span> <span class="comment">//逻辑删除</span></span><br><span class="line"><span class="keyword">private</span> Integer deleted;</span><br></pre></td></tr></table></figure></li><li><p>在<code>MybatisPlusConfig</code>中配置</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//逻辑删除配置</span></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ISqlInjector <span class="title">sqlInjector</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> LogicSqlInjector();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>在yml文件中添加配置</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">mybatis-plus:</span></span><br><span class="line">  <span class="attr">global-config:</span></span><br><span class="line">    <span class="attr">db-config:</span></span><br><span class="line">      <span class="attr">logic-delete-field:</span> <span class="string">flag</span>  <span class="comment"># 全局逻辑删除的实体字段名(since 3.3.0,配置后可以忽略不配置步骤2)</span></span><br><span class="line">      <span class="attr">logic-delete-value:</span> <span class="number">1</span> <span class="comment"># 逻辑已删除值(默认为 1)</span></span><br><span class="line">      <span class="attr">logic-not-delete-value:</span> <span class="number">0</span> <span class="comment"># 逻辑未删除值(默认为 0)</span></span><br></pre></td></tr></table></figure></li><li><p>测试<strong>逻辑删除</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">/测试逻辑删除</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">test7</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = userMapper.deleteById(<span class="number">4L</span>);</span><br><span class="line">    System.out.println(i);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>注意：<strong>逻辑删除本质是更新操作</strong></p><p><img src="http://fl.ljuuu.com/img/20210324102115.png"></p><p><img src="http://fl.ljuuu.com/img/20210324102151.png"></p></li><li><p>再去查询操作：发现查不到4号用户，deleted属性会被自动拼接上</p><p><img src="http://fl.ljuuu.com/img/20210324102335.png"></p></li></ul><h3 id="3-9、配置日志"><a href="#3-9、配置日志" class="headerlink" title="3.9、配置日志"></a>3.9、配置日志</h3><p>使用了mybatisplus之后，我们所有的SQL语句都不可见，我们需要输出日志</p><ul><li><p>在yml文件中配置日志输出，将其输出在控制台</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">mybatis-plus:</span></span><br><span class="line">  <span class="attr">configuration:</span></span><br><span class="line">    <span class="attr">log-impl:</span> <span class="string">org.apache.ibatis.logging.stdout.StdOutImpl</span></span><br></pre></td></tr></table></figure></li><li><p>测试</p><p><img src="http://fl.ljuuu.com/img/20210324090326.png"></p></li></ul><h2 id="4、MybatisPlus进阶"><a href="#4、MybatisPlus进阶" class="headerlink" title="4、MybatisPlus进阶"></a>4、MybatisPlus进阶</h2><h3 id="4-1、性能分析插件"><a href="#4-1、性能分析插件" class="headerlink" title="4.1、性能分析插件"></a>4.1、性能分析插件</h3><p>我们在平时的开发中，会遇到一些慢sql，MybatisPlus提供了性能分析插件，如果超过一个时间就停止运行</p><ul><li><p>在<code>MybatisPlusConfig</code>中配置</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//性能分析工具</span></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="meta">@Profile(&#123;&quot;dev&quot;,&quot;test&quot;&#125;)</span>  <span class="comment">//在开发环境和测试环境使用，提高效率</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> PerformanceInterceptor <span class="title">performanceInterceptor</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    PerformanceInterceptor performanceInterceptor = <span class="keyword">new</span> PerformanceInterceptor();</span><br><span class="line">    performanceInterceptor.setMaxTime(<span class="number">100</span>);  <span class="comment">//毫秒级别  设置sql查询最大时间</span></span><br><span class="line">    performanceInterceptor.setFormat(<span class="keyword">true</span>);  <span class="comment">//设置sql格式化</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> performanceInterceptor();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>在yml中设置为开发环境</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">profiles:</span></span><br><span class="line">    <span class="attr">active:</span> <span class="string">dev</span></span><br></pre></td></tr></table></figure></li><li><p>测试查询：只要超过了限制时间，就会报异常</p></li></ul><h3 id="4-2、条件查询器Wrapper"><a href="#4-2、条件查询器Wrapper" class="headerlink" title="4.2、条件查询器Wrapper"></a>4.2、条件查询器Wrapper</h3><p><strong>十分重要：Wrapper</strong></p><p>我们如果要使用一些复制的sql就可以使用条件构造器</p><ul><li><p>查询name不为空的用户，并且邮箱不为空的用户，年龄大于等于12</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//查询name不为空的用户，并且邮箱不为空的用户，年龄大于等于12</span></span><br><span class="line">    QueryWrapper&lt;User&gt; wrapper = <span class="keyword">new</span> QueryWrapper&lt;&gt;();</span><br><span class="line">    wrapper</span><br><span class="line">        .isNotNull(<span class="string">&quot;name&quot;</span>)</span><br><span class="line">        .isNotNull(<span class="string">&quot;email&quot;</span>)</span><br><span class="line">        .ge(<span class="string">&quot;age&quot;</span>,<span class="number">12</span>);</span><br><span class="line">    userMapper.selectList(wrapper).forEach(System.out::println);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>查询特定的一个用户，多个用户会模糊</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//查询名字为Ferron超级无敌的用户</span></span><br><span class="line">    QueryWrapper&lt;User&gt; wrapper = <span class="keyword">new</span> QueryWrapper&lt;&gt;();</span><br><span class="line">    wrapper.eq(<span class="string">&quot;name&quot;</span>,<span class="string">&quot;Ferron超级无敌的用户&quot;</span>);</span><br><span class="line">    User user = userMapper.selectOne(wrapper);</span><br><span class="line">    System.out.println(user);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>查询age在20-30的用户的用户个数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test3</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//查询age在20-30的用户的用户个数</span></span><br><span class="line">    QueryWrapper&lt;User&gt; wrapper = <span class="keyword">new</span> QueryWrapper&lt;&gt;();</span><br><span class="line">    wrapper</span><br><span class="line">        .between(<span class="string">&quot;age&quot;</span>,<span class="number">20</span>,<span class="number">30</span>);</span><br><span class="line">    Integer integer = userMapper.selectCount(wrapper);</span><br><span class="line">    System.out.println(integer);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>模糊查询</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test4</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//模糊查询</span></span><br><span class="line">    QueryWrapper&lt;User&gt; wrapper = <span class="keyword">new</span> QueryWrapper&lt;&gt;();</span><br><span class="line">    <span class="comment">//左和右 %e%</span></span><br><span class="line">    wrapper.notLike(<span class="string">&quot;name&quot;</span>,<span class="string">&quot;e&quot;</span>)</span><br><span class="line">        .likeRight(<span class="string">&quot;email&quot;</span>,<span class="string">&quot;t&quot;</span>);</span><br><span class="line"></span><br><span class="line">    List&lt;Map&lt;String, Object&gt;&gt; maps = userMapper.selectMaps(wrapper);</span><br><span class="line">    maps.forEach(System.out::println);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="http://fl.ljuuu.com/img/20210324104753.png"></p></li><li><p>内查询</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test5</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//内查询</span></span><br><span class="line">    QueryWrapper&lt;User&gt; wrapper = <span class="keyword">new</span> QueryWrapper&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//id在子查询中查询出来</span></span><br><span class="line">    wrapper.inSql(<span class="string">&quot;id&quot;</span>,<span class="string">&quot;select id from user where id&gt;3&quot;</span>);</span><br><span class="line"></span><br><span class="line">    List&lt;Object&gt; objects = userMapper.selectObjs(wrapper);</span><br><span class="line">    objects.forEach(System.out::println);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="http://fl.ljuuu.com/img/20210324105125.png"></p></li><li><p>通过id降序排序</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test6</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//通过id降序排序</span></span><br><span class="line">    QueryWrapper&lt;User&gt; wrapper = <span class="keyword">new</span> QueryWrapper&lt;&gt;();</span><br><span class="line">    wrapper.orderByDesc(<span class="string">&quot;id&quot;</span>);</span><br><span class="line"></span><br><span class="line">    List&lt;User&gt; users = userMapper.selectList(wrapper);</span><br><span class="line">    users.forEach(System.out::println);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="http://fl.ljuuu.com/img/20210324105314.png"></p></li></ul><h3 id="4-3、代码自动生成器-牛逼"><a href="#4-3、代码自动生成器-牛逼" class="headerlink" title="4.3、代码自动生成器(牛逼)"></a>4.3、代码自动生成器(牛逼)</h3><p><strong>AutoGenerator 是 MyBatis-Plus 的代码生成器，通过 AutoGenerator 可以快速生成 Entity、Mapper、Mapper XML、Service、Controller 等各个模块的代码，极大的提升了开发效率。</strong></p><p>测试：</p><ul><li><p>在test目录下新建一个代码生成类<code>FerronCode</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FerronCode</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//需要构建一个代码自动生成器 对象</span></span><br><span class="line">        AutoGenerator mpg = <span class="keyword">new</span> AutoGenerator();</span><br><span class="line">        <span class="comment">//配置策略</span></span><br><span class="line">        <span class="comment">//1.全局配置</span></span><br><span class="line">        GlobalConfig gc = <span class="keyword">new</span> GlobalConfig();</span><br><span class="line">        String propertyPath = System.getProperty(<span class="string">&quot;user.dir&quot;</span>);</span><br><span class="line">        gc.setOutputDir(propertyPath+<span class="string">&quot;/src/main/java&quot;</span>);  <span class="comment">//设置生成代码的路径</span></span><br><span class="line">        gc.setAuthor(<span class="string">&quot;Ferron&quot;</span>);</span><br><span class="line">        gc.setOpen(<span class="keyword">false</span>);  <span class="comment">//打开资源管理器</span></span><br><span class="line">        gc.setFileOverride(<span class="keyword">false</span>);  <span class="comment">//是否覆盖原来的代码</span></span><br><span class="line">        gc.setServiceImplName(<span class="string">&quot;%sService&quot;</span>);  <span class="comment">//去掉Service的I前缀</span></span><br><span class="line">        gc.setIdType(IdType.ID_WORKER);  <span class="comment">//设置id策略</span></span><br><span class="line">        gc.setDateType(DateType.ONLY_DATE);</span><br><span class="line">        gc.setSwagger2(<span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">        mpg.setGlobalConfig(gc);  <span class="comment">//添加全局配置</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//2.设置数据源</span></span><br><span class="line">        DataSourceConfig dsc = <span class="keyword">new</span> DataSourceConfig();</span><br><span class="line">        dsc.setUrl(<span class="string">&quot;jdbc:mysql://localhost:3306/db01?useSSL=false&amp;useUnicode=true&amp;characterEncoding=UTF-8&amp;serverTimezone=UTC&quot;</span>);</span><br><span class="line">        dsc.setDriverName(<span class="string">&quot;com.mysql.jdbc.Driver&quot;</span>);</span><br><span class="line">        dsc.setUsername(<span class="string">&quot;root&quot;</span>);</span><br><span class="line">        dsc.setPassword(<span class="string">&quot;sanfashi&quot;</span>);</span><br><span class="line">        dsc.setDbType(DbType.MYSQL);  <span class="comment">//数据库</span></span><br><span class="line">        mpg.setDataSource(dsc);  <span class="comment">//设置数据源</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//3.包的配置</span></span><br><span class="line">        PackageConfig pc = <span class="keyword">new</span> PackageConfig();</span><br><span class="line">        pc.setModuleName(<span class="string">&quot;blog&quot;</span>);</span><br><span class="line">        pc.setParent(<span class="string">&quot;com.ferron&quot;</span>);</span><br><span class="line">        pc.setEntity(<span class="string">&quot;pojo&quot;</span>);</span><br><span class="line">        pc.setMapper(<span class="string">&quot;mapper&quot;</span>);</span><br><span class="line">        pc.setService(<span class="string">&quot;service&quot;</span>);</span><br><span class="line">        pc.setController(<span class="string">&quot;controller&quot;</span>);</span><br><span class="line">        mpg.setPackageInfo(pc);  <span class="comment">//设置包的配置</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4.策略配置</span></span><br><span class="line">        StrategyConfig strategy = <span class="keyword">new</span> StrategyConfig();</span><br><span class="line">        strategy.setInclude(<span class="string">&quot;user&quot;</span>);  <span class="comment">//设置要映射的表名</span></span><br><span class="line">        strategy.setNaming(NamingStrategy.underline_to_camel);</span><br><span class="line">        strategy.setColumnNaming(NamingStrategy.underline_to_camel);</span><br><span class="line">        strategy.setSuperEntityClass(<span class="string">&quot;你自己的父类实体,没有就不用设置!&quot;</span>);</span><br><span class="line">        strategy.setEntityLombokModel(<span class="keyword">true</span>);</span><br><span class="line">        strategy.setRestControllerStyle(<span class="keyword">true</span>);</span><br><span class="line">        <span class="comment">//逻辑删除的字段</span></span><br><span class="line">        strategy.setLogicDeleteFieldName(<span class="string">&quot;deleted&quot;</span>);</span><br><span class="line">        <span class="comment">//自动填充配置</span></span><br><span class="line">        TableFill gmtCreate = <span class="keyword">new</span> TableFill(<span class="string">&quot;gmt_create&quot;</span>, FieldFill.INSERT);</span><br><span class="line">        TableFill gmtModified = <span class="keyword">new</span> TableFill(<span class="string">&quot;gmt_modified&quot;</span>, FieldFill.INSERT_UPDATE);</span><br><span class="line">        ArrayList&lt;TableFill&gt; tableFills = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        tableFills.add(gmtCreate);</span><br><span class="line">        tableFills.add(gmtModified);</span><br><span class="line">        strategy.setTableFillList(tableFills);</span><br><span class="line">        <span class="comment">//乐观锁</span></span><br><span class="line">        strategy.setVersionFieldName(<span class="string">&quot;version&quot;</span>);</span><br><span class="line"></span><br><span class="line">        mpg.setStrategy(strategy);  <span class="comment">//设置策略</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">//执行</span></span><br><span class="line">        mpg.execute();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>这代码可以生成<code>user</code>表的对应包，如果需要生成别的表，<strong>就改一下<code>strategy.setInclude(&quot;user&quot;)</code>的表名就行</strong>，参数也可以传List</p></li></ul>]]></content:encoded>
      
      
      <category domain="http://zhuferron.github.io/categories/%E4%B8%AD%E9%97%B4%E4%BB%B6/">中间件</category>
      
      
      <category domain="http://zhuferron.github.io/tags/MybatisPlus/">MybatisPlus</category>
      
      
      <comments>http://zhuferron.github.io/2021/03/24/MybatisPlus%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>数据结构与算法学习笔记(一)：排序算法(一)</title>
      <link>http://zhuferron.github.io/2021/03/18/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(%E4%B8%80)%EF%BC%9A%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95(%E4%B8%80)/</link>
      <guid>http://zhuferron.github.io/2021/03/18/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(%E4%B8%80)%EF%BC%9A%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95(%E4%B8%80)/</guid>
      <pubDate>Thu, 18 Mar 2021 09:57:57 GMT</pubDate>
      
      <description>这是学习数据结构与算法笔记的第一部分，主要介绍了冒泡，选择，插入和希尔排序这四种排序算法</description>
      
      
      
      <content:encoded><![CDATA[<h2 id="1、冒泡排序"><a href="#1、冒泡排序" class="headerlink" title="1、冒泡排序"></a>1、冒泡排序</h2><h3 id="1-1、算法"><a href="#1-1、算法" class="headerlink" title="1.1、算法"></a>1.1、算法</h3><ol><li>比较待排序序列中两个相邻的元素，前者比后者大则交换</li><li>对于j=i，对j与j+1的元素进行步骤一</li><li>i=0 -&gt; i=N-1</li></ol><h3 id="1-2、性质"><a href="#1-2、性质" class="headerlink" title="1.2、性质"></a>1.2、性质</h3><ul><li>当a[j]=a[j+1]时，冒泡排序不进行交换，因此冒泡排序是<strong>稳定</strong>的</li><li>冒泡排序的平均时间复杂度为o(n^2)，最坏时间复杂度为o(n^2)，最好时间复杂度为o(n)</li></ul><h3 id="1-3、代码实现"><a href="#1-3、代码实现" class="headerlink" title="1.3、代码实现"></a>1.3、代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//比较函数，下同</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">less</span><span class="params">(Comparable v, Comparable w)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> v.compareTo(w) &lt; <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//交换函数，下同</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">exchange</span><span class="params">(Comparable v, Comparable w)</span></span>&#123;</span><br><span class="line">    Comparable temp = v;</span><br><span class="line">    v = w;</span><br><span class="line">    w = temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//冒泡排序</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">bubblesort</span><span class="params">(Comparable[] a)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;a.length; i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=i+<span class="number">1</span>; j&lt;a.length; j++)&#123;  </span><br><span class="line">            <span class="keyword">if</span>(less(a[j+<span class="number">1</span>], a[j]))&#123;</span><br><span class="line">                exchange(a[j], a[j+<span class="number">1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2、选择排序"><a href="#2、选择排序" class="headerlink" title="2、选择排序"></a>2、选择排序</h2><h3 id="2-1、算法"><a href="#2-1、算法" class="headerlink" title="2.1、算法"></a>2.1、算法</h3><ol><li>初始i=0，无序区为[i, N]，有序区为空</li><li>将[i, N]中的最小的元素a[min]取出，并且将a[i]与a[min]交换，此时有序区为[0, i]</li><li>i=0 -&gt; i=N-1</li></ol><h3 id="2-2、性质"><a href="#2-2、性质" class="headerlink" title="2.2、性质"></a>2.2、性质</h3><ul><li>因为选择排序可能将较前面的相等元素交换到后面，所以选择排序是<strong>不稳定</strong>的</li><li>选择排序的平均时间复杂度为o(n^2)，最坏时间复杂度为o(n^2)，最好时间复杂度为o(n^2)</li></ul><h3 id="2-3、代码实现"><a href="#2-3、代码实现" class="headerlink" title="2.3、代码实现"></a>2.3、代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//选择排序</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">selectsort</span><span class="params">(Comparable[] a)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;a.length; i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> min=i;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=i+<span class="number">1</span>; j&lt;a.length; j++)&#123;  <span class="comment">//j=i+1是因为初始min为i，第一次比较是j=i+1与i的比较</span></span><br><span class="line">            <span class="keyword">if</span>(less(a[j], a[min]))&#123;</span><br><span class="line">                min=j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        exchange(a[i],a[min]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3、插入排序"><a href="#3、插入排序" class="headerlink" title="3、插入排序"></a>3、插入排序</h2><h3 id="3-1、算法"><a href="#3-1、算法" class="headerlink" title="3.1、算法"></a>3.1、算法</h3><ol><li>初始i=1，无序区为[i, N]，有序区为第一个元素</li><li>将第i+1个元素取出，依次与第i，i-1…1个元素[<strong>有序区的元素</strong>]比较，将其交换到合适的位置</li><li>i=0 -&gt; i=N-1</li></ol><h3 id="3-2、性质"><a href="#3-2、性质" class="headerlink" title="3.2、性质"></a>3.2、性质</h3><ul><li>插入排序交换与冒泡排序类似，都是相邻两个元素交换，因此是<strong>稳定</strong>的</li><li>插入排序的平均时间复杂度为o(n^2)，最坏时间复杂度为o(n^2)，最好时间复杂度为o(n)</li></ul><h3 id="3-3、代码实现"><a href="#3-3、代码实现" class="headerlink" title="3.3、代码实现"></a>3.3、代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//插入排序</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">insertsort</span><span class="params">(Comparable[] a)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;a.length; i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=i+<span class="number">1</span>; j&gt;<span class="number">0</span> &amp;&amp; less(a[j-<span class="number">1</span>],a[j]))&#123; <span class="comment">//停止条件：a[j]到了合适的位置或者a[j]到了需要的最开始</span></span><br><span class="line">            exchange(a[j-<span class="number">1</span>],a[j]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4、希尔排序"><a href="#4、希尔排序" class="headerlink" title="4、希尔排序"></a>4、希尔排序</h2><h3 id="4-1、算法"><a href="#4-1、算法" class="headerlink" title="4.1、算法"></a>4.1、算法</h3><ol><li>选择一组增量序列：t1, t2,…tq,…tk，其中tk=1，这里选择：N/2, N/4,…, 1</li><li>选择增量序列中一个合适的数字开始排序，这里初始以N/2开始</li><li>h=N/2，将原序列变成h组序列，此时每组序列有2个元素，分别对这h组序列执行插入排序的第一，二步</li><li>h=N/2 -&gt; h=1</li></ol><h3 id="4-2、性质"><a href="#4-2、性质" class="headerlink" title="4.2、性质"></a>4.2、性质</h3><ul><li>希尔排序又叫缩小增量排序，因为它会优先比较距离较远的元素，可以说希尔排序是插入排序的改进版</li><li>希尔排序的核心在于间隔序列的设定。既可以提前设定好间隔序列，也可以动态的定义间隔序列比如：h=h/3或h=h/2</li><li>希尔排序最开始有可能进行长距离的交换，因此是<strong>不稳定</strong>的</li><li>希尔排序的平均时间复杂度为o(n^1.3)，最坏时间复杂度为o(n^2)，最好时间复杂度为o(n)</li></ul><h3 id="4-3、代码实现"><a href="#4-3、代码实现" class="headerlink" title="4.3、代码实现"></a>4.3、代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//希尔排序</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">shellsort</span><span class="params">(Comparable[] a)</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(h&gt;=<span class="number">1</span>)&#123; <span class="comment">//希尔排序停止条件</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=h; i&lt;a.length; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=i; j&gt;=h &amp;&amp; less(a[j], a[j-h]), j-=h)&#123;</span><br><span class="line">                exchange(a[j],a[j-h]);</span><br><span class="line">            &#125;</span><br><span class="line">            h/=<span class="number">3</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content:encoded>
      
      
      <category domain="http://zhuferron.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/">数据结构与算法</category>
      
      
      <category domain="http://zhuferron.github.io/tags/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/">排序算法</category>
      
      
      <comments>http://zhuferron.github.io/2021/03/18/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(%E4%B8%80)%EF%BC%9A%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95(%E4%B8%80)/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>微服务架构及Pig项目分析(二)：SpringCloud微服务技术</title>
      <link>http://zhuferron.github.io/2021/03/17/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84%E4%BB%A5%E5%8F%8APig%E9%A1%B9%E7%9B%AE%E5%88%86%E6%9E%90(%E4%BA%8C)%20/</link>
      <guid>http://zhuferron.github.io/2021/03/17/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84%E4%BB%A5%E5%8F%8APig%E9%A1%B9%E7%9B%AE%E5%88%86%E6%9E%90(%E4%BA%8C)%20/</guid>
      <pubDate>Wed, 17 Mar 2021 00:45:39 GMT</pubDate>
      
      <description>软件体系架构课程论文，这部分主要介绍了微服务存在的问题以及SpringCloud是怎么解决这些问题的</description>
      
      
      
      <content:encoded><![CDATA[<h2 id="2-1、微服务核心问题"><a href="#2-1、微服务核心问题" class="headerlink" title="2.1、微服务核心问题"></a>2.1、微服务核心问题</h2><ol><li><p>微服务架构中有很多服务组件，不同的用户怎么调用不同的服务</p></li><li><p>微服务架构中不同的服务之间怎么进行互相调用</p></li><li><p>微服务架构中怎么对这些不同的服务进行治理</p></li><li><p>微服务架构中某个服务出问题了，怎么解决</p></li></ol><h2 id="2-2、问题一：Zuul-微服务网关"><a href="#2-2、问题一：Zuul-微服务网关" class="headerlink" title="2.2、问题一：Zuul+微服务网关"></a>2.2、问题一：Zuul+微服务网关</h2><p>​    Zuul是Netflix开源的一个API Gateway 服务器,在云平台上提供动态路由，监控，弹性，安全等边缘服务的框架。Zuul相当于是设备和Netflix流应用的Web网站后端所有请求的前门。SpringCloud中集成了Zuul，使用它来解决微服务架构中的问题一。</p><p>​    Zuul的核心便是Servlet中的filter机制的实现，而filter本质上就是一个Servlet，而filter的应用则是Spring中AOP思想的体现，通过在用户在前端与后端通信的过程中增加一个filter，实现动态路由的功能。例如，用户在前端与后端进行交互时，需要一个具体的服务，而后端往往有成百上千个服务，想让前端记住后端服务的名称往往是不现实的，而加入Zuul网关的作用就是，当前端想要调用后端的一个或多个服务时，往往不直接调用，而是统一从Zuul网关调用，Zuul网关将对应的请求转发或重定向到对应的服务。</p><p><img src="http://fl.ljuuu.com/img/20210317083241.png"></p><h2 id="2-3、问题二：Feign-异步调用"><a href="#2-3、问题二：Feign-异步调用" class="headerlink" title="2.3、问题二：Feign+异步调用"></a>2.3、问题二：Feign+异步调用</h2><p>​    Feign是Netflix开发的声明式，模板化的HTTP客户端，其灵感来自Retrofit,JAXRS-2.0以及WebSocket. Feign远程调用的核心就是通过一系列的封装和处理，将以Java注解的方式定义的远程调用API接口，最终转换成HTTP的请求形式，然后将HTTP的请求的响应结果，解码成JavaBean，放回给调用者，其调用过程如下图所示。</p><p><img src="http://fl.ljuuu.com/img/20210317083309.png"></p><p>​    Feign的核心机制就是动态代理，与静态代理不同的是，动态代理的代码不用我们手写，而是可以自动生成。Feign中的动态代理是基于接口的动态代理模式，它是由JDK动态代理的，接口为InvocationHandler，动态代理也是AOP思想的核心。Feign的动态代理会根据你在接口上的@RequestMapping等注解，来动态构造出你要请求的服务的地址最后针对这个地址，发起请求、解析响应。</p><h2 id="2-4、问题三：Eureka-服务注册与发现"><a href="#2-4、问题三：Eureka-服务注册与发现" class="headerlink" title="2.4、问题三：Eureka+服务注册与发现"></a>2.4、问题三：Eureka+服务注册与发现</h2><p>​    Eureka是Netflix开发的服务发现框架，本身是一个基于REST的服务，主要用于定位运行在AWS域中的中间层服务，以达到负载均衡和中间层服务故障转移的目的。SpringCloud将它集成在其子项目spring-cloud-netflix中，以实现SpringCloud的服务发现功能。Eureka中分为eureka server和eureka client。其中eureka server是作为服务的注册与发现中心。eureka client既可以作为服务的生产者，又可以作为服务的消费者。</p><p><img src="http://fl.ljuuu.com/img/20210317083340.png"></p><p>​    其整体架构如上图所示：多个eureka server同步保留着相同的服务信息，作为服务生产者的eureka client需要在eureka server中注册其服务信息，而作为服务消费者的eureka client想要查找一个具体的服务时，首先得去eureka server查找对应服务所对应的eureka client，然后再从对应的eureka client调用对应的服务。</p><h2 id="2-5、问题四：Hystrix-降级"><a href="#2-5、问题四：Hystrix-降级" class="headerlink" title="2.5、问题四：Hystrix+降级"></a>2.5、问题四：Hystrix+降级</h2><p>​    微服务架构的特点就是各个不同的服务分离了，当网站或应用程序有很高的工作量时，就有可能导致部分服务挂了，然而往往不同的服务之间有相互调用，当一个服务挂了，就可能导致其他服务的部分功能也实现不了，这就是服务雪崩效应。</p><p>​    为了避免这种服务雪崩效应，Hystrix提出的一个解决方法就是服务降级。其实现的具体思想就是每个服务发起的请求都通过Hystrix的线程池不同的服务走不同的线程池，实现了不同的服务调度隔离，从而避免服务雪崩的问题。</p>]]></content:encoded>
      
      
      <category domain="http://zhuferron.github.io/categories/%E5%BE%AE%E6%9C%8D%E5%8A%A1/">微服务</category>
      
      
      <category domain="http://zhuferron.github.io/tags/SpringCloud/">SpringCloud</category>
      
      
      <comments>http://zhuferron.github.io/2021/03/17/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84%E4%BB%A5%E5%8F%8APig%E9%A1%B9%E7%9B%AE%E5%88%86%E6%9E%90(%E4%BA%8C)%20/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>微服务架构及Pig项目分析(三)：Pig项目分析</title>
      <link>http://zhuferron.github.io/2021/03/17/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84%E4%BB%A5%E5%8F%8APig%E9%A1%B9%E7%9B%AE%E5%88%86%E6%9E%90(%E4%B8%89)/</link>
      <guid>http://zhuferron.github.io/2021/03/17/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84%E4%BB%A5%E5%8F%8APig%E9%A1%B9%E7%9B%AE%E5%88%86%E6%9E%90(%E4%B8%89)/</guid>
      <pubDate>Wed, 17 Mar 2021 00:39:54 GMT</pubDate>
      
      <description>软件体系架构课程论文，这部分主要对Pig项目分析和源码解读</description>
      
      
      
      <content:encoded><![CDATA[<h2 id="3-1、项目简介"><a href="#3-1、项目简介" class="headerlink" title="3.1、项目简介"></a>3.1、项目简介</h2><p>  本文微服务案例选择的是码云上19.2K star的pig项目，该项目是基于 Spring Cloud Hoxton、Spring Boot 2.4、OAuth2的RBAC权限管理系统。</p><h2 id="3-2、项目技术"><a href="#3-2、项目技术" class="headerlink" title="3.2、项目技术"></a>3.2、项目技术</h2><h3 id="3-2-1、Nacos-服务注册与发现"><a href="#3-2-1、Nacos-服务注册与发现" class="headerlink" title="3.2.1、Nacos 服务注册与发现"></a>3.2.1、Nacos 服务注册与发现</h3><p>​    该项目通过Nacos注册中心来作为协调所有服务，所有服务需要在注册中心进行注册，而一个服务需要调用另外一个服务的时候则先取注册中心查找，然后得到查找结果后再去调用对应的服务。具体过程如下图所示：所有的订单服务都在注册中心中注册，但某一个用户服务需要订单服务时，则去注册中心查找需要的订单服务名字，然后去调用对应的服务。</p><p><img src="http://fl.ljuuu.com/img/20210317083536.png"></p><h3 id="3-2-2、Ribbon负载均衡"><a href="#3-2-2、Ribbon负载均衡" class="headerlink" title="3.2.2、Ribbon负载均衡"></a>3.2.2、Ribbon负载均衡</h3><p>​    Ribbon是Netflix发布的云中间层服务开源项目，其主要功能是提供客户端实现负载均衡算法。负载均衡的调度规则一般为轮询调度或者加权轮询策略，轮询调度算法的原理是每一次把来自用户的请求轮流分配给内部中的服务器，从1开始，直到N(内部服务器个数)，然后重新开始循环。轮询调度算法假设所有服务器的处理性能都相同，不关心每台服务器的当前连接数和响应速度。当请求服务间隔时间变化比较大时，轮询调度算法容易导致服务器间的负载不平衡。所以此种均衡算法适合于服务器组中的所有服务器都有相同的软硬件配置并且平均服务请求相对均衡的情况，因此现实中往往会采用加权轮询策略，而限于本文的篇幅，加权轮询策略原理不再展开。</p><p><img src="http://fl.ljuuu.com/img/20210317083557.png"></p><p>​    在SpringCloud中往往使用Ribbon来实现负载均值，其过程如下图所示：当有一个服务需要调用另外某一个服务时，该服务会向注册中心进行查询，注册中心会返回一个可用的服务实例列表，例如前文的三个订单服务中只有一个订单服务空闲，另外两个订单服务处于高工作量时，用户服务就能得到空闲的订单服务的名称，此时用户服务就可直接调用该空闲的订单服务。</p><p><img src="http://fl.ljuuu.com/img/20210317083609.png"></p><h3 id="3-2-3、GateWay业务网关"><a href="#3-2-3、GateWay业务网关" class="headerlink" title="3.2.3、GateWay业务网关"></a>3.2.3、GateWay业务网关</h3><p>​    面对互联网复杂的业务系统，基本可以将API网关分成两类：流量网关和业务网关。流量网关是指跟具体的后端业务系统和服务完全无关的部分，比如安全策略、全局性流控策略、流量分发策略等。而业务网关针对具体的后端业务系统，或者是服务和业务有一定关联性的部分，并且一般被直接部署在业务服务的前面。业务网关一般部署在流量网关之后，业务系统之前，比流量网关更靠近系统。我们大部分情况下说的 API 网关，狭义上指的是业务网关。并且如果系统的规模不大，我们也会将两者合二为一，使用一个网关来处理所有的工作。</p><p>​    SpringCloud中GateWay作为业务网关的一种，整个作用原理如下图：客户端发送的请求不会直接到服务端，而是首先通过网关系统，如果请求与网关程序定义的路由匹配，则将其发送到网关 Web 处理程序，此处理程序运行特定的请求过滤器链。过滤器之间用虚线分开的原因是过滤器可能会在发送代理请求之前或之后执行逻辑。所有 “pre” 过滤器逻辑先执行，然后执行代理请求，代理请求完成后，执行 “post” 过滤器逻辑。</p><p><img src="http://fl.ljuuu.com/img/20210317083629.png"></p><h3 id="3-2-4、Sentinel-流量保护"><a href="#3-2-4、Sentinel-流量保护" class="headerlink" title="3.2.4、Sentinel 流量保护"></a>3.2.4、Sentinel 流量保护</h3><p>​    Hystrix的产生和原理在前文已经讲述，Sentinel 和 Hystrix 的原则是一致的：当调用链路中某个资源出现不稳定，例如，表现为 timeout，异常比例升高的时候，则对这个资源的调用进行限制，并让请求快速失败，避免影响到其它的资源，最终产生雪崩的效果。但是在限制的手段上，Sentinel 和 Hystrix 采取了完全不一样的方法。Sentinel 对这个问题采取了两种手段：</p><ol><li><p>通过并发线程数进行限制：和资源池隔离的方法不同，Sentinel 通过限制资源并发线程的数量，来减少不稳定资源对其它资源的影响。这样不但没有线程切换的损耗，也不需要您预先分配线程池的大小。当某个资源出现不稳定的情况下，例如响应时间变长，对资源的直接影响就是会造成线程数的逐步堆积。当线程数在特定资源上堆积到一定的数量之后，对该资源的新请求就会被拒绝。堆积的线程完成任务后才开始继续接收请求。</p></li><li><p>通过响应时间对资源进行降级：除了对并发线程数进行控制以外，Sentinel 还可以通过响应时间来快速降级不稳定的资源。当依赖的资源出现响应时间过长后，所有对该资源的访问都会被直接拒绝，直到过了指定的时间窗口之后才重新恢复。</p></li></ol><h2 id="3-3、源码分析"><a href="#3-3、源码分析" class="headerlink" title="3.3、源码分析"></a>3.3、源码分析</h2><h3 id="3-3-1、注册中心源码分析"><a href="#3-3-1、注册中心源码分析" class="headerlink" title="3.3.1、注册中心源码分析"></a>3.3.1、注册中心源码分析</h3><p>​    从码云将pig项目clone到本地之后，使用IDEA打开该项目，SpringBoot项目本质还是一个Maven项目，故将该项目解析成一个Maven项目。</p><p>​    Springcloud-commons包中自动装配了AutoServiceRegistrationAutoConfiguration类，这个类就是与服务注册相关的配置类。如下图所示，找到这个配置类，这个配置类注入了一个AutoServiceRegistration实例。</p><p><img src="http://fl.ljuuu.com/img/20210317083729.png"></p><p>​    分析与AutoServiceRegistration类相关的其他类，发现有个很重要的AbstractAutoServiceRegistration抽象类实现了AutoServiceRegistration这个接口。</p><p><img src="http://fl.ljuuu.com/img/20210317083742.png"></p><p>​    AbstractAutoServiceRegistration类实现了onApplicationEvent抽象方法,并且监听WebServerInitializedEvent事件(当Webserver初始化完成之后) , 调用this.bind ( event )方法。</p><p><img src="http://fl.ljuuu.com/img/20210317083755.png"></p><p>​    最终会调用NacosServiceREgistry.register()方法进行服务注册。</p><p><img src="http://fl.ljuuu.com/img/20210317083808.png"></p><p><img src="http://fl.ljuuu.com/img/20210317083812.png"></p><h3 id="3-3-2、GateWay路由网关源码分析"><a href="#3-3-2、GateWay路由网关源码分析" class="headerlink" title="3.3.2、GateWay路由网关源码分析"></a>3.3.2、GateWay路由网关源码分析</h3><p>​    因为目前SpringCloud未集成Zuul，并且Zuul也已经停止维护，而GateWay与Spring完美集成，因此Pig项目选择用GateWay来做API网关。</p><p>​    GateWay中定义了一个GlobalFilter接口，该接口直译为全局的过滤器，我们知道API网关的本质就是一个或者多个过滤器，因此我们找到该项目中GlobalFilter接口的实现类。</p><p><img src="http://fl.ljuuu.com/img/20210317083832.png"></p><p>​    该类重写了接口中的filter()方法，接收一个ServerWebExchange参数和GatewayFilterChain参数，GatewayFilterChain是一个放行链，其接收参数为一系列过滤器的列表，表示可以对这些过滤器进行建立或者放行。我们重点关注ServerWebExchange参数。</p><p><img src="http://fl.ljuuu.com/img/20210317083843.png"></p><p>​    如上图，ServerWebExchange参数有请求和相应两个数据域，表示从ServerWebExchange参数中我们可以得到从用户那传递过来的请求的具体信息。于是有了下面这一步，从ServerWebExchange中得到请求的信息。</p><p><img src="http://fl.ljuuu.com/img/20210317083854.png"></p><p>然后根据具体的内容，GateWay重写对应的请求路径，将请求实现转发或者重定向。</p><p><img src="http://fl.ljuuu.com/img/20210317083903.png"></p><p>实际上，这里GateWay整个可以看成进入应用程序之前的过滤器，拦截所有请求，然后根据请求内容将请求转发或重定向到具体的业务实现部分，GateWay充当一个中介的作用。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol><li><p><a href="https://www.cnblogs.com/zhangs1986/p/10546973.html">https://www.cnblogs.com/zhangs1986/p/10546973.html</a></p></li><li><p><a href="https://blog.csdn.net/weixin_41217541/article/details/104718834">https://blog.csdn.net/weixin_41217541/article/details/104718834</a></p></li><li><p><a href="https://pig4cloud.com/home">https://pig4cloud.com/home</a></p></li></ol>]]></content:encoded>
      
      
      <category domain="http://zhuferron.github.io/categories/%E5%BE%AE%E6%9C%8D%E5%8A%A1/">微服务</category>
      
      
      <category domain="http://zhuferron.github.io/tags/SpringCloud/">SpringCloud</category>
      
      
      <comments>http://zhuferron.github.io/2021/03/17/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84%E4%BB%A5%E5%8F%8APig%E9%A1%B9%E7%9B%AE%E5%88%86%E6%9E%90(%E4%B8%89)/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>微服务架构及Pig项目分析(一)：微服务简介</title>
      <link>http://zhuferron.github.io/2021/03/17/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84%E4%BB%A5%E5%8F%8APig%E9%A1%B9%E7%9B%AE%E5%88%86%E6%9E%90(%E4%B8%80)/</link>
      <guid>http://zhuferron.github.io/2021/03/17/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84%E4%BB%A5%E5%8F%8APig%E9%A1%B9%E7%9B%AE%E5%88%86%E6%9E%90(%E4%B8%80)/</guid>
      <pubDate>Wed, 17 Mar 2021 00:39:54 GMT</pubDate>
      
      <description>软件体系架构课程论文，这部分主要介绍了微服务的概述和与单体架构的对比</description>
      
      
      
      <content:encoded><![CDATA[<h2 id="1-1、引言"><a href="#1-1、引言" class="headerlink" title="1.1、引言"></a>1.1、引言</h2><p>​    随着互联网技术和社会的快速发展，为了适应日益增长的用户访问量和产品的快速迭代升级，软件体系架构也经历了从繁到简，从最初的单体架构，到后来的MVC架构，再到现在的SOA和微服务架构的发展过程。最初的单体架构，一般一个应用程序就是一个完整的结构体，整个应用程序都只会部署到一个服务器上，但是这种高度耦合性的架构风格存在可维护性，可拓展性不足的缺陷，而且对项目作进一步修改、开发、部署及测试的压力会不断增大，无法满足移动互联网时代业务快速增长和系统快速更新交付的需求。因此微服务架构这种新的架构风格便出现了。</p><p>​    微服务分布式架构具备可扩展性、敏捷性和容错性的优势，同时，容器技术和容器编排管理平台的迅速发展为微服务架构的大规模使用提供了基础支撑，这使得微服务架构逐渐成为了目前最主流的应用解决方案。</p><p><img src="http://fl.ljuuu.com/img/20210317082811.png"></p><h2 id="1-2、概述"><a href="#1-2、概述" class="headerlink" title="1.2、概述"></a>1.2、概述</h2><p>​    服务架构是一种将一个单一应用程序开发为一组小型服务的方法，每个服务运行在自己的进程中，服务间通信采用的轻量级通信机制（通常用HTTP资源API），这些服务围绕业务能力构建并且可通过全自动部署机制独立部署。这些服务公用一个最小型的集中式的管理，服务可用不同的语言进行开发，使用不同的数据储存技术。</p><p>​    下图是目前一个微服务应用程序的架构图，首先用户访问应用程序首先得通过企业防火墙进入负载均衡系统，目前主流的负载均衡技术一般由NGINX来实现，其正向和反向代理技术是负载均衡的核心。负载均衡系统会将工作任务进行平衡、分摊到多个操作单元上进行运行，使不同的任务服务器协同完成工作任务。而微服务架构把传统的架构进行高聚合，低耦合处理，把一个应用程序的开发变成一组服务的开发，把每个具体的服务聚合成一个开发单元，如下图中的图片服务器、文件服务器、群发服务器等等。</p><p><img src="http://fl.ljuuu.com/img/20210317082853.png"></p><h2 id="1-3、单体架构和微服务对比"><a href="#1-3、单体架构和微服务对比" class="headerlink" title="1.3、单体架构和微服务对比"></a>1.3、单体架构和微服务对比</h2><h3 id="1-3-1、微服务架构的优缺点"><a href="#1-3-1、微服务架构的优缺点" class="headerlink" title="1.3.1、微服务架构的优缺点"></a>1.3.1、微服务架构的优缺点</h3><table><thead><tr><th>优点</th><th>缺点</th></tr></thead><tbody><tr><td>易于开发和维护</td><td>运维要求高</td></tr><tr><td>开发和维护单个微服务相对简单</td><td>分布式固有的复杂性</td></tr><tr><td>单个微服务启动较快</td><td>接口调整成本高</td></tr><tr><td>局部修改容易部署</td><td></td></tr><tr><td>技术栈不受限制</td><td></td></tr><tr><td>按需伸缩</td><td></td></tr></tbody></table><h3 id="1-3-2、单体架构的优缺点"><a href="#1-3-2、单体架构的优缺点" class="headerlink" title="1.3.2、单体架构的优缺点"></a>1.3.2、单体架构的优缺点</h3><table><thead><tr><th>优点</th><th>缺点</th></tr></thead><tbody><tr><td>易于开发和测试</td><td>复杂性高</td></tr><tr><td>易于部署</td><td>技术债务</td></tr><tr><td>易于整体扩展</td><td>阻碍技术创新</td></tr></tbody></table>]]></content:encoded>
      
      
      <category domain="http://zhuferron.github.io/categories/%E5%BE%AE%E6%9C%8D%E5%8A%A1/">微服务</category>
      
      
      <category domain="http://zhuferron.github.io/tags/SpringCloud/">SpringCloud</category>
      
      
      <comments>http://zhuferron.github.io/2021/03/17/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84%E4%BB%A5%E5%8F%8APig%E9%A1%B9%E7%9B%AE%E5%88%86%E6%9E%90(%E4%B8%80)/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>初始SpringMVC</title>
      <link>http://zhuferron.github.io/2021/03/17/%E5%88%9D%E8%AF%86SpringMVC/</link>
      <guid>http://zhuferron.github.io/2021/03/17/%E5%88%9D%E8%AF%86SpringMVC/</guid>
      <pubDate>Wed, 17 Mar 2021 00:21:30 GMT</pubDate>
      
      <description>SSM框架部分SpringMVC的学习内容，回顾了servlet实现controller，以及原生态SpringMVC和使用注解实现SpirngMVC</description>
      
      
      
      <content:encoded><![CDATA[<h2 id="1、SpringMVC原理剖析"><a href="#1、SpringMVC原理剖析" class="headerlink" title="1、SpringMVC原理剖析"></a>1、SpringMVC原理剖析</h2><p>SpringMVC是基于Java实现MVC的轻量级Web框架。原来的MVC框架是由servlet，javabean，jsp构成。在SpringMVC中，一切的核心是DispatcherServlet。DispatcherServlet的本质也是一个servlet，用户的所有请求都会通过这个核心的DispatcherServlet，进而协调整个MVC框架。<br>SpringMVC的工作流程如下：</p><ul><li>用户的请求首先会通过DispatcherServlet，DispatcherServlet接收到用户请求的url时，调用HandlerMapping查找对应url的handler，并向DispatcherServlet返回对应的HandlerExecution(handler)。</li><li>DispatcherServlet接收到对应的HandlerExecution，将传递给HandlerAdapter，HandlerAdapter再让具体的控制器(Controller）去执行</li><li>Controller执行业务代码后，将ModelAndView返回给HanderAdapter，HanderAdapter再传递给DispatcherServlet。</li><li>DispatcherServlet接收到ModelAndView结果后，会调用ViewResolver去解析视图。</li><li>DispatcherServlet根据ViewResolver的解析结果，调用具体视图响应给用户。</li></ul><h2 id="2、回顾Servlet"><a href="#2、回顾Servlet" class="headerlink" title="2、回顾Servlet"></a>2、回顾Servlet</h2><p>因为SpringMVC的核心终究还是Servlet，因此在实现SpringMVC之前，我们先来回顾一下之前我们是怎么实现Servlet的。</p><ul><li><p>首先新建一个空Maven项目，删掉其src文件夹，作为本篇文章所有项目的父项目，在父项目中导入相关依赖，同时固定jdk的版本。（因为笔者每次新建项目时jdk默认为1.5，目前对于笔者来说直接使用代码固定jdk版本更方便）</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- Srping依赖 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-webmvc<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.2.9.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- junit单元测试--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.12<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- Servlet依赖 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>javax.servlet<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>javax.servlet-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.0.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- JSP依赖 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>javax.servlet.jsp<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jsp-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- JSTL表达式依赖 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>javax.servlet.jsp.jstl<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jstl-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- Standard标签库 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>taglibs<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>standard<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.1.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--固定jdk版本--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">project.build.sourceEncoding</span>&gt;</span>UTF-8<span class="tag">&lt;/<span class="name">project.build.sourceEncoding</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">maven.compiler.encoding</span>&gt;</span>UTF-8<span class="tag">&lt;/<span class="name">maven.compiler.encoding</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">java.version</span>&gt;</span>11<span class="tag">&lt;/<span class="name">java.version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">maven.compiler.source</span>&gt;</span>11<span class="tag">&lt;/<span class="name">maven.compiler.source</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">maven.compiler.target</span>&gt;</span>11<span class="tag">&lt;/<span class="name">maven.compiler.target</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>新建一个module，添加Web框架支持。</p></li><li><p>编写HelloServlet</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloServlet</span> <span class="keyword">extends</span> <span class="title">HttpServlet</span> </span>&#123;</span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doGet</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line"></span><br><span class="line">       <span class="comment">//业务代码</span></span><br><span class="line">       String msg = <span class="string">&quot;这个Servlet的结果&quot;</span>;</span><br><span class="line">       req.getSession().setAttribute(<span class="string">&quot;msg&quot;</span>,msg);</span><br><span class="line">       <span class="comment">//转发</span></span><br><span class="line">       req.getRequestDispatcher(<span class="string">&quot;/WEB-INF/jsp/test.jsp&quot;</span>).forward(req,resp);</span><br><span class="line"></span><br><span class="line">   &#125;</span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doPost</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">       doGet(req, resp);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>编写前端页面，前端页面提取msg。</p></li><li><p>配置Tomcat，测试。</p><p><img src="http://fl.ljuuu.com/img/20210119151924806.png"></p></li></ul><h2 id="3、原生态SpringMVC"><a href="#3、原生态SpringMVC" class="headerlink" title="3、原生态SpringMVC"></a>3、原生态SpringMVC</h2><ul><li><p>新建一个module，这里建立一个空的Maven项目，同时添加web框架支持。同时在项目结构处新建lib文件夹，手动将依赖导入。（因为不使用模板创建Maven项目有时依赖会无法导入，运行时网页会报404，下面使用注解实现SpringMVC做同样操作）</p></li><li><p>编写web.xml配置文件。在这里注册了SpringMVC的核心DispatcherServlet。因为SpringMVC已经帮我们写好DispatcherServlet，我们只需要直接在web.xml中注册就好了。注册的同时需要绑定springmvc的核心配置文件springmvc-servlet.xml。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">web-app</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://xmlns.jcp.org/xml/ns/javaee&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">version</span>=<span class="string">&quot;4.0&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>springmvc<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span>org.springframework.web.servlet.DispatcherServlet<span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>contextConfigLocation<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>classpath:springmvc-servlet.xml<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">load-on-startup</span>&gt;</span>1<span class="tag">&lt;/<span class="name">load-on-startup</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>springmvc<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">web-app</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>编写核心配置文件springmvc-servlet.xml。在该配置文件中注册SpringMVC中的HandlerMapping，HanderAdapter，ViewResolver。因为这三个SpringMVC也已经帮我们写好了，所以只需要直接注册就行~</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="tag"><span class="string">        https://www.springframework.org/schema/beans/spring-beans.xsd&quot;</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.web.servlet.handler.BeanNameUrlHandlerMapping&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.web.servlet.mvc.SimpleControllerHandlerAdapter&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot;</span> <span class="attr">id</span>=<span class="string">&quot;InternalResourceViewResolver&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;prefix&quot;</span> <span class="attr">value</span>=<span class="string">&quot;/WEB-INF/jsp/&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;suffix&quot;</span> <span class="attr">value</span>=<span class="string">&quot;.jsp&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">    </span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>编写一个控制器HelloController。ModelAndView是用来传递业务结果的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloController</span> <span class="keyword">implements</span> <span class="title">Controller</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ModelAndView <span class="title">handleRequest</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        ModelAndView mav = <span class="keyword">new</span> ModelAndView();</span><br><span class="line"></span><br><span class="line">        mav.addObject(<span class="string">&quot;msg&quot;</span>,<span class="string">&quot;这是SpringMVC的结果&quot;</span>);</span><br><span class="line">        mav.setViewName(<span class="string">&quot;test&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> mav;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>编写完控制器之后，别忘了在springmvc-servlet.xml中注册。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;/t2&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.ferron.controller.HelloController&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>编写前端页面，前端页面提取msg。</p></li><li><p>配置Tomcat，测试</p><p><img src="http://fl.ljuuu.com/img/20210119153755827.png"></p></li></ul><h2 id="4、使用注解实现SpringMVC"><a href="#4、使用注解实现SpringMVC" class="headerlink" title="4、使用注解实现SpringMVC"></a>4、使用注解实现SpringMVC</h2><ul><li><p>新建module，添加web框架支持。</p></li><li><p>编写同上的web.xml配置文件</p></li><li><p>编写核心配置文件springmvc-servlet.xml。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:context</span>=<span class="string">&quot;http://www.springframework.org/schema/context&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:mvc</span>=<span class="string">&quot;http://www.springframework.org/schema/mvc&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="tag"><span class="string">        https://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">        http://www.springframework.org/schema/context</span></span></span><br><span class="line"><span class="tag"><span class="string">        https://www.springframework.org/schema/context/spring-context.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">        http://www.springframework.org/schema/mvc</span></span></span><br><span class="line"><span class="tag"><span class="string">        https://www.springframework.org/schema/mvc/spring-mvc.xsd&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--扫描包下的注解，让注解生效--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">&quot;com.ferron.controller&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mvc:annotation-driven</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot;</span> <span class="attr">id</span>=<span class="string">&quot;InternalResourceViewResolver&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;prefix&quot;</span> <span class="attr">value</span>=<span class="string">&quot;/WEB-INF/jsp/&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;suffix&quot;</span> <span class="attr">value</span>=<span class="string">&quot;.jsp&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>编写一个控制器HelloControllerAnno。使用@Controller注解将其标记为一个控制器，此时就默认注册到springmvc-servlet.xml中了，使用@RequestMapping指定其请求url。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloControllerAnno</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/t3&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">test3</span><span class="params">(Model model)</span></span>&#123;</span><br><span class="line">        model.addAttribute(<span class="string">&quot;msg&quot;</span>,<span class="string">&quot;这是SpringMVC注解的结果&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;test&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>编写前端页面，提取msg。</p></li><li><p>配置Tomcat，测试</p><p><img src="http://fl.ljuuu.com/img/20210119155942891.png"></p></li></ul><h2 id="5、结尾"><a href="#5、结尾" class="headerlink" title="5、结尾"></a>5、结尾</h2><p>笔者是一个喜欢编程的985理工男，金融科技专业。目前在学习Java全栈技术，过段时间可能会开始接触大数据架构、区块链技术、云计算架构和人工智能等技术的学习，这是我第一次写博客，不足之处希望大家多多谅解.</p><p><img src="http://fl.ljuuu.com/img/20210119163223168.png">————————————————<br>版权声明：本文为CSDN博主「Ferron Zhu」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。<br>原文链接：<a href="https://blog.csdn.net/Ferronzhu/article/details/112792747">https://blog.csdn.net/Ferronzhu/article/details/112792747</a></p>]]></content:encoded>
      
      
      <category domain="http://zhuferron.github.io/categories/SSM/">SSM</category>
      
      
      <category domain="http://zhuferron.github.io/tags/Spring/">Spring</category>
      
      
      <comments>http://zhuferron.github.io/2021/03/17/%E5%88%9D%E8%AF%86SpringMVC/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>Redis学习笔记(二)</title>
      <link>http://zhuferron.github.io/2021/03/12/Redis%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(%E4%BA%8C)/</link>
      <guid>http://zhuferron.github.io/2021/03/12/Redis%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(%E4%BA%8C)/</guid>
      <pubDate>Fri, 12 Mar 2021 11:18:44 GMT</pubDate>
      
      <description>Redis第二部分学习笔记，主要介绍了Redis中五种基本数据类型和三种特殊数据类型的使用、以及SpringBoot中如何集成Redis等内容</description>
      
      
      
      <content:encoded><![CDATA[<h2 id="4、数据类型"><a href="#4、数据类型" class="headerlink" title="4、数据类型"></a>4、数据类型</h2><h3 id="4-1、分类"><a href="#4-1、分类" class="headerlink" title="4.1、分类"></a>4.1、分类</h3><p>五种基本数据类型：</p><ul><li>String</li><li>Hash</li><li>List</li><li>Set</li><li>Zset</li></ul><p>三种特殊类型：</p><ul><li>Geospatal 地理位置</li><li>Bitmap</li><li>Hyperloglog 计数</li></ul><h3 id="4-2、Redis-key"><a href="#4-2、Redis-key" class="headerlink" title="4.2、Redis-key"></a>4.2、Redis-key</h3><ul><li><p><code>exists name </code>：判断name属性是否存在，1位存在，0位不存在</p></li><li><p><code>set name 1</code>：设置name为1</p></li><li><p><code>get name</code> ：取出name</p></li><li><p><code>keys *</code>：查看所有的keys</p></li><li><p><code>type name</code>：查看name类型</p></li></ul><h3 id="4-3、String"><a href="#4-3、String" class="headerlink" title="4.3、String"></a>4.3、String</h3><p>基础命令：</p><ul><li><code>append key &quot;hello&quot; </code>：在key后面追加一个hello，若key不存在则相当于set key</li><li><code>strlen key</code>：返回key的长度</li><li><code>incr key </code> ：每次key的值自动加1</li><li><code>decr key</code>： 每次key的值自动减1</li><li><code>incrby key 10</code>：每次key的值自动加10</li><li><code>decrby key 10</code>：每次key的值自动减10</li><li><code>getrange key 0 3</code>：得到key的0-3字符</li><li><code>setrange key 1 xx</code>：替换key中从指定位置开始的字符串</li><li><code>setex(set with expire) key 30 &quot;hello&quot; </code>：设置key为hello，过期时间为30s</li><li><code>setnx(set if not exists) key &quot;hello&quot;</code>：如果存在，设key为hello</li><li><code>mset k1 v1 k2 v2 k3 v3</code>：设置k1为v1，k2为v2，k3为v3</li><li><code>mget k1 k2 k3</code>：取出k1，k2，k3</li></ul><p>高阶命令：</p><ul><li><strong><code>set user:1 &#123;name:ferron,age:3&#125;</code>：设置1号user，name为ferron，age为3</strong></li><li><strong><code>set user:1:name ferron user:2:age 2</code>：同上</strong></li><li><code>getset key &quot;hello&quot;</code>：先得到key的值，然后再将key设为hello，key不存在为nil</li></ul><p>使用场景：value除了是我们的字符串还可以是我们的数字</p><ul><li>计数器</li><li>统计多单位的数量 uid:001:follow 0</li><li>粉丝数</li><li>对象缓存存储！</li></ul><h3 id="4-4、List"><a href="#4-4、List" class="headerlink" title="4.4、List"></a>4.4、List</h3><p>基本的数据类型，列表。</p><p>在Redis里面，我们可以把list变成栈，队列，阻塞队列；Redis不区分大小写命令</p><p>基本命名：</p><ul><li><code>lpush list one</code>：将“one”插入一个list的头部</li><li><code>lrange list 0 -1</code>：取出list中的全部元素</li><li><code>rpush list four</code>：将”four”插入一个list的尾部</li><li><code>lpop list</code>：将list的尾部第一个元素移出</li><li><code>rpop list</code>：将list的头部第一个元素移出</li><li><code>lindex list 1</code>：将list的索引为1的元素取出</li><li><code>llen list</code>：查看list的长度</li><li><code>lrem list 1 one </code>：移除一个one，可移除多个</li><li><code>ltrim list 1 2</code>：截取1和2元素，使list只剩下1和2两个元素</li></ul><p>高阶命令：</p><ul><li><code>rpoplpush list list2  </code>：将list的尾部元素移到list2的头部</li><li><code>lset list 0 item</code>：将list中指定下标的值替换成item，list不存在会报错</li><li><code>linsert list before/after &quot;world&quot; &quot;other&quot; </code>：在list中在world的前面/后面插入other</li></ul><p>小结：</p><ul><li>实际上是一个链表，before Node after，left，right都可以插值</li><li>如果key不存在，创建新的链表</li><li>如果key存在，新增内容</li><li>如果移除了所有值，空链表，表示不存在</li><li>在两边插入或改动值，效率最高，中间元素，相对来说效率较低</li></ul><p>消息排队！消息队列(Lpush Rpop)，栈(Lpush Lpop)</p><h3 id="4-5、Set"><a href="#4-5、Set" class="headerlink" title="4.5、Set"></a>4.5、Set</h3><p>set是无序不重复集合</p><ul><li><code>sadd myset &quot;hello&quot;</code>：将hello添加到myset中</li><li><code>smembers myset</code>：查看myset中元素</li><li><code>sismember myset world</code>：查看world是否在myset中</li><li><code>scard myset</code>：查看myset中的元素个数</li><li><code>srem myset &quot;hello&quot;</code>：移除myset中的hello元素</li><li><code>srandmember myset</code>：在myset中随机抽取一个元素</li><li><code>spop myset</code>：随机删除myset中的元素</li><li><code>smove myset myset2 &quot;hello&quot;</code>：将hello从myset移动到myset2中</li><li><code>sdiff myset myset2</code>：取myset和myset2的差集</li><li><code>sinter myset myset2</code>：取myset和myset2的交集</li><li><code>sunion myset myset2</code>：取myset和myset2的并集</li></ul><h3 id="4-6、Hash"><a href="#4-6、Hash" class="headerlink" title="4.6、Hash"></a>4.6、Hash</h3><p>Map集合：key-Map集合，本质和string没有太大区别</p><ul><li><code>hset myhash name ferron</code>：将myhash中的name设为ferron</li><li><code>hget myhash name</code>：取出myhash中的name</li><li><code>hmset myhash name ferron age 1</code>：将myhash中的name设为ferron，age设为1</li><li><code>hmget myhash name age</code>：取出myhash中的name和age</li><li><code>hgetall myhash</code>：取出myhash中的所有键值对</li><li><code>hdel myhash name</code>：删除myhash指定的key，对应的value也没了</li><li><code>hlen myhash </code>：得到myhash中的键值对数量</li><li><code>hexists myhash name</code>：判断myhash中的name是否存在</li><li><code>hkeys myhash</code>：获得myhash中所有的keys</li><li><code>hvals myhash</code>：获得myhash中所有的values</li><li><code>hincrby myhash age 1</code>：将myhash中的age自增1</li></ul><p>应用：</p><p>hash可以存一个user的数据，将user:1为名字，设置其key为name，age…….</p><p>hash更适合对象的存储，string更适合字符串的存储</p><h3 id="4-7、Zset"><a href="#4-7、Zset" class="headerlink" title="4.7、Zset"></a>4.7、Zset</h3><p>有序集合，在set的基础上增加了一个值</p><ul><li><code>zadd myzset 1 one</code>：在myzset中的插入one元素，其score为1</li><li><code>zrange myset 0 -1</code>：查看myzset中所有的元素</li><li><code>zrangebyscore  myzset -inf +inf</code>：给myzset从小到大排序输出</li><li><code>zrevrange  myzset 0 -1</code>：给myzset从大到小排序输出</li><li><code>zrem myzset one</code>：将myzset中的one移除</li><li><code>zcard myzset</code>：获取myzset中的元素个数</li><li><code>zcount myzset 1 2</code>：获取1-2之间的成员数量</li></ul><p>应用：</p><p>班级成绩表，工资表，带权重的数据</p><h3 id="4-8、Geospatial（Geo）"><a href="#4-8、Geospatial（Geo）" class="headerlink" title="4.8、Geospatial（Geo）"></a>4.8、Geospatial（Geo）</h3><p>可以查询一些测试数据：<a href="https://jingweidu.bmcx.com/">https://jingweidu.bmcx.com/</a></p><ul><li><code>geoadd china:city 116.40 39.90 beijing</code>：在china:city中添加北京的经纬度</li><li><code>geopos china:city beijing</code>：从china:city中获取指定的beijing的经纬度</li><li><code>geodist china:city beijing shanghai km </code>：返回北京和上海的直线距离<ul><li><strong>m</strong> 表示单位为米。</li><li><strong>km</strong> 表示单位为千米。</li><li><strong>mi</strong> 表示单位为英里。</li><li><strong>ft</strong> 表示单位为英尺。</li></ul></li><li><code>georadius china:city 110 30 1000 km withdist  </code>：返回经纬度为110和30，<strong>半径</strong>为1000km内的所有城市</li><li><code>georadius china:city 110 30 1000 km withcoord </code>：返回经纬度为110和30，<strong>直线距离</strong>为1000km内的所有城市</li><li><code>georadiusbymember china:city beijing 1000 km</code>：返回北京周围半径1000km的城市</li><li><code>geohash</code>：返回一个或多个元素的geohash值(将经纬度转换成字符串)</li></ul><p><strong>注意：geo基于zset实现的，所有zset的命令也适用于geo，例如删除等等……</strong></p><h3 id="4-9、hyperloglog-用作计数统计"><a href="#4-9、hyperloglog-用作计数统计" class="headerlink" title="4.9、hyperloglog(用作计数统计)"></a>4.9、hyperloglog(用作计数统计)</h3><p>基数：两个集合中不重复的元素</p><p>A{1,3,5,7,8} B{1,3,5,7,8}</p><p>网页的UV：一个人访问一个网站多次，但是还是算作一个人</p><p>传统的方式：set保存用户的id，然后就可以统计set的元素数量作为标准判断</p><ul><li><code>pfadd mykey a b c d e f g</code>：将abcdefg存入mykey</li><li><code>pdcount mykey</code>：计算mykey中的值</li><li><code>pdmerge mykey3 mykey1 mykey2</code>：将mykey1和mykey2合并成mykey3</li></ul><p>优点：一个mykey最多只有12kb的内存，占用内存小</p><h3 id="4-10、Bitmaps-位存储"><a href="#4-10、Bitmaps-位存储" class="headerlink" title="4.10、Bitmaps(位存储)"></a>4.10、Bitmaps(位存储)</h3><p>统计疫情感染人数：0 0 1 0 1</p><p>Bitmaps位图，也是一种数据结构，都是操作二进制位来进行计算，只有0和1两个状态</p><p><img src="http://fl.ljuuu.com/image-20210301155405110.png" alt="image-20210301155405110"></p><p>将0-6表示一周，则表示每天的打卡情况</p><ul><li><code>setbit mybit 0 1</code>：将mybit中的0设为1</li><li><code>getbit mybit 0</code>：取出mybit中的0</li><li><code>bitcount mybit</code>：统计mybit中1的个数</li></ul><h2 id="5、Redis深入"><a href="#5、Redis深入" class="headerlink" title="5、Redis深入"></a>5、Redis深入</h2><h3 id="5-1、事务"><a href="#5-1、事务" class="headerlink" title="5.1、事务"></a>5.1、事务</h3><p>MySQL：ACID</p><p>Redis事务本质：一组命令的集合，一个事务中的所有命令都会被序列化，在事务执行过程中，会按照顺序执行！</p><p>一次性，顺序性，排他性！</p><p><strong>Redis单条命令是保证原子性，但是事务不保证原子性</strong></p><p>Redis事务也没有隔离级别的概念，所有的命令在事务中，并没有直接背执行，只有发起执行命令的时候才会被执行，Exec</p><p>事务：</p><ul><li>开启事务（multi）</li><li>命令入队（……）</li><li>执行事务（exec）/放弃事务（discard）</li></ul><p>编译型异常：事务中所有的命令都不会被执行</p><p>运行时异常：事务中其他命令也可以正常执行</p><h3 id="5-2、Jedis"><a href="#5-2、Jedis" class="headerlink" title="5.2、Jedis"></a>5.2、Jedis</h3><p>Jedis是Redis官方推荐的java开发工具，是java操作Redis的中间件</p><ul><li><p>导入依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- https://mvnrepository.com/artifact/redis.clients/jedis --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>redis.clients<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jedis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.5.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>fastjson<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.2.62<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>编码测试</p><ul><li>连接数据库</li><li>编写指令</li></ul></li></ul><h3 id="5-3、springboot整合"><a href="#5-3、springboot整合" class="headerlink" title="5.3、springboot整合"></a>5.3、springboot整合</h3><p>springboot操作数据：spring-data！</p><p>springdata也是和springboot齐名的项目</p><p>说明：在springboot2.x之后，原来的jedis被替换成了lettuce</p><p>jedis：采用的直连，多个线程操作的话，是不安全的，如果想要避免不安全的，使用jedis pool连接池</p><p>lettuce：采用netty，实例可以再多个线程进行共享，不存在线程不安全的情况。</p><ul><li><p>创建一个新的springboot项目，然后添加redis依赖</p></li><li><p>配置连接</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#redis连接配置</span></span><br><span class="line"><span class="meta">spring.redis.host</span>=<span class="string">47.115.82.253</span></span><br><span class="line"><span class="meta">spring.redis.port</span>=<span class="string">6379</span></span><br></pre></td></tr></table></figure></li><li><p>测试</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> RedisTemplate redisTemplate;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">contextLoads</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//redisTemplate 操作不同的数据类型</span></span><br><span class="line">    <span class="comment">//opsForValue 操作字符串 类似字符串string</span></span><br><span class="line">    <span class="comment">//opsForList 操作list.......</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//除了基本的操作，我们常用的方法都可以直接通过redisTemplate</span></span><br><span class="line"></span><br><span class="line">    RedisConnection connection = redisTemplate.getConnectionFactory().getConnection();</span><br><span class="line">    System.out.println(connection.ping());</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="5-4、自定义RedisTemplate"><a href="#5-4、自定义RedisTemplate" class="headerlink" title="5.4、自定义RedisTemplate"></a>5.4、自定义RedisTemplate</h3><ul><li><p>定义一个未序列化的pojo类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="meta">@NoArgsConstructor</span></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>测试，将这个对象传入redis中，发现其报未序列化的错误</p></li><li><p>将这个对象序列化，发现才可以正常输出</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> <span class="keyword">throws</span> JsonProcessingException </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//真实的开发一般都使用json来传递对象</span></span><br><span class="line">    User ferron = <span class="keyword">new</span> User(<span class="string">&quot;朱飞龙&quot;</span>, <span class="number">3</span>);</span><br><span class="line">    String jsonUser = <span class="keyword">new</span> ObjectMapper().writeValueAsString(ferron);</span><br><span class="line">    redisTemplate.opsForValue().set(<span class="string">&quot;user&quot;</span>,jsonUser);</span><br><span class="line">    System.out.println(redisTemplate.opsForValue().get(<span class="string">&quot;user&quot;</span>));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>最好的就是User类在定义的时候就直接序列化，这时候序列化之后测试时就不用序列化了</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="meta">@NoArgsConstructor</span></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>自定义一个RedisTemplate</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RedisConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//编写我们自己的redisTemplate</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> RedisTemplate&lt;String, Object&gt; <span class="title">redisTemplate</span><span class="params">(RedisConnectionFactory factory)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        RedisTemplate&lt;String,Object&gt; template = <span class="keyword">new</span> RedisTemplate&lt;String, Object&gt;();</span><br><span class="line">        template.setConnectionFactory(factory);</span><br><span class="line">        Jackson2JsonRedisSerializer&lt;Object&gt; objectJackson2JsonRedisSerializer = <span class="keyword">new</span> Jackson2JsonRedisSerializer(Object.class);</span><br><span class="line">        ObjectMapper om = <span class="keyword">new</span> ObjectMapper();</span><br><span class="line">        om.setVisibility(PropertyAccessor.ALL, JsonAutoDetect.Visibility.ANY);</span><br><span class="line">        om.enableDefaultTyping(ObjectMapper.DefaultTyping.NON_FINAL);</span><br><span class="line">        objectJackson2JsonRedisSerializer.setObjectMapper(om);</span><br><span class="line">        StringRedisSerializer stringRedisSerializer = <span class="keyword">new</span> StringRedisSerializer();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//key采用string的序列化方式</span></span><br><span class="line">        template.setKeySerializer(stringRedisSerializer);</span><br><span class="line">        <span class="comment">//hash的key也采用string的序列化方式</span></span><br><span class="line">        template.setHashKeySerializer(stringRedisSerializer);</span><br><span class="line">        <span class="comment">//value序列化方式采用jackson</span></span><br><span class="line">        template.setValueSerializer(objectJackson2JsonRedisSerializer);</span><br><span class="line">        <span class="comment">//hash序列化采用jackson</span></span><br><span class="line">        template.setValueSerializer(objectJackson2JsonRedisSerializer);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> template;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>使用自定义的RedisTemplate之后，查看redis中的数据</p><p><img src="http://fl.ljuuu.com/image-20210301194502526.png" alt="image-20210301194502526"></p></li></ul>]]></content:encoded>
      
      
      <category domain="http://zhuferron.github.io/categories/%E4%B8%AD%E9%97%B4%E4%BB%B6/">中间件</category>
      
      
      <category domain="http://zhuferron.github.io/tags/Redis/">Redis</category>
      
      
      <comments>http://zhuferron.github.io/2021/03/12/Redis%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(%E4%BA%8C)/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>Docker学习笔记(一)</title>
      <link>http://zhuferron.github.io/2021/03/12/Docker%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(%E4%B8%80)/</link>
      <guid>http://zhuferron.github.io/2021/03/12/Docker%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(%E4%B8%80)/</guid>
      <pubDate>Fri, 12 Mar 2021 11:18:44 GMT</pubDate>
      
      <description>Docker第一部分学习笔记，主要介绍了Docker基本知识、安装和使用、基本命令、以及容器化技术和镜像原理</description>
      
      
      
      <content:encoded><![CDATA[<h2 id="1、Docker概述"><a href="#1、Docker概述" class="headerlink" title="1、Docker概述"></a>1、Docker概述</h2><h3 id="1-1、出现场景"><a href="#1-1、出现场景" class="headerlink" title="1.1、出现场景"></a>1.1、出现场景</h3><p>一款产品：开发–&gt;上线 两套环境！应用环境，应用配置！</p><p>开发—&gt;运维，问题：版本更新，导致服务不可用，对运维考验十分大</p><p>环境配置是十分的麻烦。每一个机器都要配属环境，费时费力！</p><p><strong>发布一个项目(jar+(redis mysql jdk es))，项目能不能带上环境安装打包</strong></p><p>之前在服务器配置一个应用的环境Redis MySQL ….配置很麻烦，windows–&gt;linux</p><p>传统：开发jar，运维来做</p><p>现在：开发打包部署上线，一套流程做完</p><p><img src="http://fl.ljuuu.com/image-20210302105607886.png" alt="image-20210302105607886"></p><p>以上问题Docker能解决！</p><p>Docker的思想来自于集装箱</p><p>隔离：Docker核心思想，打包装箱，每个箱子是互相隔离！</p><h3 id="1-2、Docker功能"><a href="#1-2、Docker功能" class="headerlink" title="1.2、Docker功能"></a>1.2、Docker功能</h3><ul><li>Docker与虚拟机技术的不同：<ul><li>传统虚拟机虚拟出一套硬件，运行一个完整的操作系统</li><li>容器化技术不是模拟一个完整的操作系统</li><li>每个容器间相互隔离，每个容器都有一个属于自己的文件系统，互不影响</li></ul></li><li>DevOps(开发、运维)：<ul><li><strong>应用更快速的交付和部署</strong>，Docker打包镜像发布测试，一键运行</li><li><strong>更便捷的升级和扩缩容</strong>，部署更搭积木一样</li><li><strong>更简单的系统运维</strong>，容器化之后我们的开发，测试环境都是高度一致的</li><li><strong>更高效的计算资源利用</strong>，服务器的性能可以被压榨到极致</li></ul></li></ul><h2 id="2、Docker安装"><a href="#2、Docker安装" class="headerlink" title="2、Docker安装"></a>2、Docker安装</h2><h3 id="2-1、Docker名词"><a href="#2-1、Docker名词" class="headerlink" title="2.1、Docker名词"></a>2.1、Docker名词</h3><p><img src="https://ss0.bdstatic.com/70cFuHSh_Q1YnxGkpoWK1HF6hhy/it/u=793314303,480081697&fm=26&gp=0.jpg" alt="点击查看源网页"></p><p><strong>镜像(image)：</strong>docker镜像好比一个模板，可以通过这个模板来创建容器服务，tomcat镜像–&gt;run–&gt;tomcat01容器(提供服务器)，通过这个镜像可以创建多个容器(最终服务运行或者项目运行就是在容器中)</p><p><strong>容器(container)：</strong>Docker利用容器技术，独立运行一个或者一个组应用，通过镜像来创建的</p><p>启动，停止，删除，基本命令！</p><p>可以把容器理解为一个简易的linux系统</p><p><strong>仓库(repository)：</strong>仓库就是存在镜像的地方，分为公有仓库和私有仓库</p><h3 id="2-2、Docker安装"><a href="#2-2、Docker安装" class="headerlink" title="2.2、Docker安装"></a>2.2、Docker安装</h3><ul><li><p>卸载旧的docker</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">yum remove docker \</span><br><span class="line">                  docker-client \</span><br><span class="line">                  docker-client-latest \</span><br><span class="line">                  docker-common \</span><br><span class="line">                  docker-latest \</span><br><span class="line">                  docker-latest-logrotate \</span><br><span class="line">                  docker-logrotate \</span><br><span class="line">                  docker-engine</span><br></pre></td></tr></table></figure></li><li><p>安装需要的安装包</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install -y yum-utils</span><br></pre></td></tr></table></figure></li><li><p>设置镜像仓库</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">yum-config-manager \</span><br><span class="line">    --add-repo \</span><br><span class="line">    <span class="comment">#https://download.docker.com/linux/centos/docker-ce.repo  #默认是国外的仓库，十分慢，尽量使用国内的</span></span><br><span class="line">   http://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo</span><br></pre></td></tr></table></figure></li><li><p>更新软件包索引</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum makecache fast</span><br></pre></td></tr></table></figure></li><li><p>安装docker相关内容：ce社区版，ee企业版</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install docker-ce docker-ce-cli containerd.io</span><br></pre></td></tr></table></figure></li><li><p>启动docker</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl start docker</span><br></pre></td></tr></table></figure></li><li><p>查看docker版本</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker version</span><br></pre></td></tr></table></figure></li><li><p>启动hello-world测试</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run hello-world</span><br></pre></td></tr></table></figure></li><li><p>查看下载的hello-world镜像</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker images</span><br></pre></td></tr></table></figure></li><li><p>若要卸载docker</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">yum remove docker-ce docker-ce-cli containerd.io</span><br><span class="line">rm -rf /var/lib/docker  <span class="comment">#docker默认工作路径</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="2-3、配置阿里云镜像加速"><a href="#2-3、配置阿里云镜像加速" class="headerlink" title="2.3、配置阿里云镜像加速"></a>2.3、配置阿里云镜像加速</h3><ul><li><p>登录阿里云，找到镜像加速地址</p></li><li><p>设置密码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">******</span><br></pre></td></tr></table></figure></li><li><p>找到镜像加速器</p><p><img src="http://fl.ljuuu.com//image-20210302184015817.png" alt="image-20210302184015817"></p></li><li><p>配置使用</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">sudo mkdir -p /etc/docker</span><br><span class="line">sudo tee /etc/docker/daemon.json &lt;&lt;-<span class="string">&#x27;EOF&#x27;</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;registry-mirrors&quot;</span>: [<span class="string">&quot;https://21iz339s.mirror.aliyuncs.com&quot;</span>]</span><br><span class="line">&#125;</span><br><span class="line">EOF</span><br><span class="line">sudo systemctl daemon-reload</span><br><span class="line">sudo systemctl restart docker</span><br></pre></td></tr></table></figure></li></ul><h3 id="2-4、Docker执行流程"><a href="#2-4、Docker执行流程" class="headerlink" title="2.4、Docker执行流程"></a>2.4、Docker执行流程</h3><ul><li>run的执行过程</li></ul><p><img src="http://fl.ljuuu.com//image-20210302184551342.png" alt="image-20210302184551342"></p><h3 id="2-5、Docker底层原理"><a href="#2-5、Docker底层原理" class="headerlink" title="2.5、Docker底层原理"></a>2.5、Docker底层原理</h3><p>docker是一个Client-Server结构的系统，Docker的守护进程运行在主机上，通过Socket从客户端访问！</p><p>DockerSever接收到Docker-Client的指令，就会执行这个指令</p><p><img src="http://fl.ljuuu.com//image-20210302185207660.png" alt="image-20210302185207660"></p><p><strong>为什么Docker会比虚拟机快？</strong></p><ol><li>Dokcer有着比虚拟机更少的抽象层</li><li>docker利用的是宿主机的内核，vm需要的是guest os</li></ol><p>所有说，新建一个容器的时候，docker不需要向虚拟机一样重新加载一个操作系统内科，避免引导。</p><h2 id="3、Docker命令"><a href="#3、Docker命令" class="headerlink" title="3、Docker命令"></a>3、Docker命令</h2><h3 id="3-1、帮助命令"><a href="#3-1、帮助命令" class="headerlink" title="3.1、帮助命令"></a>3.1、帮助命令</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docker version  <span class="comment">#显示docker的版本信息</span></span><br><span class="line">docker info  <span class="comment">#显示docker更详细的信息</span></span><br><span class="line">docker 命令 --<span class="built_in">help</span>  <span class="comment">#帮助命令</span></span><br></pre></td></tr></table></figure><p>帮助文档的地址：<a href="https://docs.docker.com/reference/">https://docs.docker.com/reference/</a></p><h3 id="3-2、镜像的基本命令"><a href="#3-2、镜像的基本命令" class="headerlink" title="3.2、镜像的基本命令"></a>3.2、镜像的基本命令</h3><ul><li><p><code>docker images</code>：查看本机的所有镜像</p></li><li><p><code>docker search mysql</code>：搜索mysql镜像</p></li><li><p><code>docker pull mysql:5.7</code>：下载5.7的mysql</p></li><li><p><code>docker rmi -f 镜像id</code>：删除指定id的镜像</p></li></ul><h3 id="3-3、容器的基本命令"><a href="#3-3、容器的基本命令" class="headerlink" title="3.3、容器的基本命令"></a>3.3、容器的基本命令</h3><p>说明：有了镜像才可以创建容器，linux，下载一个centos镜像来测试学习</p><ul><li><p><code>docker pull centos</code>：下载一个centos</p></li><li><p><code>docker run [可选参数] image</code>：运行一个镜像</p><ul><li>–name=”Name”：容器名字  tomcat01  tomcat02，用来区分容器</li><li>-d：后台方式运行</li><li>-it：使用交互方式运行，进入容器查看内容</li><li>-p<ul><li>-p ip：主机命令</li><li>-p 主机端口：容器端口(常用)</li><li>-p 容器端口</li></ul></li><li>-p：随机指定端口</li></ul></li><li><p><code>docker ps</code>：列出所有正在运行的容器</p><ul><li>-a：列出当前正在运行的容器+历史运行过的容器</li><li>-n=?：列出最进创建的几个容器</li><li>-q：显示容器的编号</li></ul></li><li><p><code>docker rm 容器id</code>：删除指定id的容器</p></li><li><p><code>docker start 容器id</code>：启动容器</p></li><li><p><code>docker restart 容器id</code>：重启容器</p></li><li><p><code>docker stop 容器id</code>：停止容器</p></li><li><p><code>docker kill 容器id</code>：强制停止容器</p></li></ul><p>测试：</p><ul><li><p>启动并进入容器**(容器就是一个小型的服务器)**</p><p><img src="http://fl.ljuuu.com//image-20210302194016793.png" alt="image-20210302194016793"></p></li><li><p>容器内部文件：</p><p><img src="http://fl.ljuuu.com//image-20210302194047986.png" alt="image-20210302194047986"></p></li><li><p>使用命令<code>exit</code>退出当前容器，并返回主机</p></li><li><p>使用Ctrl+p+q返回主机，容器依旧运行</p></li></ul><h3 id="3-4、常用的其他命令"><a href="#3-4、常用的其他命令" class="headerlink" title="3.4、常用的其他命令"></a>3.4、常用的其他命令</h3><ul><li><code>docker run -d centos</code>：通过后台启动容器，<strong>注意：docker容器使用后台运行，就必须要有一个前台进程，docker发现没有应用，就会自动停止！</strong></li><li><code>docker logs -f -t --tail 10 容器id</code>：查看日志</li><li><code>docker top 容器id</code>：查看容器的进程信息</li><li><code>docker inspect 容器id</code>：查看容器的元数据</li><li><code>docker exec -it 容器id</code>：进入某个容器，进入一个容器开启一个新的命令行</li><li><code>docker attach 容器id</code>：进入某个容器，进入的是当前的命令行</li><li><code>docker cp 容器id:容器内文件路径 主机路径</code>：把容器中文件拷贝到主机</li></ul><h3 id="3-5、安装Nginx"><a href="#3-5、安装Nginx" class="headerlink" title="3.5、安装Nginx"></a>3.5、安装Nginx</h3><ul><li><p>搜索和安装nginx，在docker hub搜索Nginx的版本</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull nginx</span><br></pre></td></tr></table></figure></li><li><p>运行nginx。<strong>端口映射，外网可以通过3344访问服务器内里面的容器(80)</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -d --name nginx01 -p 3344:80 nginx</span><br></pre></td></tr></table></figure></li><li><p>本地自测</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl localhost:3344</span><br></pre></td></tr></table></figure></li></ul><h3 id="3-6、安装Tomcat"><a href="#3-6、安装Tomcat" class="headerlink" title="3.6、安装Tomcat"></a>3.6、安装Tomcat</h3><ul><li><p>搜索tomcat</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker run -it --rm tomcat:9.0  #一般用来测试，用完就删除</span><br><span class="line">docker pull tomcat:9.0 #下载tomcat 用完不会删除</span><br></pre></td></tr></table></figure></li><li><p>运行tomcat。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -d -p 3355:8080 --name tomcat01 tomcat</span><br></pre></td></tr></table></figure></li><li><p>进入容器，发现问题：阿里云镜像的原因，默认是最小的镜像，所以把所有不必要的东西剔除了</p><ul><li>linux命令少了</li><li>没有webapp</li></ul></li></ul><h3 id="3-7、可视化面板安装"><a href="#3-7、可视化面板安装" class="headerlink" title="3.7、可视化面板安装"></a>3.7、可视化面板安装</h3><p><strong>先使用portainer，后面会使用Rancher</strong></p><ul><li><p>下载使用</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker run -d -p 8088:9000 \</span><br><span class="line">--restart=always -v /var/run/docker.sock:/var/run/docker.sock --privileged=<span class="literal">true</span> portainer/portainer</span><br></pre></td></tr></table></figure></li><li><p>外网访问。</p></li><li><p>先登录账户，设置密码</p></li><li><p>选择<code>local</code>进入就行了</p></li></ul><h2 id="4、Docker镜像"><a href="#4、Docker镜像" class="headerlink" title="4、Docker镜像"></a>4、Docker镜像</h2><h3 id="4-1、什么是镜像"><a href="#4-1、什么是镜像" class="headerlink" title="4.1、什么是镜像"></a>4.1、什么是镜像</h3><p>镜像是一种轻量级、可执行的独立软件包，用来打包软件运行环境和基于运行环境开发的软件，它包含运行某个软件所需的所有内容，包括代码、运行时、库、环境变量和配置文件。</p><p>所有的应用，直接打包成为一个docker镜像，就可以直接跑起来</p><p>如何得到镜像：</p><ul><li>从远程仓库下载</li><li>拷贝</li><li>自己制作</li></ul><h3 id="4-2、镜像加载原理"><a href="#4-2、镜像加载原理" class="headerlink" title="4.2、镜像加载原理"></a>4.2、镜像加载原理</h3><ul><li>UnionFS，联合文件系统</li></ul><h3 id="4-3、Commit镜像"><a href="#4-3、Commit镜像" class="headerlink" title="4.3、Commit镜像"></a>4.3、Commit镜像</h3><p>自己制作一个镜像</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">docker commit 提交让其成为一个新的副本</span><br><span class="line"></span><br><span class="line"><span class="comment">#命令和git类似</span></span><br><span class="line"><span class="comment">#官方的tomcat的webapps没有文件，我们想要发布一个有webapps的镜像</span></span><br><span class="line"><span class="comment">#得到自己的镜像</span></span><br><span class="line">cp -r /webapps.dist/* /webapps</span><br><span class="line"><span class="comment">#commit自己的镜像</span></span><br><span class="line">docker commit -a=<span class="string">&quot;ferron&quot;</span> -m=<span class="string">&quot;add webapps app&quot;</span> 容器id tomcat02 tomcat02:1.0</span><br><span class="line"><span class="comment">#查看自己的镜像</span></span><br><span class="line">docker images</span><br></pre></td></tr></table></figure>]]></content:encoded>
      
      
      <category domain="http://zhuferron.github.io/categories/%E4%B8%AD%E9%97%B4%E4%BB%B6/">中间件</category>
      
      
      <category domain="http://zhuferron.github.io/tags/Docker/">Docker</category>
      
      
      <comments>http://zhuferron.github.io/2021/03/12/Docker%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(%E4%B8%80)/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>Redis学习笔记(一)</title>
      <link>http://zhuferron.github.io/2021/03/12/Redis%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(%E4%B8%80)/</link>
      <guid>http://zhuferron.github.io/2021/03/12/Redis%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(%E4%B8%80)/</guid>
      <pubDate>Fri, 12 Mar 2021 11:18:44 GMT</pubDate>
      
      <description>Redis第一部分学习笔记，主要介绍了NoSQL概念、以及Redis入门和安装使用</description>
      
      
      
      <content:encoded><![CDATA[<h2 id="1、概述"><a href="#1、概述" class="headerlink" title="1、概述"></a>1、概述</h2><h3 id="1-1、发展"><a href="#1-1、发展" class="headerlink" title="1.1、发展"></a>1.1、发展</h3><ul><li><p>单机Mysql时代</p><p><img src="http://fl.ljuuu.com/image-20210228091732164.png" alt="image-20210228091732164"></p><p>随着访问量增加会出现许多问题：</p><ul><li>数据量太大，一个机器放不下</li><li>数据的索引(B+ Tree)，一个机器内存放不下</li><li>访问量(读写混合)，一个服务器承受不了</li></ul></li><li><p>缓存+Mysql+垂直拆分</p><p>发展过程：优化数据结构和索引–&gt;文件缓存(IO)–&gt;Memcached</p><p><img src="http://fl.ljuuu.com/image-20210228091856599.png" alt="image-20210228091856599"></p><ul><li>缓存：减轻服务器的压力，使用缓存来保证效率</li><li>垂直拆分：纵向扩展服务器，一般一个网站80%都是在读，因此读写分离(主从复制，主库写，从库读)</li></ul></li><li><p>分库分表+水平拆分+Mysql集群</p><p>早些年MyISAM：表锁，十分影响效率，高并发会出现严重的问题</p><p>Innodb：行锁</p><p><img src="http://fl.ljuuu.com/image-20210228092600004.png" alt="image-20210228092600004"></p><ul><li>每个集群存三分之一的数据</li></ul></li><li><p>如今的时代</p><p><img src="http://fl.ljuuu.com/image-20210228094123601.png" alt="image-20210228094123601"></p><ul><li>数据量很多，变化很快：Mysql等关系型数据库力不从心</li><li>像图片、定位数据这种数据很难用关系型数据库来存储</li></ul></li><li><p>为什么要用Nosql</p><ul><li>用户的个人信息、社交网络、地理位置、用户自己产生的数据、用户日志等数据爆发式增长</li></ul></li></ul><h3 id="1-2、大数据"><a href="#1-2、大数据" class="headerlink" title="1.2、大数据"></a>1.2、大数据</h3><p>大数据时代的3V：</p><ol><li>海量Volume</li><li>多样Variety</li><li>实时Velocity</li></ol><p>大数据时代的3高：</p><ol><li>高并发</li><li>高可扩（随时可以水平拆分）</li><li>高性能（保证用户体验和性能）</li></ol><h2 id="2、Nosql"><a href="#2、Nosql" class="headerlink" title="2、Nosql"></a>2、Nosql</h2><h3 id="2-1、概述"><a href="#2-1、概述" class="headerlink" title="2.1、概述"></a>2.1、概述</h3><p>Nosql=not only sql</p><p>不仅仅是sql，泛指非关系型数据库。——-&gt;Map&lt;String,Object&gt;</p><p>Nosql特点：</p><ol><li><p>方便拓展（数据之间没有关系，很好拓展！）</p></li><li><p>大数据量高性能（Redis一秒写8w次，读取11w次，Nosql的缓存记录级，是一种细粒度的缓存，性能会比较高）</p></li><li><p>数据类型是多样性的（不需要事先设计数据库）</p></li><li><p>传统RDBMS和Nosql区别</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">传统的RDBMS</span><br><span class="line">- 结构化组织</span><br><span class="line">- SQL</span><br><span class="line">- 数据和关系都存在单独的表中</span><br><span class="line">- 操作操作，数据定义语言</span><br><span class="line">- 严格的一致性</span><br><span class="line">- 基础的事务</span><br><span class="line">- .....</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Nosql</span><br><span class="line">- 不仅仅是数据</span><br><span class="line">- 没有固定的查询语言</span><br><span class="line">- 键值对存储，列存储，文档存储，图形数据库(社交关系)</span><br><span class="line">- 最终一致性</span><br><span class="line">- CAP定理和BASE(异地多活)</span><br><span class="line">- 高性能，高可用，高可拓展</span><br><span class="line">- .....</span><br></pre></td></tr></table></figure></li><li><p>真正的实践：RDBMS+NoSQL</p></li></ol><h3 id="2-2、四大分类"><a href="#2-2、四大分类" class="headerlink" title="2.2、四大分类"></a>2.2、四大分类</h3><p><strong>KV键值对：</strong></p><ul><li>新浪：Redis</li><li>美团：Redis+Tair</li><li>阿里、百度：Redis+memachche</li></ul><p><strong>文档型数据库(bson+json一样)：</strong></p><ul><li>MongoDB(一般必须要掌握)：<ul><li>MongoDB是一个基于分布式文件存的数据库，主要用来处理大量的文档</li><li>MongoDB是一个介于关系型数据库和非关系型数据中中间的产品！<strong>是非关系型数据库中功能最丰富，最像关系型数据库的！</strong></li></ul></li><li>ConthDB</li></ul><p><strong>列存储数据库：</strong></p><ul><li>HBase</li><li>分布式文件系统</li></ul><p><strong>图数据库：</strong></p><ul><li>不是存图形的，放的是关系，就是图这种数据结构</li><li>Neo4j，infoGrid</li></ul><h2 id="3、Redis入门"><a href="#3、Redis入门" class="headerlink" title="3、Redis入门"></a>3、Redis入门</h2><h3 id="3-1、概述"><a href="#3-1、概述" class="headerlink" title="3.1、概述"></a>3.1、概述</h3><ul><li>Redis（<strong>Re</strong>mote <strong>Di</strong>ctionary <strong>S</strong>erver )，即远程字典服务</li><li>是一个开源的使用ANSI C语言编写、支持网络、可基于内存亦可持久化的日志型、Key-Value数据库，并提供多种语言的API。</li><li>redis会周期性的把更新的数据写入磁盘或者把修改操作写入追加的记录文件，并且在此基础上实现了master-slave(主从)同步。</li><li>读的速度是110000次/s,写的速度是81000次/s 。</li></ul><h3 id="3-2、功能"><a href="#3-2、功能" class="headerlink" title="3.2、功能"></a>3.2、功能</h3><ul><li>内存存储、持久化，内存是断电即失，所以说持久化很重要（rdb、aof）</li><li>效率高，可以用于高速缓存</li><li>发布订阅系统</li><li>地图信息分析</li><li>计时器、计数器（浏览量）</li><li>……</li></ul><h3 id="3-3、特性"><a href="#3-3、特性" class="headerlink" title="3.3、特性"></a>3.3、特性</h3><ul><li>多样的数据类型</li><li>持久化</li><li>集群</li><li>事务</li><li>…….</li></ul><h3 id="3-4、下载安装（Linux）"><a href="#3-4、下载安装（Linux）" class="headerlink" title="3.4、下载安装（Linux）"></a>3.4、下载安装（Linux）</h3><ul><li><p>下载安装包：<code>redis-6.0.6.tar.gz</code>，放到home目录</p></li><li><p>一般程序放到<code>/opt</code>目录下</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mv redis-6.0.6.tar.gz /opt</span><br></pre></td></tr></table></figure></li><li><p>解压redis</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar -zxvf redis-6.0.6.tar.gz</span><br></pre></td></tr></table></figure></li><li><p>进入redis目录</p><p><img src="http://fl.ljuuu.com/image-20210228133613720.png" alt="image-20210228133613720"></p></li><li><p>安装依赖环境（6.0.1之后版本）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#安装c++</span></span><br><span class="line">yum install gcc-c++</span><br><span class="line"><span class="comment">#查看需要安装的依赖</span></span><br><span class="line">gcc -v</span><br><span class="line"><span class="comment"># 升级到9.1版本</span></span><br><span class="line">yum -y install centos-release-scl  </span><br><span class="line">yum -y install devtoolset-9-gcc devtoolset-9-gcc-c++ devtoolset-9-binutils</span><br><span class="line">scl <span class="built_in">enable</span> devtoolset-9 bash</span><br><span class="line"><span class="comment">#安装依赖</span></span><br><span class="line">make</span><br><span class="line"><span class="comment">#确定安装</span></span><br><span class="line">make install</span><br></pre></td></tr></table></figure></li><li><p>默认安装到<code>/usr/local/bin</code>目录下</p><p><img src="http://fl.ljuuu.com/image-20210228135044676.png" alt="image-20210228135044676"></p></li><li><p>将redis配置文件复制到当前目录下，我们之后使用这个文件进行启动</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cp /opt/redis-6.0.6/redis.conf fconfig/</span><br></pre></td></tr></table></figure></li><li><p>redis默认不是后台启动的，我们修改配置文件使其后台启动</p><p><img src="http://fl.ljuuu.com/image-20210228140010904.png" alt="image-20210228140010904"></p></li><li><p>在<code>/usr/local/bin</code>目录下启动redis</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis-server fconfig/redis.conf <span class="comment">#通过指定的配置文件启动服务</span></span><br></pre></td></tr></table></figure></li><li><p>使用<code>redis-cli</code>连接指定的端口号</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis-cli -p 6379</span><br></pre></td></tr></table></figure></li><li><p>测试</p><p><img src="http://fl.ljuuu.com/image-20210228140448044.png" alt="image-20210228140448044"></p></li><li><p>查看redis进程</p><p><img src="http://fl.ljuuu.com/image-20210228140624062.png" alt="image-20210228140624062"></p></li><li><p>关闭redis服务</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">shutdown</span><br><span class="line"><span class="built_in">exit</span></span><br></pre></td></tr></table></figure></li><li><p>再次查看进程是否存在</p><p><img src="http://fl.ljuuu.com/image-20210228140808293.png" alt="image-20210228140808293"></p></li></ul><h3 id="3-5、测试性能"><a href="#3-5、测试性能" class="headerlink" title="3.5、测试性能"></a>3.5、测试性能</h3><p><strong>redis-benchmark</strong>是一个压力性能测试工具</p><h3 id="3-6、基础知识"><a href="#3-6、基础知识" class="headerlink" title="3.6、基础知识"></a>3.6、基础知识</h3><p>redis默认有16个数据库，默认使用的是第0个数据库</p><p><code>select x</code>：切换数据库，x表示第几个数据库</p><p><code>BDSIZE</code>：查看数据库内数据大小</p><p><code>keys *</code>：查看当前数据库所有的key</p><p><code>flushdb</code>：清除当前数据库的所有数据</p><p><code>flushall</code>：清除所有数据库的所有数据</p><h3 id="3-7、单线程和多线程"><a href="#3-7、单线程和多线程" class="headerlink" title="3.7、单线程和多线程"></a>3.7、单线程和多线程</h3><pre><code>- **Redis是单线程的**。- 官方表示，Redis是基于内存操作的，CPU不是Redis性能瓶颈，Redis的瓶颈是根据机器的内存和网络带宽。- 误区1：高性能的服务器一定是多线程的？- 误区2：多线程一定比单线程效率高？- 核心：Redis是将所有的数据都放在内存中的，所有使用单线程去操作效率就是最高的，而多线程会涉及CPU上下文的切换，这会耗时！对于内存系统来说，如果没有上下文切换，效率就是最高的！多次读写都是在一个CPU上的，在内存情况下，这个就是最佳的方案</code></pre><h2 id=""><a href="#" class="headerlink" title=""></a></h2>]]></content:encoded>
      
      
      <category domain="http://zhuferron.github.io/categories/%E4%B8%AD%E9%97%B4%E4%BB%B6/">中间件</category>
      
      
      <category domain="http://zhuferron.github.io/tags/Redis/">Redis</category>
      
      
      <comments>http://zhuferron.github.io/2021/03/12/Redis%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(%E4%B8%80)/#disqus_thread</comments>
      
    </item>
    
  </channel>
</rss>
